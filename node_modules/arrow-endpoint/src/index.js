const fs = require('fs');
const path = require('path');
const parseJson = require('parse-json');
const schemas = require('axway-schema');
const openAPIUtils = require('@axway/openapi-utils')();
const swaggerMiddleware = require('./swagger-middleware');
const PATH_PATTERN = new RegExp(/(?:\{.*?\})/g);
const EXTENTION_PATTERN = new RegExp(/^x-/);

class Endpoints {
	/**
	 * Loads and validates an endpoint from a given file directory
	 *
	 * @static
	 * @param {string} file - file path of the endpoint to be loaded
	 * @param {array} flows - the array of available flows (used in validation)
	 * @returns {object} promise - resolves to give the loaded endpoint
	 *
	 * @memberOf Endpoints
	 */
	static load(file, flows) {
		return new Promise((resolve, reject) => {
			return fs.readFile(file, async (err, data) => {
				if (err) {
					return reject(err);
				}
				// Check if its a valid JSON
				let swagger;
				try {
					swagger = parseJson(data.toString(), file);
				} catch (ex) {
					const id = path.basename(file, path.extname(file));
					return reject(new Error(`Unable to load endpoint ${id}. ${ex.message}`));
				}
				try {
					const dereferencedSwagger = await openAPIUtils.validateSwagger(swagger);
					const endpoint = Endpoints.validateEndpoint(dereferencedSwagger, flows);
					resolve({
						swagger,
						endpoint
					});
				} catch (ex) {
					reject(ex);
				}
			});
		});
	}

	/**
	 * validates a given endpoint for internal errors. Flows are required in validation.
	 *
	 * @static
	 * @param {object} endpoint - an endpoint's definition
	 * @param {array} flows - an array of the available flows (used in validation)
	 * @returns {object} endpoint - validated endpoint's definition
	 *
	 * @memberOf Endpoints
	 */
	static validateEndpoint(endpoint, flows) {
		const xEnabled = endpoint['x-enabled'] = endpoint['x-enabled'] || { enabled: true };
		let disabled = 0;
		let invalid = 0;
		let total = 0;

		xEnabled.warnings = [];
		xEnabled.errors = [];

		Object.keys(endpoint.paths).forEach((path) => {
			if (EXTENTION_PATTERN.test(path)) {
				return;
			}
			Object.keys(endpoint.paths[path]).forEach((methodName) => {
				if (methodName === 'parameters' || EXTENTION_PATTERN.test(methodName)) {
					return;
				}
				const method = endpoint.paths[path][methodName];
				Endpoints.validateMethod(method, flows);
				if (!Endpoints.isEnabled(method)) {
					if (!Endpoints.isValid(method)) {
						xEnabled.warnings.push(
							`Problem in ${methodName.toUpperCase()} ${path}: ${method['x-enabled'].errors.join()}`
						);
						invalid++;
					} else {
						disabled++;
					}
				}
				total++;

				// If the group is manually disabled, disable each method
				if (!Endpoints.isEnabled(endpoint)) {
					Endpoints.disableEndpoint(method);
				}
			});
		});

		// If the group is manually disabled, do not apply additional validation and bail
		if (!Endpoints.isEnabled(endpoint)) {
			return endpoint;
		}

		// if all methods are disabled, disable the whole group
		if (disabled === total) {
			Endpoints.disableEndpoint(endpoint);
		} else if (invalid === total - disabled) {
			// if all the methods are invalid (contain error), invalidate the whole group
			Endpoints.disableEndpoint(endpoint, 'All methods contain errors');
		}
		return endpoint;
	}

	/**
	 * Validates a given method against flow related errors.
	 *
	 * @static
	 * @param {object} method - a single operation object of a valid swagger doc. https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject
	 * @param {object} flows - an array of the available flows (used in validation)
	 * @memberof Endpoints
	 */
	static validateMethod(method = {}, flows = {}) {
		// start with existing value to support manual enable/disable
		const xEnabled = method['x-enabled'] = method['x-enabled'] || { enabled: true };
		xEnabled.warnings = [];
		xEnabled.errors = [];
		const flowName = method['x-flow'];
		const flow = flows[flowName];
		if (!flowName) {
			Endpoints.disableEndpoint(method);
			delete xEnabled.errors;
		} else if (!flow) {
			Endpoints.disableEndpoint(method, `Flow not found: ${flowName}`);
		} else if (!flow['x-validation'] || !flow['x-validation'].valid) {
			Endpoints.disableEndpoint(method, `Invalid flow: ${flowName}`);
		}
	}

	/**
	 * marks a given endpoint invalid with a given error message. No error means its just disabled
	 *
	 * @static
	 * @param {object} endpoint - an endpoint's definition
	 * @param {string} [error] - optional error message to set
	 * @returns {object} endpoint - the given endpoint's definition marked invalid
	 *
	 * @memberOf Endpoints
	 */
	static disableEndpoint(endpoint, error) {
		const xEnabled = endpoint['x-enabled'] = endpoint['x-enabled'] || {};
		const errors = xEnabled.errors = xEnabled.errors || [];

		// If we're dissabling an endpoint, disable all the methods
		if (endpoint && endpoint.paths) {
			Object.keys(endpoint.paths).forEach(path => {
				if (EXTENTION_PATTERN.test(path)) {
					return;
				}
				Object.keys(endpoint.paths[path]).forEach((methodName) => {
					if (methodName === 'parameters' || EXTENTION_PATTERN.test(methodName)) {
						return;
					}
					const method = endpoint.paths[path][methodName];
					Endpoints.disableEndpoint(method);
				});
			});
		}

		xEnabled.enabled = false;
		error && errors.push(error);
		return endpoint;
	}

	/**
	 * Confirms a given endpoint's active status. Could've been manually disabled w/o any error
	 *
	 * @static
	 * @param {object} endpoint - an endpoint's definition
	 * @returns {boolean}
	 *
	 * @memberOf Endpoints
	 */
	static isEnabled(endpoint) {
		return (endpoint['x-enabled'] && endpoint['x-enabled'].enabled);
	}

	/**
	 * Confirms a given endpoint's validity. Based on the presence of any error.
	 *
	 * @static
	 * @param {object} endpoint - an endpoint's definition
	 * @returns {boolean}
	 *
	 * @memberOf Endpoints
	 */
	static isValid(endpoint) {
		return (!Endpoints.isEnabled(endpoint)
			&& (!endpoint['x-enabled'].errors || endpoint['x-enabled'].errors.length === 0));
	}

	/**
	 * binds the given endpoints to the apibuilder's express app
	 *
	 * @static
	 * @param {object} apibuilderInstance - the running apibuilder instance to be bound with
	 * @param {object} endpoints - the endpoints to be bound
	 * @param {targetRenameCallback} [rename] - a callback function to rename swagger definitions
	 *
	 * @memberOf Endpoints
	 */
	static bind(apibuilderInstance, endpoints, rename) {
		Object.keys(endpoints).forEach((endpointName) => {
			const ep = endpoints[endpointName];
			if (!Endpoints.isEnabled(ep)) {
				const errors = ep['x-enabled'] && ep['x-enabled'].errors;
				errors && errors.length && errors.forEach((errorMessage) => {
					apibuilderInstance.logger.error(`${endpointName} - ${errorMessage}`);
				});
				return;
			}
			const endpoint = schemas.dereference(ep, {
				target: '#/definitions',
				rename
			});
			const basePath = Endpoints.getRuntimeBasePath(apibuilderInstance, endpoint);
			const middlewareMetadata = swaggerMiddleware.middlewareMetadata(basePath, endpoint);
			Object.keys(endpoint.paths).sort((left, right) => {
				// Parameterized paths last
				const lParamCount = (left.match(/{/g) || []).length;
				const rParamCount = (right.match(/{/g) || []).length;

				if (lParamCount > rParamCount) {
					return lParamCount - rParamCount;
				}
				// shortest paths first
				return left > right;
			}).forEach((path) => {
				if (EXTENTION_PATTERN.test(path)) {
					return;
				}
				const bindPath = Endpoints.endpointToExpress(basePath + path);
				let bound = false;
				// adding CORS headers for the OPTIONS request
				apibuilderInstance.app.options(
					bindPath,
					Endpoints.addCors(apibuilderInstance, endpoint.paths[path])
				);
				Object.keys(endpoint.paths[path]).forEach((method) => {
					if (EXTENTION_PATTERN.test(method) || method === 'parameters') {
						return;
					}
					apibuilderInstance.logger.debug(`binding api (${method})`, bindPath);

					// Bind to the express path and apply middlewares
					const EPdefinition = endpoint.paths[path][method];
					if (!Endpoints.isEnabled(EPdefinition)) {
						apibuilderInstance.logger.debug(`binding api failed for (${method})`, bindPath);
						return;
					}
					apibuilderInstance.app[method](
						bindPath,
						Endpoints.addCors(apibuilderInstance, endpoint.paths[path]),
						// ---
						// The following two middlewares
						// must be invoked one after the other in this order
						middlewareMetadata,
						swaggerMiddleware.middlewareParameters,
						// ---
						Endpoints.invokeFlow(apibuilderInstance, endpoint, EPdefinition)
					);
					bound = true;
				});

				if (!bound) {
					return;
				}
				// Bind the error handler
				apibuilderInstance.app.use(bindPath, (err, req, res, next) => { // eslint-disable-line
					// jjp: we trust that the above middleware functions are doing their jobs
					// to not leak unexpected errors.  they were specifically written that way.
					// the purpose of this method is to log and send the "clean" error back to
					// the client.  this is intentional.  the default response is 200, so unless
					// the status code is already set to an error condition, explicitly set it.
					if (res.statusCode < 400) {
						res.status(500);
					}
					res.send({ error: err.message });
				});
			});
		});
	}

	/**
	 * Returns an Express middleware to add CORS headers to the response
	 *
	 * @static
	 * @param {any} apibuilderInstance - the apibuilder instance
	 * @param {any} endpointPathItemObj - the endpoint's path item object containing methods
	 * @returns {function} Express middleware
	 *
	 * @memberOf Endpoints
	 */
	static addCors(apibuilderInstance, endpointPathItemObj = {}) {
		return (req, res, next) => {
			// if cross origin req, extract defined methods and headers for the requested path
			if (apibuilderInstance && apibuilderInstance.isCORSReq(req, apibuilderInstance.config.cors)) {
				const corsConf = { ...(apibuilderInstance.config.cors || {}) },
					preflight = apibuilderInstance.isPreflight(req),
					methods = [],
					headers = {};

				// extract related data from the api object (methods, headers etc)
				if (preflight) {
					Object.keys(endpointPathItemObj).forEach(method => {
						if (EXTENTION_PATTERN.test(method) || method === 'parameters') {
							return;
						}
						methods.push(method.toUpperCase());
					});
				} else {
					Object.keys(endpointPathItemObj).forEach(method => {
						if (EXTENTION_PATTERN.test(method) || method === 'parameters') {
							return;
						}
						const responses = endpointPathItemObj[method].responses;
						// extract headers from the response definition
						responses && Object.keys(responses).forEach(response => {
							const hdrs = responses[response].headers;
							hdrs && Object.keys(hdrs).forEach(header => {
								// storing in an object to avoid dedupe cost
								headers[header] = undefined;
							});
						});
					});
				}

				// insert extracted data into the cors configs to be used by the addCORsHeaders
				corsConf.defMethods = methods;
				corsConf.defHeaders = Object.keys(headers);
				apibuilderInstance.addCORsHeaders(corsConf, req, res);
				if (preflight) {
					return res.status(200).end();
				}
			}
			next();
		};
	}

	/**
	 * Returns an Express middleware to invoke flow
	 *
	 * @static
	 * @param {object} apibuilderInstance - the apibuilder instance
	 * @param {object} endpoint - the endpoint's swagger definition
	 * @param {object} EPdefinition - the specific path/method from the endpoint
	 * @returns {function} Express middleware
	 *
	 * @memberOf Endpoints
	 */
	static invokeFlow(apibuilderInstance, endpoint, EPdefinition) {
		const produces = EPdefinition.produces || endpoint.produces;
		const flowName = EPdefinition['x-flow'];

		// A middleware closure to invoke flow
		return (req, res, next) => {
			const reqlog = apibuilderInstance.logger.scope(req);

			if (produces && !req.accepts(produces)) {
				res.status(406);
				return next();
			} else {
				const flow = apibuilderInstance.flowManager.getFlow(flowName);
				const data = Endpoints.getFlowInput(req, flow, apibuilderInstance);

				apibuilderInstance.flowManager
					.flow(flowName, data, { logger: reqlog })
					.then(
						(result) => {
							const status = (+(result && result.status) || 200);
							const body = result && result.body;
							const headers = result && result.headers;

							if (headers) {
								(Object.keys(headers)).forEach((key) => {
									res.setHeader(key, headers[key]);
								});
								// expose the new headers added by the flow
								let exposeHeaders = res.get['Access-Control-Expose-Headers'];
								exposeHeaders = exposeHeaders ? exposeHeaders.split(/\s*,\s*/) : [];
								exposeHeaders = new Set([ ...exposeHeaders, ...Object.keys(headers) ]);
								exposeHeaders = [ ...exposeHeaders ].join(', ');
								res.setHeader('Access-Control-Expose-Headers', exposeHeaders);
							}

							res.status(status);
							if (body !== undefined) {
								res.setHeader('Content-Type', 'application/json; charset=utf-8');
								res.send(JSON.stringify(body));
							} else {
								res.send();
							}
						}
					)
					.catch((err) => {
						// Unexpected error processing the flow response
						reqlog.error(err);
						const body = { error: 'Server Error' };
						res.status(500).send(body);
					});
			}
		};
	}

	/**
	 * Converts an Swaggger endpoint path to an Express one.
	 *
	 * @static
	 * @param {string} str - the endpoint path to convert.
	 * @returns {string} The express path.
	 *
	 * @memberOf Endpoints
	 */
	static endpointToExpress(str) {
		let match = PATH_PATTERN.exec(str);
		while (match !== null) {
			str = str.replace(/{/, ':').replace(/}/, '');
			match = PATH_PATTERN.exec(str);
		}
		return str;
	}

	/**
	 * Helper to get flow parameters from the swagger context on the request.
 	 *
 	 * @static
 	 * @param {object} req - the Express request object.
 	 * @param {object} flow - The flow.
 	 * @param {object} apibuilder - the API Builder instance
 	 * @returns {object} A map of the deserialized parameters.
 	 *
 	 * @memberOf Endpoints
 	 */
	static getFlowInput(req, flow, apibuilder) {
		// Just to call it out - we're not using `flow` here.  Not yet.  Ideally, we would
		// only copy over those swagger parameters that are also on the flow.  However, we
		// do not have an explicit schema saying that flow must have `params`, `request`,
		// `config`, and `env`, or even that `params` must be an object.  It would be
		// incorrect to select swagger parameters that are not actually direct flow inputs
		// (they would only be properties on the flow parameter `params`, e.g.
		// $.params.username).
		const params = {};
		if (req.swagger && req.swagger.params) {
			Object.keys(req.swagger.params).forEach(paramName => {
				const param = req.swagger.params[paramName];
				params[paramName] = param.value;
			});
		}
		return {
			params,
			request: req,
			config: apibuilder.config,
			env: process.env
		};
	}

	/**
	 * Get the runtime basepath.
 	 *
 	 * @static
 	 * @param {APIBuilder} apibuilder - the API Builder instance.
	 * @param {object} endpoint - the endpoint.
 	 * @returns {string} - the runtime basePath.
 	 *
 	 * @memberOf Endpoints
 	 */
	static getRuntimeBasePath(apibuilder, endpoint) {
		let basePath = apibuilder.config.apiPrefix || '';

		if (endpoint.basePath) {
			basePath += endpoint.basePath;
		}

		return basePath;
	}

	/**
	 * Validate a swagger document - delegates to openapi-utils.
	 *
	 * @static
	 * @param {object} swagger - swagger document
	 * @returns {Promise<object>} the valid swagger document (dereferenced)
	 */
	static async validateSwagger(swagger) {
		return openAPIUtils.validateSwagger(swagger);
	}

}

module.exports = Endpoints;
