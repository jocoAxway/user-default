const swaggerTools = require('swagger-tools');
const stMiddlewareValidator = require('swagger-tools/middleware/swagger-validator');

module.exports = {
	// Express middleware that validates the swagger parameters.
	middlewareParameters: stMiddlewareValidator(),

	// This one is invoked together with the middlewareParameters on each Express path invocation
	middlewareMetadata: (basePath, endpoint) => {
		const replica = getReplica(endpoint);
		// Swagger might be bound to a different basePath than is declared in the Swagger
		replica.basePath = basePath;
		return getSwaggerMetadataMiddleware(replica);
	}
};

/**
 * Returns an Express middleware to deserialize the swagger parameters from the express request.
 *
 * @param {object} endpoint - the endpoint's swagger definition
 * @returns {function} Express middleware
 */
function getSwaggerMetadataMiddleware(endpoint) {
	let middleware;
	return (...args) => {
		if (middleware) {
			return middleware(...args);
		}
		// the metadata generator relies on the endpoint to be cached. It actually
		// runs sync even though it has a callback, and will fail if the cache is
		// not present. calling validate first will populate the cache async then
		// we run the middleware. Ideally we would run resolveRefs which is much
		// faster but that's not exported...
		swaggerTools.initializeMiddleware(endpoint, (options) => {
			const swaggerMetadataMiddleware = options.swaggerMetadata();

			middleware = ((req, res, next) => {
				// TODO: why do we wrap here? Why do we need the custom callback?
				// Also next is not invoked in the case when swagger is not set.
				swaggerMetadataMiddleware(req, res, () => {
					if (!req.swagger) {
						res.status(404);
						res.send();
					} else {
						next && next();
					}
				});
			});

			middleware(...args);
		});
	};
}

/**
 * Clonse the provided JSON file.
 *
 * @param {object} json the file to clone.
 * @returns {object} the cloned file.
 */
function getReplica(json) {
	return JSON.parse(JSON.stringify(json));
}
