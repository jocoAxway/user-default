/**
 * @module nodehandler-utils
 * @typicalname nodehandler-utils
 * @exports nodehandler-utils
 *
 * @example <caption>Quick start</caption>
 * ```javascript
 *  const { NodeHandlerUtils } = require('nodehandler-utils');
 *  const { FlowManager } = require('axway-flow');
 *  const uri = FlowManager.formatNodeHandlerUri('service-connector', 'thing');
 *  const swagger = require('./thing.json');
 *  const schemas =  NodeHandlerUtils.exportSchemas(swagger, 'thing');
 *  const spec =  NodeHandlerUtils.swaggerToNodeHandlerSpec(swagger, 'thing', uri, 'thing-icon');
 *  const icon = NodeHandlerUtils.loadIcon('icon.png');
 * ```
 */
const jsonpointer = require('json-pointer');
const jsonrefs = require('json-refs');
const capitalize = require('capitalize');
const loadicon = require('./load-icon');

// http://json-schema.org/draft-06/schema properties
const draft06 = require('./json-schema-draft-06.json');
const draft06properties = Object.keys(draft06.properties);

const SWAGGER_EXTENSION = /^x-/;

function _pick(obj, ...props) {
	return Object.assign({}, ...props.map(prop => {
		if (obj[prop] !== undefined) {
			return ({ [prop]: obj[prop] });
		}
		return undefined;
	}));
}

function _pickSchemaRelevant(obj, additionalProperties) {
	return _pick(obj, ...draft06properties, ...additionalProperties);
}

function _sanitize(str) {
	return str.replace(/[^a-z0-9_-]+/ig, '');
}

/**
 * This method construct uri only if necessary information is provided in the swagger.
 * Moreover it takes the fits scheme from the list of provided schemes.
 * This probably must be configurable during runtime in the future.
 */

function _constructUri (swagger) {
	const protocol = swagger.schemes ? swagger.schemes[0] : 'http';
	return {
		protocol,
		host: swagger.host,
		basePath: swagger.basePath,
		full: getUri()
	};

	function getUri () {
		if (swagger.host && swagger.basePath) {
			return `${protocol}://${swagger.host}${swagger.basePath}`;
		} else if (swagger.host) {
			// base path is optional
			return `${protocol}://${swagger.host}`;
		} else {
			return undefined;
		}
	}
}

function _cloneRef(obj, pointer) {
	return JSON.parse(JSON.stringify(jsonpointer.get(obj, pointer)));
}

// found inspiration on stackoverflow, but cannot find the source.  merges
// two arrays of parameters using spread.  if duplicate parameter is found,
// it will replace the existing with the merged.  in other words, the last
// duplicate merged will win.
function _mergeParameters(...parameter) {
	return [].concat(...parameter).reduce((result, current) => {
		if (current === undefined) {
			return result;
		}
		const index = result.findIndex(a => {
			return a.name === current.name && a.in === current.in;
		});
		if (index === -1) {
			return result.concat(current);
		}
		// option to do Object.assign(result[index], current), but the
		// spec is unclear.  the parameter is "overriden at the operation
		// level", so I assume it means that its attributes are replaced
		// and not combined.
		result[index] = current;
		return result;
	}, []);
}

// I could find no restrictions on parameter names in Swagger, so I will assume they are
// all valid, and that ':' denotes a regex, e.g. {banana:[a-z]}.  The regex below will
// match any set of characters within brackets {}, but has an optional, non-capturing
// group that starts with ':'.
const reSwaggerParam = new RegExp(/{(.+?)(?::.*?)?}/g);
const reParamName = new RegExp(/[^a-zA-Z0-9]/g);
/**
 * Method to create custom operationID-like operation id. Taken from connectors team
 * NOTE: duplicated from code from arrow-admin-api/src/util.js,
 * @param  {string} swpath   - The swagger path (eg. /thing)
 * @param  {string} method - The swagger method/verb (eg. "GET")
 * @return {string} The custom operationID
 */
function generateFunctionName(swpath, method) {
	const parts = swpath.split(/\//g);
	if (parts.length && parts[0] === '') {
		parts.shift();
	}
	const parsed = parts.reduce((acc, cur) => {
		if (cur.startsWith('{')) {
			reSwaggerParam.lastIndex = 0;
			const match = reSwaggerParam.exec(cur);
			reParamName.lastIndex = 0;
			match[1].split(reParamName).forEach(a => {
				acc.params.push(capitalize(a));
			});
		} else {
			reParamName.lastIndex = 0;
			cur.split(reParamName).forEach(a => {
				acc.slugs.push(capitalize(a));
			});
		}
		return acc;
	}, {
		slugs: [],
		params: []
	});
	if (!parsed.params.length) {
		return method.toLowerCase() + parsed.slugs.join('');
	} else {
		return `${method.toLowerCase()}${parsed.slugs.join('')}By${parsed.params.join('')}`;
	}
}

/**
 * Node handler utils
 * @public
 */
class NodeHandlerUtils {
	/**
	 * Converts conventional #/definitions refs to axway-schema.
	 * @param	{string} ref - local json-pointer
	 * @param	{string} svcname - name of the service connector (sanitized)
	 * @return {string} axway-schema style id/ref
	 * @private
	 */
	static _formatSchemaRef(ref, svcname) {
		// Replace slashes and tilda
		const sanitizedRef = _sanitize(ref.replace('#/definitions/', ''));
		// Convert to schema service URI
		return `schema:///${svcname}/${sanitizedRef}`;
	}

	/**
	 * Recursively sanitizes json-schema by removing non-json-schema properties.
	 * @param	{object} schema - JSON schema object
	 * @return {object} Sanatized json-schema
	 * @private
	 */
	static _sanatizeSchema(schema) {
		if (schema.in) {
			throw new Error(`Invalid JSON schema object (this looks like a Swagger parameter): ${JSON.stringify(schema)}`);
		}
		// http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3
		const allowedFormats = [
			'date-time',
			'email',
			'hostname',
			'ipv4',
			'ipv6',
			'uri',
			'uri-reference',
			'uri-template',
			'json-pointer'
		];

		// Migrate to draft 6
		// http://json-schema.org/draft-06/json-schema-migration-faq.html
		// r.e. exclusiveMinimum & exclusiveMaximum:
		// 'wherever one of these would be true before, change the value to
		// the corresponding "minimum" or "maximum" value and remove the
		// "minimum"/"maximum" keyword'
		if (schema.exclusiveMaximum) {
			schema.exclusiveMaximum = schema.maximum;
			delete schema.maximum;
		} else {
			delete schema.exclusiveMaximum;
		}

		if (schema.exclusiveMinimum) {
			schema.exclusiveMinimum = schema.minimum;
			delete schema.minimum;
		} else {
			delete schema.exclusiveMinimum;
		}

		// http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25
		const allowedTypes = draft06.definitions.simpleTypes.enum;

		// Remove any formats that aren't json-schema compliant. Could update ajv with unknownFormats
		const _removeFormats = (prop) => {
			if (allowedFormats.indexOf(prop.format) < 0) {
				delete prop.format;
			}
		};

		// Only use json-schema compliant types. eg. disallow "type": "file"
		// This is a switch in case we want to cast any types later on
		const _castTypes = (prop) => {
			if (allowedTypes.indexOf(prop.type) < 0) {
				// we can handle special non json-schema types as needed
				switch (prop.type) {
					case undefined:
						break;
					case 'file': // swagger defined
						prop.type = 'object';
						break;
					default:
						prop.type = 'string';
				}
			}
		};

		if (schema.type === 'object') {
			// If the property is of type `object` then we can expect either `properties` or
			// `additionalProperties` to be present.  If present, then those properties also
			// need to be sanitized.
			if (schema.properties) {
				Object.keys(schema.properties).forEach(propertyName => {
					schema.properties[propertyName] = NodeHandlerUtils._sanatizeSchema(
						schema.properties[propertyName]
					);
				});
			}
			if (schema.additionalProperties) {
				schema.additionalProperties = NodeHandlerUtils._sanatizeSchema(
					schema.additionalProperties
				);
			}
		} else if (schema.type === 'array' && schema.items) {
			// If type is array, then sanitize array items
			schema.items = NodeHandlerUtils._sanatizeSchema(schema.items);
		}

		_removeFormats(schema);
		_castTypes(schema);
		schema = _pickSchemaRelevant(schema, [ 'schema', 'id' ]);
		return schema;
	}

	/**
	 * Method to create custom operationID-like operation id. Taken from connectors team
	 * @param  {string} path   - The swagger path (eg. /thing)
	 * @param  {string} method - The swagger method/verb (eg. "GET")
	 * @return {string} The custom operationID
	 * @private
	 */
	static _generateFunctionName(path, method) {
		return generateFunctionName(path, method);
	}

	static _getOutputs(swagger, method) {
		const outputs = NodeHandlerUtils._swaggerResponsesToOutputs(swagger, method);
		outputs.error = {
			name: 'Error',
			context: '$.error',
			description: 'An error occurred during the flow-node execution',
			schema: {
				type: 'object',
				properties: {
					message: {
						description: 'The error message',
						type: 'string'
					},
					stack: {
						description: 'The error stack',
						type: 'string'
					}
				},
				required: [ 'message' ]
			}
		};
		return outputs;
	}

	/**
	 * Converts swagger responses to returns spec.
	 * @param	{object} swagger - swagger doc
	 * @param	{object} method - swagger method
	 * @return {object|array} oneOf schema object or object schema
	 * @private
	 */
	static _swaggerResponsesToOutputs(swagger, method) {
		const outputs = {};
		if (!method.responses.default) {
			// Add a default response if one doesn't exist already
			method.responses.default = {
				description: 'Default response for all HTTP codes not covered by the specification',
				headers: {},
				schema: {}
			};
		}
		for (const code of Object.keys(method.responses)) {
			if (SWAGGER_EXTENSION.test(code)) {
				continue;
			}
			let response = method.responses[code];

			if (response.$ref) {
				// dereference global response
				response = _cloneRef(swagger, response.$ref.substring(1));
			}

			const sanitizedHeaders = Object.keys(response.headers || []).reduce((headers, header) => {
				headers[header] = NodeHandlerUtils._sanatizeSchema(response.headers[header]);
				return headers;
			}, {});

			// The idea here is to wrap an output item, for example:
			// {
			//    status: 200,
			//    headers: { foo: 'bar' },
			//    data: { name: 'foo' }
			// }
			const output = outputs[code] = {
				schema: {
					type: 'object',
					properties: {
						status: {
							type: 'integer'
						},
						headers: {
							type: 'object',
							properties: {
								...sanitizedHeaders
							}
						}
					},
					required: [ 'status', 'headers' ]
				},
				description: response.description,
				context: '$.response'
			};

			if (code === 'default') {
				// Give a friendly capitalised name to default output
				output.name = 'Default';
			} else {
				// The status code should be a const number if the response is not `default`
				output.schema.properties.status.const = parseInt(code, 10);
			}

			// "If this field does not exist, it means no content is returned as part of the response."
			if (response.schema) {
				// If we have a reference, then it should have been registered into
				// axway-schema by now
				if (response.schema.$ref) {
					output.schema.properties.data = {
						$ref: response.schema.$ref
					};
				} else {
					// If there is no reference just sanatize the schema
					output.schema.properties.data = {
						...NodeHandlerUtils._sanatizeSchema(response.schema)
					};
				}
				output.schema.required.push('data');
			}
		}
		return outputs;
	}

	/**
	 * Converts the swagger parameters to json-schema properties.
	 * @param	{object} swagger - swagger doc
	 * @param 	{string} name - The name of the node handler
	 * @param	{object} verb - the method verb
	 * @param	{object} path - the method path under swagger.paths
	 * @return {object}	schema property
	 * @public
	 */
	static getSwaggerMethodAsProperties(swagger, name, verb, path) {
		const cswagger = JSON.parse(JSON.stringify(swagger));
		const method = cswagger.paths[path][verb];
		const safename = _sanitize(name);
		NodeHandlerUtils._rewriteRegisteredSchemaDefinitions(cswagger, safename);
		NodeHandlerUtils._mergeMethodParameters(cswagger);
		return NodeHandlerUtils._getSwaggerMethodAsProperties(cswagger, method);
	}

	/**
	 * Converts the swagger parameters to json-schema properties.
	 * @param	{object} swagger - swagger doc
	 * @param	{object} method	- swagger method object
	 * @return {object}	schema property
	 * @private
	 */
	static _getSwaggerMethodAsProperties(swagger, method) {
		const properties = {};
		const required = [];
		if (method.parameters) {
			for (let parameter of method.parameters) {
				// store these original values as the parameter can get reset if the parameter has
				// a schema (below).
				const orig = {
					required: parameter.required,
					in: parameter.in
				};

				// Delete the swagger required property
				delete parameter.required;

				if (parameter.schema) {
					// If the parameter has a schema, then it effectively ceases to be a swagger
					// parameter and becomes a schema, and should be treated as such.  e.g. a body
					// param that has `schema` does not have a type, the type is in `schema`,
					// however, the swagger parameter may have a name and description (if present,
					// description should be used in preference to the schema description).
					parameter = Object.assign({
						name: parameter.name,
						description: parameter.description
					}, parameter.schema);
				}

				// count duplicate parameters
				const count = method.parameters.filter(
					a => a.name === parameter.name
				).length;

				// Swagger defines unique parameters as `in` and `name`, which causes conflict
				// when converting to properties.  Disambigulate the property name by prefixing `in.`.
				const propertyName = count === 1 ? parameter.name : `${orig.in}.${parameter.name}`;

				// Convert the parameter to a poperty by filtering out the non-schema related bits.
				const property = _pickSchemaRelevant(parameter, [ 'schema', 'id' ]);

				// Sanitize the property as JSON schema
				properties[propertyName] = {
					...NodeHandlerUtils._sanatizeSchema(property)
				};

				if (orig.required) {
					required.push(propertyName);
				}
			}
		}
		return {
			type: 'object',
			additionalProperties: false,
			properties,
			required
		};
	}

	/**
	 * Converts swagger security requirement objects for a method to json-schema properties.
	 * @param {object} swagger - swagger doc
	 * @param	{object} method	- swagger method object
	 * @return {object|null}	schema property
	 * @private
	 */
	static _getSwaggerSecurityAsProperties(swagger, method) {
		const properties = {};
		const required = [];
		const defaultDescriptions = {
			apiKey: 'An API Key',
			oauth2: 'An OAuth Bearer Token',
			basic: 'A base64 encoded username:password combination'
		};

		if (method.security) {
			const requirements = {};

			// get all referenced security requirements
			for (const requirementObject of method.security) {
				for (const scheme in requirementObject) {
					if (!requirements[scheme]) {
						requirements[scheme] = 1;
					} else {
						requirements[scheme]++;
					}
				}
			}

			if (!Object.keys(requirements).length) {
				return null;
			}

			for (const scheme in requirements) {
				// get securityDefinition info for scheme
				const definition = swagger.securityDefinitions[scheme];
				properties[scheme] = {
					type: 'string',
					description: definition.description || defaultDescriptions[definition.type]
				};

				// if a security requirement is listed in each array item, it is required
				if (requirements[scheme] === method.security.length) {
					required.push(scheme);
				}
			}

			return {
				type: 'object',
				additionalProperties: false,
				properties,
				required
			};
		}
		return null;
	}

	/**
	 * Generates a spec for every path/verb pair
	 * @param  {object} swagger     - A swagger document
	 * @param  {object} method      - The method object under verb
	 * @param  {string} description - The description for the path/verb
	 * @return {object}             The full spec for the path/verb
	 * @private
	 */
	static _generateSpec(swagger, method, description) {
		const spec = {
			description,
			parameter: NodeHandlerUtils._getSwaggerMethodAsProperties(swagger, method),
			outputs: NodeHandlerUtils._getOutputs(swagger, method)
		};
		const authz = NodeHandlerUtils._getSwaggerSecurityAsProperties(swagger, method);
		if (authz) {
			spec.authorization = authz;
		}
		return spec;
	}

	/**
	 * Rewrites swagger to use axway-schema references.
	 * @param {object} swagger - A swagger document
	 * @param {string} name - The service name to use for rewriting
	 * @private
	 */
	static _rewriteRegisteredSchemaDefinitions(swagger, name) {
		const refs = jsonrefs.findRefs(swagger, {
			filter: ref => { return ref.uri.startsWith('#/definitions'); }
		});
		const toremove = new Set();
		Object.keys(refs).forEach(refPath => {
			const ref = decodeURIComponent(refs[refPath].uri.substring(1));
			// ensure the ref exists (will throw)
			jsonpointer.get(swagger, ref);
			toremove.add(ref);
			refs[refPath].def.$ref = NodeHandlerUtils._formatSchemaRef(refs[refPath].uri, name);
		});
		// delete all of the "registered" definitions that have been rewritten
		toremove.forEach(a => jsonpointer.remove(swagger, a));
	}

	/**
	 * dereferences security requirement objects from the global security list to produce a single parameter list that can be used as a source of
	 * truth for the method.
	 *
	 * Also deferences paths which use $ref
	 *
	 * The secuirty requirements object is defined as:
	 *     | A declaration of which security schemes are applied for the API as a whole.
	 *     | The list of values describes alternative security schemes that can be used
	 *     | (that is, there is a logical OR between the security requirements).
	 *     | Individual operations can override this definition.
	 * Source: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject
	 *
	 * @param {object} swagger - The swagger document to convert
	 * @private
	 */
	static _mergeMethodSecurity(swagger) {
		for (const mpath in swagger.paths) {
			if (SWAGGER_EXTENSION.test(mpath)) {
				continue;
			}
			if (swagger.paths[mpath].$ref) {
				swagger.paths[mpath] = jsonpointer.get(swagger, swagger.paths[mpath].$ref.substring(1));
			}

			for (const verb in swagger.paths[mpath]) {
				if (verb === 'parameters' || SWAGGER_EXTENSION.test(verb)) {
					continue;
				}
				const method = swagger.paths[mpath][verb];
				const security = method.security || swagger.security;
				security && (method.security = security);
			}
		}
	}

	/**
	 * Merges method parameters from path item parameter list, and also dereferences any from the
	 * global parameter list to produce a single parameter list that can be used as a source of
	 * truth for the method.
	 *
	 * Also deferences paths which use $ref
	 *
	 * The path item parameters are defined:
	 *     | A list of parameters that are applicable for all the operations described under
	 *     | under this path. These parameters can be overridden at the operation
	 *     | level, but cannot be removed there.
	 * Source: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#path-item-object
	 *
	 * @param {object} swagger - The swagger document to convert
	 * @private
	 */
	static _mergeMethodParameters(swagger) {
		for (const mpath in swagger.paths) {
			if (SWAGGER_EXTENSION.test(mpath)) {
				continue;
			}
			if (swagger.paths[mpath].$ref) {
				swagger.paths[mpath] = _cloneRef(swagger, swagger.paths[mpath].$ref.substring(1));
			}

			// A list of parameters that are applicable for all the operations described
			// under this path. These parameters can be overridden at the operation
			// level, but cannot be removed there.
			const pathItemParameters = swagger.paths[mpath].parameters
			&& swagger.paths[mpath].parameters.map(a => {
				if (a.$ref) {
					// dereference global parameter
					return _cloneRef(swagger, a.$ref.substring(1));
				}
				return a;
			});

			for (const verb in swagger.paths[mpath]) {
				if (verb === 'parameters' || SWAGGER_EXTENSION.test(verb)) {
					continue;
				}

				const method = swagger.paths[mpath][verb];

				// dereference any method parameters
				method.parameters = method.parameters && method.parameters.map(a => {
					if (!a.$ref) {
						return a;
					}
					return _cloneRef(swagger, a.$ref.substring(1));
				});

				if (pathItemParameters) {
					const pparams = pathItemParameters.map(a => {
						if (!a.$ref) {
							return Object.assign({}, a);
						}
						return _cloneRef(swagger, a.$ref.substring(1));
					});
					method.parameters = _mergeParameters(pparams, method.parameters);
				}
			}
		}
	}

	/**
	 * Converts a swagger definition to a flow-node spec.  The `uri` uniquely identifies
	 * the flow-node, e.g. nodehandler://service-connector/foo (see `FlowManager.formatNodeHandlerUri`).
	 * @param {object} swagger - The swagger document to convert
	 * @param {string} scope - The flow-node scope used in schema references
	 * @param {string} uri - The unique uri of the flow-node
	 * @param {string} [icon] - The flow-node's icon (defaults to `glyphicon-link`).
	 * @returns {object} flow-node spec
	 * @public
	 */
	static swaggerToNodeHandlerSpec(swagger, scope, uri, icon) {
		if (!swagger) {
			throw new Error('missing required parameter: swagger');
		}
		if (!swagger.info.title) {
			throw new Error('missing required parameter: swagger.info.title');
		}
		if (!scope) {
			throw new Error('missing required parameter: scope');
		}
		if (!uri) {
			throw new Error('missing required parameter: uri');
		}
		const copied = JSON.parse(JSON.stringify(swagger));
		const safename = encodeURIComponent(scope);

		NodeHandlerUtils._rewriteRegisteredSchemaDefinitions(copied, safename);
		NodeHandlerUtils._mergeMethodParameters(copied);
		NodeHandlerUtils._mergeMethodSecurity(copied);

		const spec = {
			schemaVersion: '2',
			type: uri,
			name: swagger.info.title,
			icon: icon || 'glyphicon-link',
			category: 'connector',
			methods: {}
		};

		const metadata = {
			uri: _constructUri(swagger),
			methods: {}
		};

		for (const mpath of Object.keys(copied.paths)) {
			if (SWAGGER_EXTENSION.test(mpath)) {
				continue;
			}
			for (const verb of Object.keys(copied.paths[mpath])) {
				if (verb === 'parameters' || SWAGGER_EXTENSION.test(verb)) {
					continue;
				}
				const method = copied.paths[mpath][verb];
				const customOperationID = method.operationId
					|| NodeHandlerUtils._generateFunctionName(mpath, verb);

				metadata.methods[customOperationID] = {
					path: mpath,
					httpMethod: verb.toUpperCase(),
					security: method.security,
					securityDefinitions: copied.securityDefinitions,
					parameters: method.parameters ? method.parameters.reduce((acc, param) => {
						const place = param.in;
						acc[place].push(param);
						return acc;
					}, {
						query: [],
						header: [],
						path: [],
						body: [],
						formData: []
					}) : []
				};

				spec.methods[customOperationID] = NodeHandlerUtils._generateSpec(
					copied,
					method,
					method.description || method.summary || '',
				);
			}
		}
		return { spec, metadata };
	}

	/**
	 * Exports schema from a swagger document.  Before returning, all of the references are
	 * rewritten to an axway-schema type reference, and identifiers are applied to each
	 * schema.
	 * @param {object} swagger - The swagger document to use to register schemas
	 * @param {string} scope - The flow-node scope used in schema references
	 * @return {array} An array of schemas.
	 * @public
	 */
	static exportSchemas(swagger, scope) {
		if (!swagger.definitions) {
			return [];
		}
		const copied = JSON.parse(JSON.stringify(swagger));
		const safename = encodeURIComponent(scope);

		const refs = jsonrefs.findRefs(copied.definitions, {
			filter: ref => { return ref.uri.startsWith('#/definitions'); }
		});

		// Find all of the $refs in the (copied) swagger definitions section and
		// rewrite them to be axway-schema refs.
		Object.keys(refs).forEach(refPath => {
			const ref = refs[refPath].uri;
			const refID = NodeHandlerUtils._formatSchemaRef(ref, safename);
			refs[refPath].def.$ref = refID;
		});

		const schemas = [];
		// For each definition, assign an identifier to the definition and register schema
		Object.keys(copied.definitions).forEach(key => {
			const refID = NodeHandlerUtils._formatSchemaRef(encodeURIComponent(key), safename);
			const def = NodeHandlerUtils._sanatizeSchema(copied.definitions[key]);
			def.id = refID;
			schemas.push(def);
		});

		return schemas;
	}

	/**
	 * Loads an icon file and returns it as a data URI.  Supports bmp, jpeg, jpg, png, gif,
	 * tiff, and svg.
	 * @param {string} file - The icon file to load.
	 * @return {Promise<string>} The icon data URI.
	 */
	static loadIcon(file) {
		return loadicon(file);
	}

	/**
	 * Formats a nodehandler URI.
	 * @param {string} module - A module name for scope, e.g. "twilio".
	 * @param {string} type - A simple URL safe type name, e.g. "echo".
	 * @return {string} The formatted URI.
	 */
	static formatNodeHandlerUri(module, type) {
		// NOTE: this function should be the same as: axway-flow/flowmanager.js
		if (!module) {
			throw new Error('Invalid argument: module');
		}
		if (!type) {
			throw new Error('Invalid argument: type');
		}
		return `nodehandler://${module}/${type}`;
	}
}

exports = module.exports = NodeHandlerUtils;
