const request = require('request');
const urljoin = require('url-join');
const qs = require('qs');
const WrappedResponse = require('./WrappedResponse');

class TestController {
	constructor(ctx) {
		this.ctx = ctx;
	}

	formatAPIUrl(wrappedRequest) {
		// Format the url
		let path = wrappedRequest.path;

		// Format the path params
		const pathParams = (wrappedRequest.params && wrappedRequest.params.path) || {};
		if (Object.keys(pathParams).length > 0) {
			path = path.replace(/:\w+\?*/g,
				(param) => {
					let optional = false;
					let name = param.substring(1);
					if (name[name.length - 1] === '?') {
						name = name.substring(0, name.length - 1);
						optional = true;
					}

					const value = pathParams[name] !== undefined
						&& pathParams[name] !== null ? pathParams[name] : '';

					if (!optional && !value) {
						throw new Error(`${name} required.`);
					}
					return value;
				}
			);
		}

		// Remove duplicate and trailing slashes
		path = path.replace(/\/{2,}/g, '/').replace(/\/$/g, '');

		// Format the query string
		const queryParams = (wrappedRequest.params && wrappedRequest.params.query) || {};
		if (Object.keys(queryParams).length > 0) {
			// Omit empty params
			Object.keys(queryParams)
				.filter((key) => (queryParams[key] === undefined || queryParams[key] === null || queryParams[key] === ''))
				.forEach(key => { delete queryParams[key]; });
			path = urljoin(path, `?${qs.stringify(queryParams)}`);
		}

		// Connect to local apibuilder
		return `http://127.0.0.1:${this.ctx.apibuilder.port}${path}`;
	}

	testApi(opts, resolve) {
		// Make the request
		const ts = Date.now();

		request(opts, (err, response, body) => {
			const duration = Date.now() - ts;

			if (err) {
				console.error(err);
			}

			// allow the auth plugin to handle the response too and potentially change it
			if (this.ctx.apibuilder.authStrategy) {
				body = this.ctx.apibuilder.authStrategy.applyResponseForTest(response, body);
			}

			const pickResponseFields = () => {
				const { httpVersion, headers, url, statusCode } = response;
				return { httpVersion, headers, url, statusCode };
			};

			resolve(new WrappedResponse({
				success: !err || (response && response.statusCode >= 202) || false,
				response: response ? pickResponseFields() : { statusCode: 404 },
				result: body,
				responseTime: duration,
				responseSize: (response && response.headers['content-length']) || 0
			}));
		});
	}

	invoke(wrappedRequest, headers) {
		return new Promise((resolve) => {
			// Verify the API exists
			const api = this.ctx.apibuilder.getAPI(wrappedRequest.path, wrappedRequest.method);

			if (!api) {
				console.error(`No api found for ${wrappedRequest.method} ${wrappedRequest.path}`);
				resolve(new WrappedResponse({
					success: false,
					response: {
						statusCode: 400
					},
					responseTime: 0
				}));
				return;
			}

			let url;
			try {
				url = this.formatAPIUrl(wrappedRequest);
			} catch (err) {
				resolve(new WrappedResponse({
					success: false,
					response: {
						statusCode: 400
					},
					result: err.message,
					responseSize: 0,
					responseTime: 0
				}));
				return;
			}

			const opts = {
				method: wrappedRequest.method || 'GET',
				url,
				headers: {
					cookie: headers.cookie
				}
			};

			// Pass the request body
			if (wrappedRequest.params && wrappedRequest.params.body) {
				if (typeof wrappedRequest.params.body === 'object') {
					opts.json = wrappedRequest.params.body;
				} else {
					opts.body = wrappedRequest.params.body;
				}
			}

			// Configure the request settings
			opts.followRedirect = !!wrappedRequest.followRedirect;
			opts.followAllRedirects = !!wrappedRequest.followRedirect;
			opts.gzip = !!wrappedRequest.gzip;

			// Configure the headers
			if (wrappedRequest.headers) {
				Object.keys(wrappedRequest.headers).forEach(name => {
					opts.headers[name] = wrappedRequest.headers[name];
				});
			}
			opts.headers['Content-Type'] = opts.headers['Content-Type'] || 'application/json';
			opts.headers['User-Agent'] = opts.headers['User-Agent'] || 'Appcelerator API Tester/1.0';

			// Add our authentication as required by the authentication plugin
			if (this.ctx.apibuilder.authStrategy) {
				this.ctx.apibuilder.authStrategy.applyCredentialsForTest(opts);
			}

			// Make the request & resolve the promise
			this.testApi(opts, resolve);
		});
	}
}

exports = module.exports = TestController;
