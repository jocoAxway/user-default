const fs = require('fs');
const path = require('path');
const ServerConfiguration = require('./ServerConfiguration');
const NotFoundError = require('../errors/NotFoundError');

const envRegex = /^(?:.*\.)?(?:default|local)\.js$/;

/**
 * The controller implementing the actions for interacting with the server configuration..
 * @public
 */
class ConfigurationController {
	/**
	 * Create a ConfigurationController.
	 * @param {object} ctx - The context for this controller.
	 * @param {express} ctx.app - The express application.
	 * @param {string} ctx.prefix - The prefix bound to.
	 * @param {APIBuilder} ctx.apibuilder - The API Builder server.
	 * @param {Swagger} ctx.swagger - openapi-doc instance.
	 */
	constructor(ctx) {
		this.ctx = ctx;
		this.confDir = path.resolve(
			path.join(this.ctx.apibuilder.config.dir || process.cwd(), 'conf')
		);
	}

	/**
	* Sanitize name and resolve it as a child of the configuration directory.
	* @param {string} name - The configuration file name to resolve to a path.
	* @return {string} path - The configuration file path.
	* @private
	*/
	safeFilename(name) {
		return path.relative(path.sep, path.join(path.sep, name));
	}

	/**
	* Check if the file exists and is readable.
	* @param {string} filepath - The configuration file path.
	* @return {Promise} promise - A promise that will resolve with true or false to indicate acccess..
	* @private
	*/
	checkAccess(filepath) {
		return new Promise(
			(resolve, reject) => {
				fs.stat(filepath,
					(err, stats) => {
						if (err) {
							reject(err);
						} else {
							resolve(stats.isFile());
						}
					}
				);
			}).then(() => new Promise(
			(resolve) => {
				fs.access(
					filepath,
					fs.constants ? fs.constants.R_OK : fs.R_OK,
					(hasAccess) => resolve(!hasAccess));
			}
		)
		);
	}

	/**
	 * Get the specified configuration file.
	 * @param {string} name - The configuration file name.
	 * @return {Promise} - Resolves with the file name and content.
	 * @private
	 */
	readConfigFile(name) {
		const safeName = this.safeFilename(name);
		const filepath = path.join(this.confDir, safeName);

		return this.checkAccess(filepath).then((hasAccess) => {
			if (!hasAccess) {
				throw new NotFoundError(name);
			}

			return new Promise((resolve, reject) => {
				// Read the file
				fs.readFile(filepath, 'utf8', (err, data) => {
					if (err) {
						reject(err);
					} else {
						resolve({
							name: safeName,
							content: data
						});
					}
				});
			});
		});
	}

	/**
	 * Get the specfied configuration file.
	 * @param {string} name - The configuration file name.
	 * @return {Promise} - Resolves with the file name, content and environments.
	 */
	getConfig(name) {
		return Promise.race([
			new Promise((resolve, reject) => {
				if (!envRegex.test(name) || name.startsWith('.')) {
					reject(new NotFoundError(name));
				}
			}),
			this.readConfigFile(name).then(
				(config) => new ServerConfiguration(config.name, config.content)
			)
		]);
	}

	/**
	 * Update the specfied configuration file.
	 * @param {string} name - The configuration file name.
	 * @param {ServerConfiguration} config - The configuration file content.
	 * @return {Promise} - Resolves with the file name, content and environments.
	 */
	updateConfig(name, config) {
		const safeName = this.safeFilename(name);
		const filepath = path.join(this.confDir, safeName);

		return this.getConfig(name).then(
			() => new Promise((resolve, reject) => {
				fs.writeFile(filepath, config.content, 'utf8', (err) => {
					if (err) {
						reject(err);
					} else {
						resolve();
					}
				});
			})
		);
	}

	/**
	 * List all the configuration files, optionally filter by environment.
	 * @return {Promise} - Resolves with an array of SystemConfig with no content.
	 */
	listConfigs() {
		return new Promise((resolve, reject) => {
			const files = [];
			fs.readdir(this.confDir, 'utf8', (err, fileNames) => {
				if (err) {
					return reject(err);
				}
				const paths = fileNames
					.filter(fn => !fn.startsWith('.') && envRegex.test(fn));

				const promises = paths.map((fn) => {
					return new Promise((resolve2, reject2) => {
						fs.stat(path.join(this.confDir, fn), (err, stats) => {
							if (err) {
								reject2(err);
							} else {
								resolve2(stats);
							}
						});
					});
				});

				Promise.all(promises).then(stats => {
					stats.forEach((stat, i) => {
						if (!stat.isDirectory()) {
							files.push(new ServerConfiguration(paths[i]));
						}
					});
					resolve(files);
				}).catch(err => {
					reject(err);
				});
			});
		});
	}
}

exports = module.exports = ConfigurationController;
