const fs = require('fs');
const path = require('path');
const BadRequestError = require('../errors/BadRequestError');

const ALLOWED_MODEL_PROPS = [
	'actions',
	'connector',
	'description',
	'fields',
	'metadata',
	'plural',
	'singular'
];
const ALLOWED_FIELD_PROPS = [
	'default',
	'description',
	'model',
	'name',
	'type',
	'required',
	'readonly',
	'validator'
];

/**
 * Generates code from current model.  Ideally, this should be within the arrow-orm.
 * @param {object} model - model to generate code from
 * @returns {string} generated javascript for model
 */
function generateCode(model) {
	// Check for required properties
	if (!model.name) {
		throw new BadRequestError('missing required property: name');
	}

	if (!model.connector
		|| (typeof (model.connector) === 'object' && !model.connector.name)) {
		throw new BadRequestError('missing or invalid property: connector');
	}
	if (!model.fields
		|| typeof (model.fields) !== 'object'
		|| !Object.keys(model.fields).length) {
		throw new BadRequestError('missing or invalid property: fields');
	}

	// Preserve the model name, but escape single quotes
	const modelName = model.name.replace(/'/g, '\\\'');

	Object.keys(model).forEach(key => {
		if (key === 'fields') {
			Object.keys(model[key]).forEach(field => {
				Object.keys(model[key][field]).forEach(attr => {
					if (ALLOWED_FIELD_PROPS.indexOf(attr) < 0) {
						delete model[key][field][attr]; // not allowed
					} else if (attr === 'default') {
						if (model[key][field][attr] === '') {
							// when: default; deletes when empty (and only if empty)
							delete model[key][field][attr];
						}
					} else if (attr !== 'actions' && !model[key][field][attr]) {
						// when: readonly, required; deletes when false
						// when: description, name, type; deletes when empty
						// when: actions; do nothing
						delete model[key][field][attr];
					}
				});
			});
		}
		if (ALLOWED_MODEL_PROPS.indexOf(key) < 0) {
			delete model[key]; // not allowed
		} else if (key === 'connector') {
			if (typeof (model[key]) === 'object') {
				model[key] = model[key].name; // convert the connector to a string name
			}
		} else if (key === 'metadata' && !Object.keys(model[key]).length) {
			delete model[key]; // redundant
		} else if (!model[key]) {
			// when: connector, fields, metadata; deletes when empty
			delete model[key];
		}
	});

	const modelPrefix = `var APIBuilder = require('@axway/api-builder-runtime');\nvar Model = APIBuilder.createModel('${modelName}', `;
	const modelBookend = ');\nmodule.exports = Model;';
	const generatedCode = `${modelPrefix}${JSON.stringify(model, null, 4)}${modelBookend}`;
	return generatedCode;
}

class ModelsController {
	constructor(ctx) {
		this.ctx = ctx;
		if (!this.ctx.apibuilder.createModel) {
			throw new BadRequestError('APIBuilder.createModel is not defined');
		}
		this.modelsDir = path.resolve(
			path.join(this.ctx.apibuilder.config.dir || process.cwd(), 'models')
		);
	}

	/**
	* List all the models.
	* @return {Model} models - The models that API Builder has loaded.
	* @private
	*/
	getModels() {
		return new Promise((resolve, reject) => {
			const models = this.ctx.apibuilder.getModels();
			if (!models) {
				reject(new Error('Unable to list models from API Builder.'));
			} else {
				// The APIBuilder.Model has a toJson that's more restrictive that limits the data, so re-compose
				// the model list to avoid the issue.
				const bareModels = {};
				Object.keys(models).forEach(m => {
					// Shallow copy the model and remove unwanted top-level fields
					bareModels[m] = Object.assign({}, models[m]);
					bareModels[m].filename && delete bareModels[m].filename;
				});
				resolve(bareModels);
			}
		});
	}

	/**
	* Sanitize name and resolve it to prevent directory traversal.
	* @param {string} name - The name to make safe.
	* @return {string} path - The safe filename.
	* @private
	*/
	safeFilename(name) {
		return path.relative(path.sep, path.join(path.sep, name));
	}

	/**
	* Create a model file with the specified definition.  Note that _currently_, there is
	* no UI validation of the model name, and all "enforcement" is handled in the orm.  The
	* rules are that any character that will be encoded as a URI is an invalid character
	* (e.g. < > \\ | ""), but also '.'.  There is currently no file name escaping when we
	* write the model to disk.
	*
	* @param {Model} modelDef - The mode to create.
	* @return {Promise} promise - A promise that resolves when the file has been written.
	* @private
	*/
	createModel(modelDef) {
		return new Promise((resolve, reject) => {
			try {
				if (!modelDef || !modelDef.name) {
					reject('invalid model definition');
					return;
				}

				// Deep copy model
				const definition = JSON.parse(JSON.stringify(modelDef));
				const safeName = `${this.safeFilename(definition.name)}.js`;
				const filepath = path.join(this.modelsDir, safeName);

				// NOTE: the following code uses APIBuilder to validate models.  to make it
				// work, it is necessary to "tweak" things to allow createModel to be
				// called successfully.  It needs to remove the model, and dynamically
				// load the connector for it.
				// ------------------------------------
				// BEGIN: tweak
				// check to see if the current model exists and if it does remove
				// it (otherwise, it will throw an error).  the server will be restaring
				// anyway.  removing only removes from memory.
				try {
					const exists = this.ctx.apibuilder.getModel(definition.name);
					if (exists) {
						this.ctx.apibuilder.removeModel(definition);
					}
				} catch (ex) {
					// okay to gobble error
				}
				// convert the connector object to string to allow the apibuilder code
				// to dynamically resolve the connector.
				if (definition.connector && definition.connector.name) {
					definition.connector = definition.connector.name;
				}
				// ------------------------------------
				// END: tweak

				// validates the model before saving
				this.ctx.apibuilder.createModel(definition.name, definition);

				const code = generateCode(definition);

				fs.writeFile(
					filepath, code,
					{
						flag: 'w',
						encoding: 'utf-8',
						mode: 0o644
					},
					(err) => {
						if (err) {
							reject(err);
						} else {
							resolve(definition.name);
						}
					}
				);
			} catch (ex) {
				reject(ex);
			}
		});
	}
}

exports = module.exports = ModelsController;
