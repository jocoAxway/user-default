const APIProvider = require('../APIProvider');
const BadRequestError = require('../errors/BadRequestError');
const Model = require('./Model');

class ModelsAPI extends APIProvider {
	static bind(controller) {
		const swagger = controller.ctx.swagger;

		swagger
			.schema('Model', Model.schema);

		swagger
			.get('/models')
			.operationId('getModels')
			.tag('model')
			.summary('Gets a list of API Builder Models')
			.response(200, 'OK', 'Model', true)
			.response(500)
			.action((req, res) => {
				try {
					controller.getModels()
						.then((data) => {
							res.status(200).send(data);
						})
						.catch((err) => {
							APIProvider.handleError(err, res, 500);
						});
				} catch (err) {
					APIProvider.handleError(err, res, 500);
				}
			});

		swagger
			.post('/models')
			.operationId('createModel')
			.tag('model')
			.summary('Creates a new model')
			.parameter({
				in: 'body',
				name: 'definition',
				schema: {
					// If anyone is wondering, why body.model, I expect that we will
					// eventually need to also support the custom code, and validation
					// functions.
					type: 'object',
					properties: {
						model: {
							$ref: '#/definitions/Model'
						}
					}
				},
				description: 'API Builder Model definition',
				required: true })
			.response(201)
			.response(400)
			.response(500)
			.action((req, res) => {
				try {
					const isValid = Model.validate(req.body.model);
					if (isValid) {
						const model = req.body.model;
						controller.createModel(model)
							.then(name => {
								res.status(201).send(name);
								controller.ctx.apibuilder.emit('reload');
							})
							.catch((err) => {
								APIProvider.handleError(err, res, 400, 500);
							});
					} else {
						APIProvider.handleError(new BadRequestError('Invalid model.'), res, 400, 500);
					}
				} catch (err) {
					APIProvider.handleError(err, res, 400, 500);
				}
			});
	}
}

exports = module.exports = ModelsAPI;
