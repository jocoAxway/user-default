const APIProvider = require('../APIProvider');

/**
 * API for interacting with the Endpoints.
 * @public
 */
class FlowsAPI extends APIProvider {
	/**
	 * Bind the paths to the controller methods.
	 *
	 * @param {EndpointsController} controller - The main controller providing the
	 *                                         implementation for this API.
	 */
	static bind(controller) {
		const swagger = controller.ctx.swagger;

		// https://techweb.axway.com/jira/browse/RDPP-2086
		// FIXME: Swagger 2.0 only supports a limited subset of JSON schema draft 04.
		// See: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#schema-object
		// This means that it is not possible to represent our flow schema in a Swagger 2.0
		// document because we use things like (oneOf, allOf).  The only choice here is to upgrade to
		// use Swagger 3.0, which allegedly supports them
		// See: https://blog.readme.io/an-example-filled-guide-to-swagger-3-2/#formatchanges
		// When fixed, replace with:
		const flowschema = {
			// $ref: 'http://axway.com/schemas/flowschema.json#/flow-schema'
			type: 'object'
		};

		swagger
			.schema('FlowValidateResponse', {
				type: 'object'
			});

		swagger
			.get('/flows/:flowId')
			.operationId('getFlow')
			.tag('flow')
			.summary('Gets a flow.')
			.parameter({
				in: 'path',
				name: 'flowId',
				type: 'string',
				description: 'The unique id of the flow to retrieve.'
			})
			.response(200, 'OK', flowschema)
			.response(404)
			.response(500)
			.action((req, res) => {
				try {
					let flowId;
					if (req.params.flowId) {
						// decode group
						flowId = decodeURIComponent(req.params.flowId);
					}
					controller.getFlow(flowId)
						.then(flow => {
							res.status(200).send(flow);
						})
						.catch(err => {
							APIProvider.handleError(err, res, 404, 500);
						});
				} catch (err) {
					APIProvider.handleError(err, res, 400, 500);
				}
			});

		swagger
			.put('/flows/validate')
			.operationId('validateFlow')
			.tag('flow')
			.summary('Validates a flow and returns a validation response.  The property `valid` indicates whether or not the flow is valid or not.')
			.parameter({
				in: 'body',
				name: 'flow',
				schema: flowschema,
				description: 'The flow to validate.'
			})
			.response(200, 'OK', 'FlowValidateResponse')
			.response(400)
			.response(500)
			.action((req, res) => {
				try {
					const flow = req.body;

					controller.validateFlow(flow)
						.then(result => {
							res.status(200).send(result);
						})
						.catch(err => {
							APIProvider.handleError(err, res, 400, 500);
						});
				} catch (err) {
					APIProvider.handleError(err, res, 400, 500);
				}
			});

		swagger
			.post('/flows/:flowId')
			.operationId('updateFlow')
			.tag('flow')
			.summary('Updates a flow, or creates it if it does not exist.')
			.parameter({
				in: 'path',
				name: 'flowId',
				type: 'string',
				description: 'The unique id of the flow to update.'
			})
			.parameter({
				in: 'body',
				name: 'flow',
				schema: flowschema,
				description: 'The flow to update.'
			})
			.response(204)
			.response(400)
			.response(500)
			.action((req, res) => {
				try {
					const flowId = req.params.flowId ? decodeURIComponent(req.params.flowId) : null;
					const flow = req.body;

					controller.saveFlow(flowId, flow)
						.then(() => {
							res.status(204).send();
							controller.ctx.apibuilder.emit('reload');
						})
						.catch(err => {
							APIProvider.handleError(err, res, 400, 500);
						});
				} catch (err) {
					console.error('error saving flow', err);
					APIProvider.handleError(err, res, 400, 500);
				}
			});
	}
}

exports = module.exports = FlowsAPI;
