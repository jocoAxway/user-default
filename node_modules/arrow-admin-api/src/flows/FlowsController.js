const path = require('path');
const fs = require('fs');
const async = require('async');
const BadRequestError = require('../errors/BadRequestError');
const NotFoundError = require('../errors/NotFoundError');
const InternalServerError = require('../errors/InternalServerError');
const { mkdirIfNotExists, isSafeFilename } = require('../util');

/**
 * The controller implementing the actions for interacting with Flows.
 * @public
 */
class FlowsController {
	/**
	 * Create a ProjectController.
	 * @param {object} ctx - The context for this controller.
	 * @param {express} ctx.app - The express application.
	 * @param {string} ctx.prefix - The prefix bound to.
	 * @param {APIBuilder} ctx.apibuilder - The API Builder server.
	 * @param {Swagger} ctx.swagger - openapi-doc instance.
	 */
	constructor(ctx) {
		this.ctx = ctx;
		this.flowsDir = path.resolve(
			path.join(this.ctx.apibuilder.config.dir || process.cwd(), 'flows')
		);
		this.logger = this.ctx.apibuilder.logger;
		this.flowManager = this.ctx.apibuilder.flowManager;
	}

	/**
	 * Get a flow
	 * @param {string} flowId - The name of the Flow to get
	 * @returns {Promise} - Resolves to a flow on success.
	 */
	getFlow(flowId) {
		this.logger && this.logger.trace(`Getting flow: ${flowId}`);
		return new Promise((resolve, reject) => {
			if (!flowId) {
				return reject(new BadRequestError());
			}
			const flow = this.ctx.apibuilder.getFlow(flowId);
			if (!flow) {
				return reject(new NotFoundError());
			}
			return resolve(flow);
		});
	}

	/**
	 * Checks to see if `flowId` already exists.
	 * @param {string} flowId - The flow to check.
	 * @returns {Promise<boolean>} True if the flow exists.
	 */
	exists(flowId) {
		this.logger && this.logger.trace(`Getting flow: ${flowId}`);
		return new Promise((resolve, reject) => {
			if (!flowId) {
				return reject(new BadRequestError());
			}
			return resolve(!!this.ctx.apibuilder.getFlow(flowId));
		});
	}

	/**
	 * Delete a flow by name.
	 * @param  {string} flowId - name of the flowfile (x-flow)
	 * @returns {Promise}
	 */
	deleteFlow(flowId) {
		this.logger && this.logger.trace(`Deleting flow: ${flowId}`);
		return new Promise((resolve, reject) => {
			if (!flowId) {
				return reject(new BadRequestError('Missing parameter: flowId'));
			}
			if (!isSafeFilename(flowId)) {
				// Reject the request if the flowId is not a valid (safe) id.
				return reject(new BadRequestError('Invalid parameter: flowId'));
			}

			const flowFilePath = path.join(this.flowsDir, `${flowId}.json`);
			return async.series([
				next => fs.stat(flowFilePath, next),
				next => fs.unlink(flowFilePath, next)
			], (err) => {
				if (err) {
					this.logger && this.logger.error(err);
					// security - do not reject with err.message
					return reject(new BadRequestError());
				}
				return resolve();
			});
		});
	}

	/**
	 * Validates a flow.
	 * @param {object} flow - The flow to validate
	 * @returns {Promise} - Resolves a validation response.
	 */
	validateFlow(flow) {
		this.logger && this.logger.trace('Validating flow');
		return new Promise((resolve, reject) => {
			if (!flow) {
				return reject(new BadRequestError('Missing parameter: flow'));
			}
			this.flowManager.validate(flow, { graph: true, schema: true })
				.catch(error => {
					if (error instanceof Error) {
						// json-schema validation can reject with a string
						return resolve({
							valid: false,
							errors: [{
								type: 'invalidFlow',
								code: 'INVALID_FLOW',
								location: '/',
								detail: {
									error: error.message
								}
							}]
						});
					} else {
						// a graph validation error
						return resolve(error);
					}
				})
				.then(() => {
					resolve({ valid: true });
				});
		});
	}

	/**
	 * Saves a flow
	 * @param  {string} flowId - name of the flowfile (x-flow)
	 * @param {object} flow - The flow to save
	 * @returns {Promise} - Resolves on success.
	 */
	saveFlow(flowId, flow) {
		this.logger && this.logger.trace(`Saving flow: ${flowId}`);
		return new Promise((resolve, reject) => {
			if (!flowId) {
				return reject(new BadRequestError('Missing parameter: flowId'));
			}
			if (!flow) {
				return reject(new BadRequestError('Missing parameter: flow'));
			}
			if (!isSafeFilename(flowId)) {
				// Reject the request if the flowId is not a valid (safe) id.
				return reject(new BadRequestError('Invalid parameter: flowId'));
			}
			async.series([
				next => {
					this.validateFlow(flow).then(validation => {
						if (!validation.valid) {
							this.logger && this.logger.error(`invalid flow: ${flowId}`, JSON.stringify(validation.errors));
							this.logger && this.logger.error('data:', JSON.stringify(flow));
							return next(new BadRequestError('Invalid parameter: flow'));
						}
						next();
					}, next);
				},
				next => mkdirIfNotExists(this.flowsDir, next),
				next => {
					const flowFilePath = path.join(this.flowsDir, `${flowId}.json`);
					const data = JSON.stringify(flow, null, '\t');
					fs.writeFile(flowFilePath, data, 'utf8', (err) => {
						next(err);
					});
				}
			], error => {
				if (error) {
					this.logger && this.logger.error(error);
					if (error instanceof BadRequestError) {
						reject(error);
					} else {
						reject(new InternalServerError());
					}
				} else {
					resolve();
				}
			});
		});
	}
}

exports = module.exports = FlowsController;
