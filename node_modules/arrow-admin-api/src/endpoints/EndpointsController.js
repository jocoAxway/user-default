const async = require('async');
const fs = require('fs');
const path = require('path');
const request = require('request');
const { mkdirIfNotExists, safeFilename, writeJSONFile, writeUniqueJSONFile, isSafeFilename } = require('../util');
const OpenAPIUtils = require('../openapi-utils');
const sampleFromSchema = require('./mockUtils');
const ModelEndpointGenerator = require('./ModelEndpointGenerator');
const { BadRequestError, NotFoundError, ForbiddenError, PayloadTooLargeError, InternalServerError, ExtendableError } = require('../errors');

const makeParameter = (value, param) => {
	let type;
	if (typeof value === 'string') {
		type = 'string';
		value = value || '';
	} else if (typeof value === 'number') {
		type = 'number';
		value = value || 0;
	} else if (typeof value === 'boolean') {
		type = 'boolean';
	} else if (value instanceof Array) {
		type = 'array';
		value = value || [];
	} else if (value === null && typeof value === 'object') {
		type = 'null';
		value = null;
	} else {
		type = 'object';
		value = value || {};
	}
	return {
		...param,
		value: JSON.stringify(value, null, 4),
		type
	};
};

const mockResponse = (swagger, operationId, code, response) => {
	const flow = {
		schemaVersion: '4',
		info: {
			name: operationId,
		},
		parameter: {
			properties: {
				params: {
					type: 'object',
					description: 'The parameters from the endpoint.'
				},
				request: {
					type: 'object',
					description: 'The HTTP request.'
				},
				config: {
					type: 'object',
					description: 'The service\'s configuration'
				},
				env: {
					type: 'object',
					description: 'The host OS environment'
				}
			},
			additionalProperties: false,
			required: [
				'params',
				'request',
				'config',
				'env'
			]
		},
		start: 'http.setresponse.1',
		nodes: {
			'http.setresponse.1': {
				type: 'nodehandler://axway-flow/http',
				method: 'setresponse',
				name: 'Set HTTP Response',
				parameters: [],
				outputs: {
					next: {
						context: '$.response'
					}
				}
			}
		}
	};
	const parameters = flow.nodes['http.setresponse.1'].parameters;

	parameters.push({
		name: 'status',
		value: code === 'default' ? '200' : code,
		type: 'number'
	});
	if (response.headers) {
		const headers = Object.keys(response.headers);
		const headerObj = headers.reduce((acc, cur) => {
			const name = cur.toLowerCase();
			if (name === 'location') {
				acc[name] = '/example/location';
			} else if (name === 'content-type') {
				acc[name] = 'application/json; charset=utf8';
			} else {
				acc[name] = sampleFromSchema(response.headers[cur], swagger);
			}
			return acc;
		}, {});
		parameters.push(makeParameter(headerObj, { name: 'headers' }));
	}
	if (response.schema) {
		const sample = sampleFromSchema(response.schema, swagger);
		parameters.push(makeParameter(sample, { name: 'body' }));
	}
	return flow;
};

function getEndpointFromSwagger(swaggerFile, eppath, method, cb) {
	fs.readFile(swaggerFile, 'utf8', (err, content) => {
		if (err) {
			return cb(err);
		}
		try {
			const endpoint = JSON.parse(content);
			const methodObj = endpoint.paths
				&& endpoint.paths[eppath]
				&& endpoint.paths[eppath][method];
			if (!methodObj) {
				return cb(new NotFoundError('Endpoint not found'));
			}
			cb(null, endpoint);
		} catch (ex) {
			return cb(ex);
		}
	});
}

/**
 * The controller implementing the actions for interacting with Endpoints.
 * @public
 */
class EndpointsController {
	/**
     * Create a ProjectController.
     * @param {object} ctx - The context for this controller.
     * @param {express} ctx.app - The express application.
     * @param {string} ctx.prefix - The prefix bound to.
     * @param {APIBuilder} ctx.apibuilder - The API Builder server.
     * @param {Swagger} ctx.swagger - openapi-doc instance.
     * @param {object} controllers - Additional controllers.
     */
	constructor(ctx, controllers) {
		this.ctx = ctx;
		this.endpointsDir = path.resolve(
			path.join(this.ctx.apibuilder.config.dir || process.cwd(), 'endpoints')
		);
		this.flowsDir = path.resolve(
			path.join(this.ctx.apibuilder.config.dir || process.cwd(), 'flows')
		);
		this.logger = this.ctx.apibuilder.logger;
		this.controllers = controllers;
		// for tests :(
		this.writeUniqueJSONFile = writeUniqueJSONFile;
	}

	/**
	 * Explict call to get the ModelGenerator to allow for easier testing.
	 * @param {string} modelName - the model name
	 * @returns {ModelEndpointGenerator}
	 */
	_createModelGenerator(modelName) {
		return new ModelEndpointGenerator(this.ctx.apibuilder, modelName);
	}

	/**
	 * Remove the flow related extensions from the document.
	 * @param {object} swagger - the swagger definition to clean
	 * @returns {object} cleaned swagger doc
	 */
	_cleanSwagger(swagger) {
		if (!swagger || typeof swagger !== 'object') {
			throw new TypeError('Invalid parameter "swagger"');
		}
		return JSON.parse(JSON.stringify(swagger, (key, value) => {
			if ([ 'x-flow', 'x-enabled' ].indexOf(key) === -1) {
				return value;
			}
		}));
	}

	/**
	 * Fetches data from a URL and makes sure that it doesn't exceed the set limit.
	 *
	 * @param {string} url - url to get data from
	 * @param {number} [maxSize=10,000,000] - max download size in bytes
	 * @returns {Promise}
	 */
	_fetchURLData(url, maxSize = 10 * 1000 * 1000) {
		const proxy = this.ctx.apibuilder.config.proxy;

		return new Promise((resolve, reject) => {
			request.head(url, { proxy }, (err, response) => {
				if (err) {
					return resolve();
				}
				const size = response.headers['Content-Length'];
				if (size && size > maxSize) {
					return reject(new PayloadTooLargeError(`File size too large: Size ${size}B, Max size ${maxSize}B`));
				}
				return resolve();
			});
		})
			.then(() => {
				return new Promise((resolve, reject) => {
					let str = '';
					let size = 0;
					const req = request.get(url, {
						proxy,
						headers: {
							Accept: 'application/json'
						}
					});
					req.on('data', (data) => {
						size += data.length;
						if (size > maxSize) {
							req.abort();
							return reject(new PayloadTooLargeError(`File size too large: Current stream ${size}B, Max size ${maxSize}B`));
						}
						str += data.toString();
					});
					req.on('error', (err) => {
						return reject(err);
					});
					req.on('end', () => {
						return resolve(str);
					});
				});
			});
	}

	/**
	 * Validates a swagger document
	 *
	 * @param {string|object} data - swagger document
	 * @returns {object} { valid: {boolean} swagger: {object} } - swagger is returned when valid
	 */
	_validateSwagger(data) {
		return new Promise(resolve => {
			let swagger = data;
			if (typeof data === 'string') {
				try {
					swagger = JSON.parse(data);
				} catch (ex) {
					resolve({ valid: false });
					return;
				}
			}
			this.ctx.apibuilder.validateSwagger(swagger)
				.then((api) => {
					return resolve({
						valid: true,
						swagger,
						dereferencedSwagger: api
					});
				}, err => {
					this.logger.error(`Swagger validation failed: ${err}`);
					return resolve({
						valid: false
					});
				});
		});
	}

	/*
	 * Upload a swagger/endpoint definition or pull from a URL, validate it and return it.
	 */
	validateEndpoint(fields, files) {
		return new Promise((resolve, reject) => {
			if (files.file) {
				// get data from endpoint
				return fs.readFile(files.file.file, (err, data) => {
					if (err) {
						return reject(err);
					}
					return resolve(data.toString());
				});
			} else if (fields.url) {
				// get data from url
				const cfg = this.ctx.apibuilder.config;
				const limit = cfg && cfg.admin && cfg.admin.request && cfg.admin.request.limit;
				return this._fetchURLData(fields.url.value, limit)
					.then(resolve, reject);
			}
			return reject(new BadRequestError('Missing parameter "file"'));
		})
			.then(data => this._validateSwagger(data));
	}

	createEndpoint(params) {
		if (!params.swagger) {
			return Promise.reject(new BadRequestError('Missing parameter "swagger"'));
		}
		return this._validateSwagger(params.swagger)
			.then(res => {
				if (!res.valid) {
					throw new BadRequestError('Invalid parameter "swagger"');
				}
				return this._cleanSwagger(res.swagger);
			})
			.then(swagger => {
				return new Promise((resolve, reject) => {
					const group = safeFilename(swagger.info.title);
					let alltasks = [
						(next) => mkdirIfNotExists(this.endpointsDir, next)
					];
					const bindSwagger = this._cleanSwagger(params.swagger);
					let mockflows = Promise.resolve();
					if (params.mock) {
						mockflows = this.generateMockFlowsForEndpoint(group, swagger, bindSwagger)
							.then((tasks) => {
								// mush all the tasks together
								tasks.forEach(a => {
									alltasks = alltasks.concat(a.pre);
								});
								tasks.forEach(a => {
									alltasks = alltasks.concat(a.update);
								});
								tasks.forEach(a => {
									alltasks = alltasks.concat(a.post);
								});
							}).catch(reject);
					}
					mockflows.then(() => {
						alltasks.push(
							(next) => this.writeUniqueJSONFile(
								this.endpointsDir,
								group,
								// save the *original* swagger, cleaned and bound
								bindSwagger,
								next
							)
						);
						// Write the files
						async.series(alltasks, (err, results) => {
							if (err) {
								if (err instanceof ExtendableError) {
									return reject(err);
								} else {
									return reject(new InternalServerError(err));
								}
							}
							// get ID from the last results to resolve (endpoint fn)
							const id = path.basename(results.pop(), '.json');
							return resolve(id);
						});
					}).catch(reject);
				});
			});
	}

	/**
	 * Generate the endpoint.
	 * @param {object} params - params for endpoint
	 * @returns {Promise}
	 */
	generateEndpoints(params) {
		return new Promise((resolve, reject) => {
			if (params && params.name && params.model) {
				try {
					const safeName = `${safeFilename(params.name)}.json`;
					const endpointFilePath = path.join(this.endpointsDir, safeName);

					const generator = this._createModelGenerator(params.model);
					const endpointSwagger = generator.generateEndpoint(params.name, params.description);
					const flowDefinitions = generator.generateFlows(params.name);

					const fileData = [
						{ path: endpointFilePath, content: endpointSwagger }
					];
					Object.keys(flowDefinitions).forEach(name => {
						fileData.push({
							path: path.join(this.flowsDir, `${name}.json`),
							content: flowDefinitions[name]
						});
					});

					// Write the files
					const writeTasks = [
						(next) => mkdirIfNotExists(this.endpointsDir, next),
						(next) => mkdirIfNotExists(this.flowsDir, next)
					];
					fileData.forEach(file => {
						writeTasks.push((next) => {
							writeJSONFile(file.path, file.content, next);
						});
					});

					async.series(writeTasks, (err) => {
						if (err) {
							reject(err);
						} else {
							resolve(path.basename(endpointFilePath, path.extname(endpointFilePath)));
						}
					});
				} catch (err) {
					reject(err);
				}
			} else {
				reject(new BadRequestError());
			}
		});
	}

	/**
	 * Produces mock flows for a swagger definition
	 * @param {object} swagger - swagger document
	 * @returns {Promise}
	 */
	mockEndpoints(swagger) {
		return new Promise((resolve, reject) => {
			if (!swagger || typeof swagger !== 'object') {
				return reject(new BadRequestError('Missing parameter'));
			}
			const data = [];
			Object.keys(swagger.paths).forEach((spath) => {
				if (spath.startsWith('x-')) {
					return;
				}
				Object.keys(swagger.paths[spath]).forEach((verb) => {
					if (verb.startsWith('x-') || verb === 'parameters') {
						return;
					}
					let operationId = swagger.paths[spath][verb].operationId;
					if (!operationId || !isSafeFilename(operationId)) {
						operationId = OpenAPIUtils.generateFunctionName(spath, verb);
					}
					this.logger.trace(`mocking endpoint ${verb} ${spath} as "${operationId}"`);

					const codes = Object.keys(swagger.paths[spath][verb].responses)
						.sort((a, b) => {
							if (b.startsWith('x-')) {
								return -1;
							}
							// there "should be one response code" and that should have
							// precedence over 'default'.
							if (a < b || b === 'default') {
								return -1;
							}
							return 0;
						});
					const code = codes.shift(); // pull first code
					const response = swagger.paths[spath][verb].responses[code];
					const mock = mockResponse(swagger, operationId, code, response);
					data.push({
						path: spath,
						method: verb,
						flow: mock
					});
				});
			});
			resolve(data);
		});
	}

	/**
	 * Generate mock flows for an endpoint.
	 * @param {string} group - The group name, i.e. safeFilename(swagger.info.title)
	 * @param {object} swagger - The resolved swagger to mock.
	 * @param {object} bindSwagger - The original swagger document to bind.
	 * @return {Promise<array>} A promise to the array of tasks (pre, update, post).
	 */
	generateMockFlowsForEndpoint(group, swagger, bindSwagger) {
		return new Promise((resolve, reject) => {
			// mock all the endpoints
			return this.mockEndpoints(swagger).then((data) => {
				// for each endpoint mocked, bind to the flow which generates all of the
				// tasks to complete the operation.  the 'pre' tasks will check for files;
				// the 'update' tasks will write files; and the 'post' tasks will update
				// the endpoint.
				return Promise.all(data.map((item) => {
					return this._bindFlowToEndpoint(bindSwagger, {
						group,
						...item,
						tasks: {
							pre: [],
							update: [],
							post: []
						}
					});
				})).then(resolve, reject);
			});
		});
	}

	/*
	 * Returns an array of summaries (group name, endpoint count)
	 * for each API group
	 */
	getEndpointSummaries() {
		return new Promise(resolve => {
			const endpoints = this.ctx.apibuilder.getEndpoints();
			const summaries = Object.keys(endpoints).map(apiName => {
				// A list of keys to be excluded when counting the endpoints.
				// This resolves the issue when the parameters are attached to
				// root level of the endpoint - [RDPP-4818].
				const excludedKeys = [ 'parameters' ];

				const endpoint = endpoints[apiName];
				return {
					id: apiName,
					name: endpoint.info.title,
					endpointCount: Object.keys(endpoint.paths)
						.filter(part => !/^x-/.test(part))
						.map((part) => {
							const pathsList = Object.keys(endpoint.paths[part])
								.filter(el => !excludedKeys.includes(el));
							return pathsList.length;
						})
						.reduce((pre, cur) => pre + cur),
					description: endpoint.info.description,
					status: !endpoint.hasOwnProperty('x-enabled') ? {
						enabled: true
					} : {
						...endpoint['x-enabled']
					}
				};
			});
			resolve(summaries);
		});
	}

	/**
	 * Get API endpoints
	 * @param {string} groupName - The name of the API endpoint group
	 * @returns {Promise}
	 */
	getEndpoints(groupName) {
		return new Promise((resolve, reject) => {
			if (!groupName) {
				return reject(new BadRequestError());
			}
			const endpoints = this.ctx.apibuilder.getEndpoints();
			if (!endpoints.hasOwnProperty(groupName)) {
				return reject(new NotFoundError());
			}
			return resolve(endpoints[groupName]);
		});
	}

	/**
	 * delete a method from and api group on some endpoint
	 * @param  {object} params - contains api group, path within the group, and method
	 * @returns {Promise}
	 */
	deleteEndpoint(params = {}) {
		return new Promise((resolve, reject) => {
			if (!params.group || !params.path || !params.method) {
				const paramError = new BadRequestError('Missing parameter');
				this.logger.error(paramError.message);
				return reject(paramError);
			}

			const tasks = [];
			const endpointPath = params.path;
			const method = params.method;
			const fileName = `${params.group}.json`;
			const endpointFilePath = path.join(this.endpointsDir, fileName);

			// Update the endpoint definition and write it to the fs
			const deleteEndpointMethod = (endpointToDelete, next) => {
				delete endpointToDelete.paths[endpointPath][method];
				fs.writeFile(
					endpointFilePath,
					JSON.stringify(endpointToDelete, null, 2), {
						flag: 'w',
						encoding: 'utf-8',
						mode: 0o600
					}, function (err) {
						if (err) {
							next(err);
						} else {
							next();
						}
					});
			};

			tasks.push(getEndpointFromSwagger.bind(null, endpointFilePath, endpointPath, method));
			tasks.push(deleteEndpointMethod);

			return async.waterfall(tasks, (err) => {
				if (err) {
					this.logger.error(err);
					if (err instanceof ExtendableError) {
						reject(err);
					} else {
						reject(new InternalServerError());
					}
				} else {
					resolve();
				}
			});
		});
	}

	/**
	 * Binds a flow to an endpoint (swagger) definition, and resolves with the set of
	 * tasks to complete that binding where pre-tasks check directories and existing
	 * files, update-tasks write the files, and post-tasks complete the binding.
	 *
	 * @param {object} endpoint - the endpoint to bind flow to
	 * @param {object} [params] - Bind parameters
	 * @param {string} params.group - The endpoint group name
	 * @param {string} params.path - The endpoint path to bind
	 * @param {string} params.method - The endpoint method to bind (e.g. "post")
	 * @param {object} params.tasks - An object of 3 arrays, `pre`, `update`, and `post`
	 * @param {object} params.flow - The flow object to bind.
	 * @return {Promise<object>} A promise to the tasks.
	 */
	_bindFlowToEndpoint(endpoint, params = {}) {
		return new Promise((resolve, reject) => {
			const names = [ 'group', 'path', 'method', 'flow', 'tasks' ];
			const name = names.find(a => !params[a]);
			if (name) {
				const paramError = new BadRequestError(`Missing parameter: ${name}`);
				this.logger.error(paramError.message);
				return reject(paramError);
			}

			const operation = endpoint.paths[params.path][params.method];

			let operationId = operation.operationId;
			if (!operationId || !isSafeFilename(operationId)) {
				operationId = OpenAPIUtils.generateFunctionName(params.path, params.method);
			}
			const flowId = `${params.group}-${operationId}`;

			// Check that a flow with that ID does not exist.
			params.tasks.pre.push((next) => {
				this.controllers.flowsController.exists(flowId).then(exists => {
					if (exists) {
						this.logger.error(`Flow already exists: ${flowId}`);
						return next(new ForbiddenError('A flow already exists.'));
					} else if (operation['x-flow']) {
						this.logger.error(`Endpoint already bound to a flow: ${operation['x-flow']}`);
						return next(new ForbiddenError('Endpoint already bound to a flow.'));
					}
					if (!isSafeFilename(flowId)) {
						this.logger.error(`Not a safe flow filename: ${flowId}`);
						return next(new ForbiddenError('Flow filename can only contain alpha-numeric, underscores, and dashes.'));
					}
					next();
				}).catch(next);
			});

			// Write the new flow
			params.tasks.update.push((next) => {
				// Update the endpoint flowId
				operation['x-flow'] = flowId;
				// save the flow
				this.controllers.flowsController.saveFlow(flowId, params.flow)
					.then(next)
					.catch(next);
			});

			resolve(params.tasks);
		});
	}

	/**
	 * Binds a flow to an existing endpoint file (swagger) definition.
	 *
	 * @param {object} [params] - Bind parameters
	 * @param {string} params.group - The endpoint group name
	 * @param {string} params.path - The endpoint path to bind
	 * @param {string} params.method - The endpoint method to bind (e.g. "post")
	 * @param {object} params.flow - The flow object to bind.
	 * @return {Promise<object>} A promise to the tasks.
	 */
	bindFlow(params = {}) {
		return new Promise((resolve, reject) => {
			const names = [ 'group', 'path', 'method', 'flow' ];
			const name = names.find(a => !params[a]);
			if (name) {
				const paramError = new BadRequestError(`Missing parameter: ${name}`);
				this.logger.error(paramError.message);
				return reject(paramError);
			}

			// const tasks = [];
			const endpointPath = params.path;
			const method = params.method;
			const safeName = `${params.group}.json`;
			const endpointFilePath = path.join(this.endpointsDir, safeName);

			getEndpointFromSwagger(endpointFilePath, endpointPath, method, (cberr, endpointToBind) => {
				if (cberr) {
					this.logger.error(cberr);
					if (cberr instanceof ExtendableError) {
						return reject(cberr);
					} else {
						return reject(new InternalServerError());
					}
				}

				this._bindFlowToEndpoint(endpointToBind, {
					...params,
					tasks: {
						pre: [
							// pre-task to check directory
							(next) => mkdirIfNotExists(this.flowsDir, next)
						],
						update: [],
						post: [
							// final write to endpoint (this is done knowing that
							// _bindFlowToEndpoint does not write any post events).
							(next) => writeJSONFile(endpointFilePath, endpointToBind, next)
						]
					}
				}).then((tasks) => {
					const alltasks = tasks.pre.concat(tasks.update).concat(tasks.post);
					return async.series(alltasks, (err) => {
						if (err) {
							this.logger.error(err);
							if (err instanceof ExtendableError) {
								reject(err);
							} else {
								reject(new InternalServerError());
							}
						} else {
							resolve();
						}
					});
				});
			});
		});
	}
}

exports = module.exports = EndpointsController;
