const schemas = require('axway-schema');
const jsonpointer = require('json-pointer');
const jsonschemafaker = require('json-schema-faker');
const OpenAPIUtils = require('../openapi-utils');

// Note on upgrade to json-schema-faker 5.x this all needs to be reviewed. We should
// probably consolidate on json-schema-ref-parser for all our schema parsing.
function faker(schema) {
	try {
		return jsonschemafaker(schema);
	} catch (err) {
		return null;
	}
}

function normalizeArray(arr) {
	if (Array.isArray(arr)) {
		return arr;
	}
	return [ arr ];
}

function getRefSchema(swagger, parent) {
	if (!parent.$ref) {
		return;
	}
	let refSchema = schemas.get(parent.$ref);
	if (!refSchema && parent.$ref.startsWith('#/')) {
		refSchema = jsonpointer.get(swagger, parent.$ref.substring(1));
	}
	return refSchema;
}

function getAllOfValue(schema, swagger, config, path) {
	let combined;
	for (let i = 0; i < schema.allOf.length; ++i) {
		const sub = schema.allOf[i];
		const sample = sampleFromSchema(sub, swagger, config, path);

		if (combined === undefined) {
			combined = sample;
			if (typeof combined !== 'object') {
				break;
			}
		} else if (sample && typeof sample === 'object') {
			combined = { ...combined, ...sample };
		}
	}
	return combined;
}

// Resolve objects that are just { $ref: /foo }
function resolveRefObj(schema, swagger, path) {
	const loop = [ ...path ];

	while (schema && schema.$ref) {
		if (loop.includes(schema.$ref)) {
			schema = null;
			break;
		}
		path.push(schema.$ref);
		schema = getRefSchema(swagger, schema);
	}
	return schema;
}

function sampleFromSchema(schema, swagger, config = {}, path = []) {
	// If it's allOf the build all the samples
	if (schema && schema.allOf) {
		return getAllOfValue(schema, swagger, config, path);
	}

	// If it's just a ref then get the refed schema
	schema = resolveRefObj(schema, swagger, path);

	if (!schema) {
		return;
	}

	let { type } = schema;
	const { example, properties, additionalProperties, items } = schema;
	const { includeReadOnly, includeWriteOnly } = config;

	if (example !== undefined) {
		return example;
	}

	if (!type) {
		if (properties) {
			type = 'object';
		} else if (items) {
			type = 'array';
		} else {
			return;
		}
	}

	if (type === 'object') {
		const props = properties;
		const obj = {};
		for (const name in props) {
			if (!props.hasOwnProperty(name)) {
				continue;
			}

			const prop = props[name];
			if ((prop.$ref && path.includes(prop.$ref)) || (path.includes(prop))) {
				// No cycles.
				continue;
			}

			if (prop.readOnly && !includeReadOnly) {
				continue;
			}
			if (prop.writeOnly && !includeWriteOnly) {
				continue;
			}

			const childPath = [ ...path, prop.$ref || prop ];
			const objSchema = prop.$ref ? getRefSchema(swagger, prop) : prop;
			if (objSchema) {
				obj[name] = sampleFromSchema(objSchema, swagger, config, childPath);
			}
		}

		if (additionalProperties === true) {
			obj.additionalProp1 = {};
		} else if (additionalProperties) {
			const addProps = additionalProperties;
			const cycle = (addProps.$ref && path.includes(addProps.$ref)) || (path.includes(addProps));

			if (!cycle) {
				const childPath = [ ...path, addProps.$ref || addProps ];
				const addSchema = addProps.$ref ? getRefSchema(swagger, addProps) : addProps;
				const additionalPropVal = sampleFromSchema(addSchema, swagger, config, childPath);

				for (let i = 1; i < 4; i++) {
					obj[`additionalProp${i}`] = additionalPropVal;
				}
			}
		}
		return obj;
	}

	if (type === 'array') {
		if ((items.$ref && path.includes(items.$ref)) || (path.includes(items))) {
			// No cycles.
			return [];
		}

		const childPath = [ ...path, items.$ref || items ];
		const arraySchema = items.$ref ? getRefSchema(swagger, items) : items;
		if (arraySchema) {
			return [ sampleFromSchema(arraySchema, swagger, config, childPath) ];
		} else {
			return [];
		}
	}

	if (schema.enum) {
		if (schema.hasOwnProperty('default')) {
			return schema.default;
		}
		return normalizeArray(schema.enum)[0];
	}

	if (type === 'file') {
		return;
	}

	return faker(OpenAPIUtils.cleanSchema(schema));
}

exports = module.exports = sampleFromSchema;
