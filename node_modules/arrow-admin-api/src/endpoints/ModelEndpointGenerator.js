const Swagger = require('openapi-doc');
const NotFoundError = require('../errors/NotFoundError');
const safeFilename = require('../util').safeFilename;
const modelflows = require('./modelflows');
const modelEndpoints = require('./modelendpoints');

const ACTION_MAP = {
	findById: 'findByIDAPI',
	findOne: 'findByIDAPI'
};

/**
 * Helper for generating standard Endpoints from a Model definition.
 * @public
 */
class ModelEndpointGenerator {
	constructor(apibuilder, modelName) {
		this.apibuilder = apibuilder;
		this.logger = apibuilder.logger;
		this.model = apibuilder.getModel(modelName);

		if (!this.model) {
			throw new NotFoundError(`Model ${modelName} not found.`);
		}

		// Load the models referenced through composition.
		this.models = this.getReferencedModels(
			this.model, { [modelName]: this.model }
		);
		this.supportedAPIs = this.getSupportedAPIDefs();
	}

	/**
	 * Get the names of all the models referenced by this model.
	 * @param {object} model - the model to check
	 * @param {array} models -
	 * @returns {object} models referenced by the original
	 */
	getReferencedModels(model, models) {
		const referencedModelNames = new Set(
			Object.keys(model.fields)
				.map((fieldName) => model.fields[fieldName])
				.filter(field => field.model && (field.type === 'array' || field.type === Array || field.type === 'object' || field.type === Object))
				.map(field => field.model)
				.filter(modelName => !models || !models.hasOwnProperty(modelName))
		);

		const referencedModels = [ ...referencedModelNames ].map(
			refModelName => {
				const m = this.apibuilder.getModel(refModelName);
				if (!m) {
					throw new NotFoundError(`Model ${refModelName} not found.`);
				}
				return m;
			}
		);

		// Add the referenced models
		models = models || {};
		referencedModels.forEach(m => {
			models[m.name] = m;
		});

		// Look for nested dependencies
		referencedModels.forEach(m => {
			this.getReferencedModels(m, models);
		});

		return models;
	}

	/**
	 * Get the APIs that are supported by the model.
	 * @returns {object} sipported api definitions
	 */
	getSupportedAPIDefs() {
		const defs = {};

		// Reusing the existing CRUD->API support here
		// to get the metadata for Endpoint creation.
		for (const key in this.model) {
			// Limiting to CRUD APIs defined in Model base and not extended
			// APIs added by custom models/connectors.
			if (this.model[key] && key.slice(-3) === 'API') {
				// Some connectors use old mappings, to maintain support remap to the standard action.
				const name = key.slice(0, -3);
				if (this.model[name] && Object.getPrototypeOf(this.model).hasOwnProperty(name)) {
					// Check to see if the underlying connector has the necessary methods to support this API.
					const apiDef = this.model[key]();
					const reqConnectorMethods = apiDef.dependsOnAny || apiDef.dependsOnAll || [ name ];
					const connectorMethods = reqConnectorMethods.filter(
						method => !!this.model.getConnector()[method]
					);

					if (connectorMethods.length >= (apiDef.dependsOnAll ? reqConnectorMethods.length : 1)) {
						const action = ACTION_MAP[name] || key;
						defs[action] = apiDef;
					} else {
						this.logger.warn(`API not supported on Connector: ${name}`);
					}
				} else {
					this.logger.warn(`API not supported on Model: ${name}`);
				}
			}
		}
		return defs;
	}

	/**
	 * Generate the standard endpoints for the model.
	 * @param {string} name - The endpoint name.
	 * @param {string} description - The endpoint description.
	 * @return {object} - The swagger object for the model endpoints.
	 */
	generateEndpoint(name, description) {
		// Create the Swagger for each API supported by the model
		const swagger = new Swagger();
		swagger.info(
			name || `${this.model.singular || this.model.name} API`,
			'1.0.0',
			description
		);
		swagger.basePath('/endpoints');
		const schemaRef = {
			model: this.apibuilder.getModelSchemaId(this.model),
			modelEx: this.apibuilder.getModelSchemaExId(this.model),
			full: this.model.hasPrimaryKey() ? this.apibuilder.getModelSchemaFullId(this.model) : this.apibuilder.getModelSchemaId(this.model),
			fullEx: this.model.hasPrimaryKey() ? this.apibuilder.getModelSchemaFullExId(this.model) : this.apibuilder.getModelSchemaExId(this.model)
		};
		Object.keys(this.supportedAPIs).forEach((apiName) => {
			if (modelEndpoints[apiName]) {
				const opId = this.getOperationId(
					this.model,
					this.getAPIPath(apiName),
					this.supportedAPIs[apiName]);
				const flow = this.getFlowName(name, apiName);
				swagger.merge(modelEndpoints[apiName](flow, opId, schemaRef, this.model));
				swagger.extension('x-flow', flow);
			}
		});

		return swagger.apidoc();
	}

	/**
	 * Generate the standard flows for the model apis.
	 * @param {string} endpointName - The name of the endpoint.
	 * @return {object} - The map of flows to support the endpoint apis.
	 */
	generateFlows(endpointName) {
		const flows = {};

		Object.keys(this.supportedAPIs).forEach((apiName) => {
			const flowName = this.getFlowName(endpointName, apiName);
			const schemaRef = {
				model: this.apibuilder.getModelSchemaId(this.model),
				modelEx: this.apibuilder.getModelSchemaExId(this.model),
				full: this.model.hasPrimaryKey() ? this.apibuilder.getModelSchemaFullId(this.model) : this.apibuilder.getModelSchemaId(this.model),
				fullEx: this.model.hasPrimaryKey() ? this.apibuilder.getModelSchemaFullExId(this.model) : this.apibuilder.getModelSchemaExId(this.model)
			};

			if (modelflows.hasOwnProperty(apiName)) {
				flows[flowName] = modelflows[apiName](flowName, schemaRef, this.model);
			}
		});
		return flows;
	}

	/**
	 * Get the appropriate name to use for the flow.
	 * @param {string} endpointName - the name of the endpoint
	 * @param {string} apiName - the name of the API
	 * @returns {string} the safe name of the flow
	 */
	getFlowName(endpointName, apiName) {
		return `${safeFilename(endpointName)}-${apiName.slice(0, -3)}`;
	}

	/**
	 * Get the path for the model api.
	 * @param {string} apiName - The api to get the path for.
	 * @return {string} - The api path.
	 */
	getAPIPath(apiName) {
		const apiDetail = this.supportedAPIs[apiName];
		const name = this.model.name.replace(/^.*?\//, '').toLowerCase();
		let apiPath = `/${name}`;
		if (apiDetail.path) {
			if (apiDetail.path.startsWith('./')) {
				apiPath += apiDetail.path.substr(1);
			} else {
				apiPath += apiDetail.path;
			}
		}
		return apiPath;
	}

	/**
	 * Get the operation id.
	 * @param {Model} model - The model the endpoints are being generated for.
	 * @param {string} apiPath - The path the endpoint is going to advertise.
	 * @param {object} apiDetail - The API details for the model method.
	 * @return {string} - The operation id.
	 */
	getOperationId(model, apiPath, apiDetail) {
		return apiDetail.nickname
			? `${apiDetail.nickname} ${model.singular}` : `${apiDetail.method} ${apiPath}`;
	}
}

exports = module.exports = ModelEndpointGenerator;
