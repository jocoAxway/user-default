const schemas = require('axway-schema');
const capitalize = require('capitalize');

// http://json-schema.org/draft-04/schema properties
const draft04 = schemas.get('http://json-schema.org/draft-06/schema');
const draft04properties = Object.keys(draft04.properties);

function _pick(obj, ...props) {
	return Object.assign({}, ...props.map(prop => {
		if (obj[prop] !== undefined) {
			return ({ [prop]: obj[prop] });
		}
		return undefined;
	}));
}

function _pickSchemaRelevant(obj, additionalProperties) {
	return _pick(obj, ...draft04properties, ...additionalProperties);
}

// I could find no restrictions on parameter names in Swagger, so I will assume they are
// all valid, and that ':' denotes a regex, e.g. {banana:[a-z]}.  The regex below will
// match any set of characters within brackets {}, but has an optional, non-capturing
// group that starts with ':'.
const reSwaggerParam = new RegExp(/{(.+?)(?::.*?)?}/g);
const reParamName = new RegExp(/[^a-zA-Z0-9]/g);

// https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-7.3
const allowedFormats = [
	'date-time',
	'email',
	'hostname',
	'ipv4',
	'ipv6',
	'uri'
];

// Remove any formats that aren't json-schema compliant. Could update ajv with unknownFormats
const _removeFormats = (prop) => {
	if (prop.format && allowedFormats.indexOf(prop.format) < 0) {
		delete prop.format;
	}
};

const MAX_DEPTH = 5;

// This is a candiate (precursor) for its own repo.  These functions have related counterparts
// in nodehandler-utils, and have already diverged a little, but this should be regarded as the
// reference implementation.

/**
 * OpenAPI utility functions.
 */
class OpenAPIUtils {
	/**
	 * Cleans an openapi schema to be JSON schema draft-04 compliant by recursively removing
	 * unsupported formats.
	 *
	 * NOTE: If/when this makes it into a new module, this code should be changed to remove the
	 * kill-switch on depth.  Instead, the schema passed in should be guaranteed/made to be
	 * non-circular (e.g. with a separate `decircularize` method).
	 *
	 * @param {object} schema - The openapi schema to transform.
	 * @param {number} [level] - The current recursion level for safety.
	 * @returns {object} cleaned schema
	 */
	static cleanSchema(schema, level = 0) {
		let cloned = Object.assign({}, schema);
		if (schema.properties) {
			// If the property is of type `object` then we can expect either `properties` or
			// `additionalProperties` to be present.  If present, then those properties also
			// need to be sanitized.
			cloned.properties = {};
			Object.keys(schema.properties).forEach(propertyName => {
				cloned.properties[propertyName] = {};
				if (level + 1 < MAX_DEPTH) {
					cloned.properties[propertyName] = OpenAPIUtils.cleanSchema(
						schema.properties[propertyName], level + 1
					);
				}
			});
		}
		if (typeof schema.additionalProperties === 'object') {
			if (schema.additionalProperties instanceof Array) {
				cloned.additionalProperties = [];
			} else {
				cloned.additionalProperties = {};
			}
			if (level + 1 < MAX_DEPTH) {
				cloned.additionalProperties = OpenAPIUtils.cleanSchema(
					schema.additionalProperties, level + 1
				);
			}
		}
		[ 'allOf', 'anyOf', 'oneOf' ].forEach((arrayOf) => {
			if (!schema[arrayOf]) {
				return;
			}
			cloned[arrayOf] = [];
			schema[arrayOf].forEach(item => {
				if (level + 1 < MAX_DEPTH) {
					cloned[arrayOf].push(OpenAPIUtils.cleanSchema(item, level + 1));
				}
			});
		});
		if (schema.not) {
			if (schema.not instanceof Array) {
				cloned.not = [];
			} else {
				cloned.not = {};
			}
			if (level + 1 < MAX_DEPTH) {
				cloned.not = OpenAPIUtils.cleanSchema(schema.not, level + 1);
			}
		}
		if (schema.type === 'array' && schema.items) {
			cloned.items = {};
			if (level + 1 < MAX_DEPTH) {
				// If type is array, then sanitize array items
				cloned.items = OpenAPIUtils.cleanSchema(schema.items, level + 1);
			}
		}
		_removeFormats(cloned);
		cloned = _pickSchemaRelevant(cloned, [ 'schema', 'id', '$ref' ]);
		return cloned;
	}

	/**
	 * Cleans all x- extensions from a supplied swagger document.  Does not modify the
	 * original document.  Note that this can cause an issue if a $ref is referencing
	 * any x- extension (e.g. evil.json /thingyref).  The swagger document should be
	 * dereferenced prior to cleaning.
	 * @param {string} swagger - The swagger document to clean.
	 * @returns {object} - The cleaned swagger document.
	 */
	static cleanExtensions(swagger) {
		const type = typeof swagger;
		if (type !== 'object' || swagger === null) {
			return swagger;
		}
		let cloned;
		if (type === 'object' && swagger instanceof Array) {
			cloned = swagger.slice(0);
		} else {
			cloned = Object.assign({}, swagger);
		}
		Object.keys(cloned).forEach(key => {
			const item = cloned[key];
			if (key.startsWith('x-')) {
				delete cloned[key];
			} else if (typeof item === 'object') {
				cloned[key] = OpenAPIUtils.cleanExtensions(item);
			}
		});
		return cloned;
	}

	/**
	 * Method to create custom operationID-like operation id.
	 * @param  {string} path   - The swagger path (eg. /thing)
	 * @param  {string} method - The swagger method/verb (eg. "GET")
	 * @return {string} The custom operationID
	 */
	static generateFunctionName(path, method) {
		const parts = path.split(/\//g);
		if (parts.length && parts[0] === '') {
			parts.shift();
		}
		const parsed = parts.reduce((acc, cur) => {
			if (cur.startsWith('{')) {
				reSwaggerParam.lastIndex = 0;
				const match = reSwaggerParam.exec(cur);
				reParamName.lastIndex = 0;
				match[1].split(reParamName).forEach(a => {
					acc.params.push(capitalize(a));
				});
			} else {
				reParamName.lastIndex = 0;
				cur.split(reParamName).forEach(a => {
					acc.slugs.push(capitalize(a));
				});
			}
			return acc;
		}, {
			slugs: [],
			params: []
		});
		if (!parsed.params.length) {
			return method.toLowerCase() + parsed.slugs.join('');
		} else {
			return `${method.toLowerCase()}${parsed.slugs.join('')}By${parsed.params.join('')}`;
		}
	}
}

exports = module.exports = OpenAPIUtils;
