const FlowValidator = require('./flowvalidator');

/**
 * @module axway-flow-graph
 * @typicalname axway-flow-graph
 */

/**
 * Converts an object into an array of keys or values
 *
 * @param {object} object - the object to convert into an array
 * @param {function|bool} map - if true, return all the keys of the object
 *                              if false, return all the values of the object
 *                              if function, map object keys to array values.
 * @returns {string[]|array} an array of values based on the map.
 */
const objectToArray = (object, map) => {
	const keys = Object.keys(object);
	return map === true ? keys : keys.map(map || (key => object[key]));
};

/**
 * FlowGraph object
 *
 * @class FlowGraph
 */
class FlowGraph {
	/**
	 * Creates an instance of FlowGraph.
	 * @constructor
	 * @param {string} flowId - The id of this flow.
	 * @param {object} flowdef - The flow definition.
	 */
	constructor(flowId, flowdef) {
		this.id = flowId;
		if (typeof (flowdef) === 'string') {
			this.flow = JSON.parse(flowdef);
		} else {
			this.flow = JSON.parse(JSON.stringify(flowdef));
		}
		this.registerValidator(FlowValidator);
		this._buildGraph();
		this._onChange();
	}

	/**
	 * Ensures that a vertex will exist
	 *
	 * @param {string} vertexId - the ID of the vertex
	 * @param {object} info - info to be set on the vertex. If vertex already exists, the info will
                     be merged with the existing info.
	 * @returns {object} the vertex which matched or was created.
	 * @protected
	 */
	_ensureVertex(vertexId, info) {
		const vertices = this.graph.vertices;
		const vertex = vertices[vertexId];
		if (!vertex) {
			vertices[vertexId] = {
				id: vertexId,
				children: Object.create(null),
				parents: Object.create(null),
				info: {
					terminal: false,
					...info || Object.create(null)
				}
			};
		} else if (info) {
			// if node already exists we still want to update the info
			vertex.info = {
				...vertex.info,
				...info || Object.create(null)
			};
		}
		return vertices[vertexId];
	}

	/**
	 * Deletes a vertex from the graph
	 *
	 * @param {string} vertexId - the id of the vertex to delete
	 * @protected
	 */
	_deleteVertex(vertexId) {
		delete this.graph.vertices[vertexId];
	}

	/**
	 * Gets the children of a vertex in the flow
	 *
	 * @param {string} vertexId - the Id of the vertex to get children for.
	 * @param {string} output - the vetex output to get the children for.
	 * @param {bool} [idsOnly] - if the vertex idsOnly should be returned rather than the vertices
	 * @returns {string[]|object[]} the child vertices of a vertex in the flow
	 */
	_getVertexChildren(vertexId, output, idsOnly) {
		return objectToArray(
			this.graph.vertices[vertexId].children[output],
			idsOnly
			|| (childId => this.getVertex(childId))
		);
	}

	/**
	 * Gets the parents of a vertex in the flow
	 *
	 * @param {string} vertexId - the Id of the vertex to get parents for.
	 * @param {bool} [idsOnly] - if the vertex ids should be returned rather than the vertices
	 * @returns {string[]|object[]} the parent nodes of a vertex in the flow
	 */
	_getVertexParents(vertexId, idsOnly) {
		return objectToArray(
			this.graph.vertices[vertexId].parents,
			idsOnly
			|| (parentId => this.getVertex(parentId))
		);
	}

	/**
	 * Ensures that an edge will exist between any two vertices. If any of the vertices do not exist,
	 * they will be created.
	 *
	 * @param {string} output - the vertex output group the edge belongs to.
	 * @param {string} fromId - the ID of the vertex where the edge starts
	 * @param {string} toId - this ID of the vertex where the edge ends
	 * @returns {object} the edge which matched or was created.
	 * @protected
	 */
	_ensureEdge(output, fromId, toId) {
		let edge = this.getEdge(output, fromId, toId);
		if (edge) {
			return edge;
		}
		edge = {
			output,
			to: toId,
			from: fromId
		};
		const vFrom = this._ensureVertex(fromId);
		const vTo = this._ensureVertex(toId);
		this.graph.edges.push(edge);
		vFrom.children[output] = vFrom.children[output] || Object.create(null);
		vFrom.children[output][toId] = true;
		vTo.parents[fromId] = true;
		return edge;
	}

	/**
	 * Deletes an edge from one node to another.
	 * Removes the parent/child where necesarry from each vertex.
	 *
	 * @param {string} fromId - the vertex where the edge starts
	 * @param {string} output - the vertex output group the edge belongs to.
	 * @param {string} toId - the vertex where the edge ends
	 * @protected
	 */
	_deleteEdge(fromId, output, toId) {
		this.graph.edges = this.graph.edges.filter(edge => {
			return !(edge.output === output && edge.to === toId && edge.from === fromId);
		});
		// delete parent
		const toVertex = this.getVertex(toId);
		if (toVertex) {
			delete toVertex.parents[fromId];
		}
		// delete child
		const fromVertex = this.getVertex(fromId);
		if (fromVertex) {
			delete fromVertex.children[output][toId];
		}
		// check the children and see if it is empty, if so, delete the output, e.g.
		// "success" of: {"success": {}}
		if (!Object.keys(fromVertex.children[output]).length) {
			delete fromVertex.children[output];
		}
		// check children and if empty, the node is terminal
		if (!Object.keys(fromVertex.children).length) {
			fromVertex.info.terminal = true;
		}
	}

	/**
	 * Deletes the edges from one node to another (across all outputs).
	 * Removes the parent/child where necesarry from each vertex.
	 *
	 * @param {string} fromId - the vertex where the edge starts
	 * @param {string} toId - the vertex where the edge ends
	 * @protected
	 */
	_deleteEdges(fromId, toId) {
		this.graph.edges = this.graph.edges.filter(edge => {
			return !(edge.to === toId && edge.from === fromId);
		});

		// Remove this node as parent of it's children
		const toVertex = this.getVertex(toId);
		if (toVertex) {
			delete toVertex.parents[fromId];
		}

		// Remove this node as child of it's parents
		const fromVertex = this.getVertex(fromId);
		if (fromVertex) {
			Object.keys(fromVertex.children).forEach((output) => {
				delete fromVertex.children[output][toId];
			});
		}
	}

	_deleteOutput(nodeId, output) {
		const node = this.getNode(nodeId);
		if (!node) {
			throw new Error(`Node ${nodeId} does not exist`);
		}
		const nodeOutput = node.outputs[output];
		if (!nodeOutput) {
			throw new Error(`Output ${output} does not exist on node ${nodeId}`);
		}

		// unroute
		const outputRoutes = nodeOutput.routes;
		if (outputRoutes) {
			outputRoutes.forEach(route => {
				this.deleteRoute(output, nodeId, route);
			});
		}
		delete node.outputs[output];
	}

	/**
	 * Sets the validation state on the flow definition
	 *
	 * @param {object} validation - the validation state
	 * @protected
	 */
	_setValidation(validation) {
		this.flow['x-validation'] = validation;
	}

	/**
	 * Gets a list of all nodes which a node may route to grouped by output.
	 *
	 * @param {string} nodeId - the ID of a node to get routes for
	 * @returns {object} A map of IDs for routes from the node specified grouped by output.
	 * @protected
	 */
	_getOutputRoutes(nodeId) {
		const node = this.flow.nodes[nodeId];
		if (!node) {
			return null;
		}

		const outputRoutes = Object.keys(node.outputs).reduce(
			(col, cur) => {
				const output = node.outputs[cur];
				if (output.routes && output.routes.length > 0) {
					col[cur] = output.routes;
				} else {
					col[cur] = [];
				}
				return col;
			},
			Object.create(null)
		);

		return outputRoutes;
	}

	/**
	 * Generates a unique symbol of the flow. Should be called whenever the flow changes.
	 */
	_onChange() {
		this.symbol = Symbol(this.id);
	}

	/**
	 * Build a graph from the flow definition.
	 *
	 * @protected
	 */
	_buildGraph() {
		// Process the nodes in the graph to determine parential dependencies and
		// nodes that terminate the flow.
		this.graph = {
			vertices: Object.create(null),
			edges: []
		};
		Object.keys(this.flow.nodes).forEach(nodeId => {
			this._buildVertex(nodeId);
		});
	}

	/**
	 * Builds a vertex for a nodeId
	 * @param {string} nodeId - The nodeId from which to build a vertex.
	 */
	_buildVertex(nodeId) {
		if (!this.flow.nodes[nodeId].name) {
			this.flow.nodes[nodeId].name = nodeId;
		}
		const outputRoutes = this._getOutputRoutes(nodeId);
		// This vertex is terminal if there are no outputs or if any of the
		// outputs have no routes.
		if (outputRoutes === null || !Object.keys(outputRoutes).length) {
			this._ensureVertex(nodeId, {
				terminal: true
			});
		} else {
			Object.keys(outputRoutes).forEach(
				(outputName) => {
					const routes = outputRoutes[outputName];
					if (!routes || !routes.length) {
						this._ensureVertex(nodeId, {
							terminal: true
						});
					} else {
						routes.forEach((route) => {
							this._ensureEdge(outputName, nodeId, route);
						});
					}
				}
			);
		}
	}

	/**
	 * Sets the name of a node
	 * @param  {string} nodeId - Node ID
	 * @param  {string} name   - New node name
	 */
	changeNodeName(nodeId, name) {
		const source = this.getNodeUnsafe(nodeId);
		source.name = name;
	}

	/**
	 * Modifies the method of a node to match a new spec
	 * @param {string} nodeId - The id of the node to update.
	 * @param {string} method - the method to use
	 * @param {object} nodehandler - the node handler in use
	 */
	changeMethod(nodeId, method, nodehandler) {
		const source = this.getNodeUnsafe(nodeId);
		// remove all parameters from the node
		for (let i = source.parameters.length - 1; i >= 0; i--) {
			this._removeParameter('parameters', nodeId, i);
		}

		// remove all authorizations from the node
		const authorizations = source.authorizations || [];
		for (let i = authorizations.length - 1; i >= 0; i--) {
			this._removeParameter('authorizations', nodeId, i);
		}

		const spec = nodehandler && nodehandler.methods[method];
		if (!spec) {
			throw new Error(`method ${method} does not exist in provided flow-node`);
		}

		// Build new outputs
		const specOutputs = spec.outputs || {};

		// loop over the existing outputs
		Object.keys(source.outputs).forEach(outputName => {
			if (!specOutputs[outputName]) {
				// delete the output (and all it's routes / edges) if it doesn't exit in the new spec
				this._deleteOutput(nodeId, outputName);
			}
		});

		// add/update the outputs
		Object.keys(specOutputs).forEach(outputName => {
			const specOutput = specOutputs[outputName];
			const newOutput = {
				routes: [],
				...source.outputs[outputName] || {}
			};
			// Port over context from the spec if it's different to anything that exists
			if (specOutput.context && specOutput.context !== newOutput.context) {
				newOutput.context = specOutput.context;
			}
			source.outputs[outputName] = newOutput;
		});

		// Change node name
		// Only if the current name is the node ID or is the default node name (i.e. method name),
		const nodeMethodName = (source.method && nodehandler && nodehandler.methods[source.method]
				&& nodehandler.methods[source.method].name) || source.method;
		if (source.name === nodeId || source.name === nodeMethodName) {
			source.name = spec.name || method;
		}

		// set the new method
		source.method = method;
		this._onChange();
	}

	/**
	 * Inserts a node into the flow graph.
	 * @param {object} node - The node to insert.
	 * @param {string} nodeId - The id of the node to insert.
	 *  If supplied, it must be unique.
	 *  If not supplied, the node id will be generated.
	 * @returns {string} - the inserted nodeId
	 */
	insertNode(node, nodeId) {
		if (nodeId) {
			const exists = this.getNode(nodeId);
			if (exists) {
				// Internally, something bad happened
				throw new Error(`a node with that id already exists: ${nodeId}`);
			}
		} else {
			// generate a nodeId from the type.
			const type = node.type.substr(node.type.lastIndexOf('/') + 1);
			let exists;
			let i = 1;
			do {
				nodeId = `${type}.${i}`;
				exists = this.getNode(nodeId);
				i += 1;
			} while (exists);
		}

		if (this.isEmpty()) {
			// if the flow is empty, automatically set the start
			this.flow.start = nodeId;
		}
		this.flow.nodes[nodeId] = node;

		this._buildVertex(nodeId);

		this._onChange();

		return nodeId;
	}

	/**
	 * Delete a specific node from the flow.
	 *
	 * @param {string} nodeId - the id of the node to delete
	 */
	deleteNode(nodeId) {
		const node = this.getNode(nodeId);
		if (!node) {
			return;
		}

		// Get the default output of the node. It's children become the children of the parent.
		const parents = this.getParents(nodeId, true);
		const children = this.getChildren(nodeId, true);

		parents.forEach(parentId => {
			this.deleteRoutes(parentId, nodeId);
		});
		children.forEach(childId => {
			this.deleteRoutes(nodeId, childId);
		});

		if (this.flow.start === nodeId) {
			this.flow.start = null;
		}

		this._deleteVertex(nodeId);
		delete this.flow.nodes[nodeId];

		this._onChange();
	}

	/**
	 * Delete the output route from one node to another.
	 *
	 * @param {string} output - the output to delete the route for.
	 * @param {string} fromId - the node id the routes are being deleted from.
	 * @param {string} toId - the node id being removed from the routes.
	 */
	deleteRoute(output, fromId, toId) {
		// Delete the edges
		this._deleteEdge(fromId, output, toId);

		// Update the flow
		const node = this.getNode(fromId);
		if (!node) {
			return;
		}

		if (node.outputs && node.outputs[output]) {
			if (node.outputs[output].routes && node.outputs[output].routes.length) {
				node.outputs[output].routes = node.outputs[output].routes.filter(route => route !== toId);
			}
		}
	}

	/**
	 * Delete all the output routes from one node to another.
	 *
	 * @param {string} fromId - the node id the routes are being deleted from.
	 * @param {string} toId - the node id being removed from the routes.
	 */
	deleteRoutes(fromId, toId) {
		// Delete the edges
		this._deleteEdges(fromId, toId);

		// Update the flow
		const node = this.getNode(fromId);
		if (!node) {
			return;
		}

		if (node.outputs && Object.keys(node.outputs).length > 0) {
			Object.keys(node.outputs).forEach(output => {
				if (node.outputs[output].routes && node.outputs[output].routes.length) {
					node.outputs[output].routes = node.outputs[output].routes.filter(route => route !== toId);
				}
			});
		}
	}

	/**
	 * Sets a node as the start node for the flow.
	 * @param {string} nodeId - The start node for the flow.
	 */
	setStart(nodeId) {
		const source = this.getNode(nodeId);
		if (!source) {
			throw new Error(`start node not found: ${nodeId}`);
		}

		if (this.flow.start !== nodeId) {
			this.flow.start = nodeId;
			this._onChange();
		}
	}

	/**
	 * Clears the start node for the flow.  This action will make the flow invalid.
	 */
	unsetStart() {
		this.flow.start = null;
		this._onChange();
	}

	/**
	 * Adds a parameter to a node in the flow
	 * @param {string} nodeId - the node id
	 * @param {string} name - the name of the parameter
	 * @param {string} value - the value of the parameter
	 * @param {string} [type=jsonpath] - the type of the parameter.
	 */
	addParameter(nodeId, name, value, type = 'jsonpath') {
		this._addParameter('parameters', nodeId, name, value, type);
	}

	/**
	 * Updates a parameter from a node in the flow
	 * @param {string} nodeId - the node id
	 * @param {string} name - the current name of the parameter
	 * @param {string|object} prop - the field to update (name|type|value) if string,
	 *                               or the new value of the parameter
	 * @param {string} newValue - the new value of the prop specified if it is a string
	 */
	updateParameter(nodeId, name, prop, newValue) {
		this._updateParameter('parameters', nodeId, name, prop, newValue);
	}

	/**
	 * Removes a parameter by name from a node in the flow
	 * @param {string} nodeId - the node id
	 * @param {string} name - the name of the parameter
	 * @returns {object} the parameter that was removed
	 */
	removeParameter(nodeId, name) {
		return this._removeParameterByName('parameters', nodeId, name);
	}

	/**
	 * Adds a authorization parameter to a node in the flow
	 * @param {string} nodeId - the node id
	 * @param {string} name - the name of the parameter
	 * @param {string} value - the value of the parameter
	 * @param {string} [type=jsonpath] - the type of the parameter.
	 */
	addAuthorization(nodeId, name, value, type = 'jsonpath') {
		this._addParameter('authorizations', nodeId, name, value, type);
	}

	/**
	 * Updates a authorization parameter from a node in the flow
	 * @param {string} nodeId - the node id
	 * @param {string} name - the current name of the parameter
	 * @param {string|object} prop - the field to update (name|type|value) if string,
	 *                               or the new value of the parameter
	 * @param {string} newValue - the new value of the prop specified if it is a string
	 */
	updateAuthorization(nodeId, name, prop, newValue) {
		this._updateParameter('authorizations', nodeId, name, prop, newValue);
	}

	/**
	 * Removes a authorization parameter by name from a node in the flow
	 * @param {string} nodeId - the node id
	 * @param {string} name - the name of the parameter
	 * @returns {object} the parameter that was removed
	 */
	removeAuthorization(nodeId, name) {
		return this._removeParameterByName('authorizations', nodeId, name);
	}

	/**
	 * Adds a parameter to a node in the flow
	 * @param {string} location - the parameter location, one of: parameters|authorizations
	 * @param {string} nodeId - the node id
	 * @param {string} name - the name of the parameter
	 * @param {string} value - the value of the parameter
	 * @param {string} [type=jsonpath] - the type of the parameter.
	 */
	_addParameter(location, nodeId, name, value, type = 'jsonpath') {
		const source = this.getNodeUnsafe(nodeId);
		if (!name) {
			throw new Error('parameter name required');
		}
		if (this._getParameterIndex(location, nodeId, name) !== -1) {
			throw new Error('parameter already exists');
		}
		if (typeof value !== 'string' && value !== undefined) {
			throw new Error('value is not a string');
		}
		if (![ 'credential', 'jsonpath', 'array', 'null', 'object', 'string', 'number', 'boolean' ].includes(type)) {
			throw new Error(`invalid type: ${type}`);
		}
		if (!source.hasOwnProperty(location)) {
			source[location] = [];
		}
		source[location].push({
			name,
			type,
			value
		});
		this._onChange();
	}

	/**
	 * Gets a parameter from the node by name
	 * @param {string} location - the parameter location, one of: parameters|authorizations
	 * @param {string} nodeId - the node id
	 * @param {string} name - the name of the parameter
	 * @returns {object} the parameter
	 */
	_getParameter(location, nodeId, name) {
		const index = this._getParameterIndex(location, nodeId, name);
		if (index === -1) {
			throw new Error(`parameter ${name} does not exist in node ${nodeId}`);
		}
		return this.getNode(nodeId)[location][index];
	}

	/**
	 * Gets a parameter index from the node by name
	 * @param {string} location - the parameter location, one of: parameters|authorizations
	 * @param {string} nodeId - the node id
	 * @param {string} name - the name of the parameter
	 * @returns {object} the parameter index
	 */
	_getParameterIndex(location, nodeId, name) {
		const node = this.getNodeUnsafe(nodeId);
		if (!node[location]) {
			return -1;
		}
		return node[location].findIndex(param => param.name === name);
	}

	/**
	 * Updates a parameter from a node in the flow
	 * @param {string} location - the parameter location, one of: parameters|authorizations
	 * @param {string} nodeId - the node id
	 * @param {string} name - the current name of the parameter
	 * @param {string|object} prop - the field to update (name|type|value) if string,
	 *                               or the new value of the parameter
	 * @param {string} newValue - the new value of the prop specified if it is a string
	 */
	_updateParameter(location, nodeId, name, prop, newValue) {
		const index = this._getParameterIndex(location, nodeId, name);
		let oldParam;
		if (index !== -1) {
			oldParam = this._removeParameter(location, nodeId, index);
		} else {
			oldParam = { name };
		}

		let newParameter;
		if (typeof prop === 'string') {
			if (![ 'type', 'name', 'value' ].includes(prop)) {
				throw new Error('prop must be one of type, name, or value');
			}
			newParameter = {
				...oldParam,
				[prop]: newValue
			};

		} else if (!prop || prop.constructor !== Object) {
			throw new Error('prop must be a string or an object');
		} else {
			newParameter = prop;
		}
		this._addParameter(location, nodeId, newParameter.name, newParameter.value, newParameter.type);
	}

	/**
	 * Removes a parameter by name from a node in the flow
	 * @param {string} location - the parameter location, one of: parameters|authorizations
	 * @param {string} nodeId - the node id
	 * @param {number} name - the name of the parameter
	 * @returns {object} the parameter that was removed
	 */
	_removeParameterByName(location, nodeId, name) {
		if (!name) {
			throw new Error('parameter name required');
		}
		const index = this._getParameterIndex(location, nodeId, name);
		if (index === -1) {
			throw new Error(`parameter ${name} does not exist in node ${nodeId}`);
		}
		const removed = this._removeParameter(location, nodeId, index);
		this._onChange();
		return removed;
	}

	/**
	 * Removes a parameter by index from a node in the flow.  Does not trigger change.
	 * @param {string} location - the parameter location, one of: parameters|authorizations
	 * @param {string} nodeId - the node id
	 * @param {number} index - the index of the parameter
	 * @returns {object} the parameter that was removed
	 */
	_removeParameter(location, nodeId, index) {
		const source = this.getNodeUnsafe(nodeId);
		if (typeof index !== 'number') {
			throw new Error('parameter index must be a number');
		}

		if (index >= source[location].length || index < 0) {
			throw new Error(`parameter with index ${index} does not exist in node ${nodeId}`);
		}

		const removed = source[location].splice(index, 1);
		return removed[0];
	}

	/**
	 * Modifies the JSONPath context of an output
	 * @param {string} nodeId - the node id
	 * @param {string} name - the name of the output
	 * @param {string} value - the new JSONPath context
	 */
	updateOutputContext(nodeId, name, value) {
		const source = this.getNodeUnsafe(nodeId);
		if (!name) {
			throw new Error('output name required');
		}
		const output = source.outputs[name];
		if (!output) {
			throw new Error(`output ${name} does not exist`);
		}
		output.context = value;
		this._onChange();
	}

	/**
	 * Connects a node output to the specified target.
	 * @param {string} sourceId - The source node for the connection.
	 * @param {string} sourceOutput - The output in the source node for the connection.
	 * @param {string} targetId - The id of the target node to connect to.
	 */
	connectNode(sourceId, sourceOutput, targetId) {
		const source = this.getNode(sourceId);
		if (!source) {
			throw new Error(`source node not found: ${sourceId}`);
		} else if (!source.outputs[sourceOutput]) {
			throw new Error(`source output not found: ${sourceOutput}`);
		}

		const target = this.getNode(targetId);
		if (!target) {
			throw new Error(`target node not found: ${targetId}`);
		}

		if (this.flow.nodes[sourceId].outputs[sourceOutput].routes
				&& this.flow.nodes[sourceId].outputs[sourceOutput].routes.indexOf(targetId) !== -1) {
			throw new Error(`route already exists: ${sourceId}:${sourceOutput} to ${targetId}`);
		}

		// Update the flow def
		this.flow.nodes[sourceId].outputs[sourceOutput] = {
			...this.flow.nodes[sourceId].outputs[sourceOutput],
			routes: [
				...(this.flow.nodes[sourceId].outputs[sourceOutput].routes || []),
				targetId
			]
		};

		this._ensureEdge(sourceOutput, sourceId, targetId);
		this._onChange();
	}

	/**
	 * Disconnects a target node from a parent node's source and output.
	 * @param {string} sourceId - The source node for the connection.
	 * @param {string} sourceOutput - The output in the source node for the connection.
	 * @param {string} targetId - The id of the target node to connect to.
	 */
	disconnectNode(sourceId, sourceOutput, targetId) {
		this.deleteRoute(sourceOutput, sourceId, targetId);
		this._onChange();
	}

	/**
	 * Indicates if the flow is empty, with no nodes.
	 * @returns {boolean} `true` if the flow is empty.
	 */
	isEmpty() {
		return !Object.keys(this.flow.nodes).length;
	}

	/**
	 * Gets the name of the flow from flow info meta-data.
	 * @returns {string} the flow name
	 */
	getName() {
		return this.flow.info.name;
	}

	/**
	 * Get the unique symbol of the flow
	 *
	 * @returns {symbol} the flow symbol
	 */
	getSymbol() {
		return this.symbol;
	}

	/**
	 * Gets the definition of the flow
	 * @returns {object} the flow definition
	 */
	getDefinition() {
		return this.flow;
	}

	/**
	 * Gets the graph representation of the flow
	 * @returns {object} the flow graph representation
	 */
	getGraph() {
		return this.graph;
	}

	/**
	 * Gets the Id of the flow
	 * @returns {string} the flow id
	 */
	getId() {
		return this.id;
	}

	/**
	 * Gets the edges of the flow graph
	 * @returns {object[]} the edges of the graph
	 */
	getEdges() {
		return this.graph.edges;
	}

	/**
	 * Get the edge between two nodes.
	 *
	 * @param {string} output - the node output the edges belong to.
	 * @param {string} fromId - the ID of the vertex where the edge starts
	 * @param {string} toId - this ID of the vertex where the edge ends
	 * @returns {object|null} the edge between two nodes. Null if no edge exists.
	 */
	getEdge(output, fromId, toId) {
		if (this.graph.vertices[fromId]
				&& this.graph.vertices[fromId].children[output]
				&& this.graph.vertices[fromId].children[output][toId]) {
			return {
				output,
				to: toId,
				from: fromId
			};
		}
		return null;
	}

	/**
	 * Gets the vertices of the graph
	 *
	 * @param {bool} [idsOnly] - if the vertex ids should be returned rather than the vertices
	 * @returns {string[]|object[]} the vertices of the graph
	 */
	getVertices(idsOnly) {
		return objectToArray(this.graph.vertices, idsOnly);
	}

	/**
	 * Gets the nodes of the flow
	 *
	 * @param {bool} [idsOnly] - if the node ids should be returned rather than the nodes
	 * @returns {string[]|object[]} the nodes of the flow
	 */
	getNodes(idsOnly) {
		return objectToArray(this.flow.nodes, idsOnly || (nodeId => this.getNode(nodeId)));
	}

	/**
	 * Gets the children of a node in the flow
	 *
	 * @param {string} nodeId - the Id of the node to get children for.
	 * @param {string} output - the node output to get the children for.
	 *                          If omitted then all children are returned.
	 * @param {bool} [idsOnly] - if the node idsOnly should be returned rather than the nodes
	 * @returns {string[]|object[]} the child nodes of a node in the flow
	 */
	getChildren(nodeId, output, idsOnly) {
		let verts;
		if (arguments.length <= 2 && typeof output !== 'string') {
			idsOnly = output || false;
			verts = Object.keys(this.graph.vertices[nodeId].children).reduce(
				(col, cur) => {
					const outputChildren = this.graph.vertices[nodeId].children[cur];
					col = Object.assign(col, outputChildren);
					return col;
				}, {}
			);
		} else {
			verts = this.graph.vertices[nodeId].children[output];
		}

		return objectToArray(
			verts,
			idsOnly
			|| (childId => this.getNode(childId))
		);
	}

	/**
	 * Gets the parents of a node in the flow
	 *
	 * @param {string} nodeId - the Id of the node to get parents for.
	 * @param {bool} [idsOnly] - if the node ids should be returned rather than the nodes
	 * @returns {string[]|object[]} the parent nodes of a node in the flow
	 */
	getParents(nodeId, idsOnly) {
		return objectToArray(
			this.graph.vertices[nodeId].parents,
			idsOnly
			|| (parentId => this.getNode(parentId))
		);
	}

	/**
	 * Gets the terminal nodes of the flow
	 *
	 * @param {bool} [idsOnly] - if the node ids should be returned rather than the nodes
	 * @returns {string[]|object[]} the terminal nodes of the flow
	 */
	getTerminalNodes(idsOnly) {
		return this.getVertices()
			.filter(vertex => vertex && vertex.info.terminal)
			.map(vertex => {
				return idsOnly ? vertex.id : this.getNode(vertex.id);
			});
	}

	/**
	 * Get the vertex which matches the ID specified
	 *
	 * @param {string} vertexId - the ID of the vertex to return
	 * @returns {object} a vertex in the graph
	 */
	getVertex(vertexId) {
		return this.graph.vertices[vertexId] || null;
	}

	/**
	 * Get the node which matches the ID specified
	 *
	 * @param {string} nodeId - the ID of the node to return
	 * @returns {object|null} a node in the flow, or null
	 */
	getNode(nodeId) {
		return this.flow.nodes[nodeId] || null;
	}

	/**
	 * Get the node which matches the ID specified and will throw an error if node was not found.
	 * Call this if you expect the node to exist
	 *
	 * @param {string} nodeId - the ID of the node to return
	 * @returns {object} a node in the flow
	 */
	getNodeUnsafe(nodeId) {
		const node = this.flow.nodes[nodeId];
		if (!node) {
			throw new Error(`node not found: ${nodeId}`);
		}
		return node;
	}

	/**
	 * Get the validation state of the flow
	 *
	 * @returns {object} the validation state of the flow
	 */
	getValidation() {
		return this.flow['x-validation'] || Object.create(null);
	}

	/**
	 * Registers a FlowValidator type class to the flow. When validation is run, this class will
	 * be used to validate the flow.
	 *
	 * @param {FlowValidator} validator - A class which is a FlowValidator
	 */
	registerValidator(validator) {
		this.FlowValidator = validator;
	}

	/**
	 * Validate the flow - check all the nodes, no cycles, syntax, etc.
	 * Update the definition to make validation report available to clients
	 * @returns {object} the validation state
	 */
	validate() {
		const validation = new this.FlowValidator(this, this.credentialManager).validate();
		this._setValidation(validation);
		return validation;
	}
}

FlowGraph.Validator = FlowValidator;

exports = module.exports = FlowGraph;
