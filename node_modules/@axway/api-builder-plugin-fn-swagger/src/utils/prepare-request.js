module.exports = (context, logger) => {
	const { requestData, authorizationData, endpointMetadata } = context;
	const parametersMetadata = endpointMetadata.parameters;

	/**
	 * This is what is built as a result of preprocessing
	 */
	const preparedRequestData = {
		query: {},
		header: {},
		path: {},
		body: undefined
	};

	for (const requestParamName in requestData) {
		const requestParamValue = requestData[requestParamName];
		if (validParamName(requestParamName)) {
			const { section, name } = splitParamIfNamespaced(requestParamName);
			if (section) {
				// Parameter is namespaced
				if (section === 'body') {
					// In case of a body we set as direct dependencies
					preparedRequestData[section] = requestParamValue;
				} else {
					preparedRequestData[section][name] = requestParamValue;
				}
			} else {
				// Parameter is not namespaced so search where it is and add it
				parametersMetadata['query'].forEach((paramObj) => {
					if (paramObj.name === requestParamName) {
						preparedRequestData.query[requestParamName] = requestParamValue;
					}
				});
				parametersMetadata['header'].forEach((paramObj) => {
					if (paramObj.name === requestParamName) {
						preparedRequestData.header[requestParamName] = requestParamValue;
					}
				});
				parametersMetadata['path'].forEach((paramObj) => {
					if (paramObj.name === requestParamName) {
						preparedRequestData.path[requestParamName] = requestParamValue;
					}
				});
				parametersMetadata['body'].forEach((paramObj) => {
					if (paramObj.name === requestParamName) {
						// Note that body usually has only one parameter that must be assigned to the body
						preparedRequestData.body = requestParamValue;
					}
				});
			}
		}
	}
	addAuthorization();
	return preparedRequestData;

	function addAuthorization() {
		const security = endpointMetadata.security;
		if ((!security || !security.length) && !authorizationData) {
			// we have no authorization to apply
			return;
		} else {
			const authorizations = findValidSecurityRequirement(security);
			for (const authzParamName in authorizations) {
				const authzParamValue = authorizations[authzParamName];
				const info = getAuthInfo(authzParamName, authzParamValue);
				preparedRequestData[info.in][info.name] = info.value;
			}
		}
	}

	/**
	 * Verifies the compatibility between what is provided as security requirement
	 * and what is provided as actual credentials passed.
	 *
	 * @param {Array} security list with security requirement objects
	 * @throws in case there is no match between security requirements and credentials provided.
	 * @return {object} valid authorizations that must be applied on the request
	 */
	function findValidSecurityRequirement(security) {
		const isOptional = isOptionalSecurity(security);
		const packingCredentials = hasCredentials();
		if ((!security || !security.length) && packingCredentials) {
			logger.error(`Credentials are not required, but the invoked flow is configured to include: ${Object.keys(authorizationData)}`);
		} else if (!isOptional && !packingCredentials) {
			throw new Error(`Credentials are required.  Please provide: ${formatSecurityRequirement(security)}`);
		} else {
			// note that `authorizationData` can be null
			const authorizations = getMatchingAuthorizations(security);
			const incomplete = !Object.keys(authorizations).length;
			if (incomplete && !isOptionalSecurity(security)) {
				throw new Error(`None of the supplied credentials match the requirements for: ${formatSecurityRequirement(security)}`);
			} else {
				return authorizations;
			}
		}
	}

	/**
	 * Formats the security requirements into AND/OR string
	 *
	 * @param {Object[]} security - The list of security requirements for the method
	 * @returns {String} A formatted set of security requirements
	 */
	function formatSecurityRequirement(security) {
		return security.map(a => Object.keys(a))
			.map(m => {
				return m.join(' & ');
			})
			.join(' | ');
	}

	/**
	 * Returns true if there are credentials
	 * @returns {Boolean} returns true if there are credentials provided.
	 */
	function hasCredentials() {
		return authorizationData && Object.keys(authorizationData).length;
	}

	/**
	 * Test to see if any of the security requirements are optional, i.e. {}.
	 *
	 * @param {Object[]} security - The list of security requirements for the method
	 * @returns {Boolean} returns true if the security is optional.
	 */
	function isOptionalSecurity(security) {
		if (!security || !security.length) {
			return true;
		}
		for (const securityRequirement of security) {
			if (!Object.keys(securityRequirement).length) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Gets all supplied credentials that match the security requirements.  For a credential
	 * to be added, it must be defined, and must match the security requirements completely.
	 *
	 * Checks for both:
	 * 		OR relationship => [{apiKey: []} || {oAuth: []}]
	 * 		AND relationship => [{apiKey: [] && oAuth: []} || {basic:[]}]
	 *
	 * @param {Object[]} security - The list of security requirements for the method
	 * @returns {Object} returns credentials matching the security requirements.
	 */
	function getMatchingAuthorizations(security) {
		const authorizations = {};
		if (authorizationData) {
			for (const securityRequirement of security) {
				// add the credential only if every requirement is met
				const keys = Object.keys(securityRequirement);
				if (keys.every(a => authorizationData.hasOwnProperty(a))) {
					keys.reduce((acc, authName) => {
						acc[authName] = authorizationData[authName];
						return acc;
					}, authorizations);
				}
			}
		}
		return authorizations;
	}

	/**
	 * Gets the metainfo for the configured authorizations.
	 * Return silently if unknown authorization is provided.
	 *
	 * @param {string} authzParamName the name of the selected security requirement
	 * @param {string} authzParamValue the value of the selected security requirement
	 * @returns {object} returns information about credentials and their position in the http request
	 */
	function getAuthInfo(authzParamName, authzParamValue) {
		const def = endpointMetadata.securityDefinitions && endpointMetadata.securityDefinitions[authzParamName];
		if (!def) {
			const defs = endpointMetadata.securityDefinitions && Object.keys(endpointMetadata.securityDefinitions);
			const knownError = defs && defs.length > 0 ? `Only the following authorization parameters are known: ${defs.join(', ')}.` : 'There are no known authorization parameters.';
			throw new Error(`Unknown authorization parameter '${authzParamName}' provided to request. ${knownError}`);
		}
		if (def.type === 'apiKey') {
			return {
				in: def.in,
				name: def.name,
				value: authzParamValue
			};
		} else if (def.type === 'basic') {
			return {
				in: 'header',
				name: 'Authorization',
				value: `Basic ${authzParamValue}`
			};
		} else if (def.type === 'oauth2') {
			return {
				in: 'header',
				name: 'Authorization',
				value: `Bearer ${authzParamValue}`
			};
		} else {
			throw new Error(`Unknown authorization type '${def.type}' provided to request. Supproted types are basic, apiKey, oauth2.`);
		}
	}

};

/**
 * Check if parameter name is valid.
 *
 * @param {string} requestParamName parameter name
 * @returns {boolean} true if valid name
 */
function validParamName(requestParamName) {
	return ![ undefined, 'undefined', null, 'null', '' ].includes(requestParamName);
}

/**
 * Convention with the API Builder is to provide parameters with the same name prefixed with the location they shold be.
 * For example if we have name in the path and in the header we will get path.name and header.name for request parameter.
 * We need to get the section out of
 *
 * @param {string} requestParam request parameter passed
 * @returns {object} Contains the section where the parameters should be place and the name of the parameter
 */
function splitParamIfNamespaced(requestParam) {
	const allowedSections = [ 'query', 'body', 'header', 'path' ];
	const paramParts = requestParam.split('.');
	if (paramParts.length > 1) {
		// we do have dots in param name
		const section = paramParts.shift(1);
		if (allowedSections.includes(section)) {
			// the first thing before the dot denotes valid namespace
			return {
				section,
				name: paramParts.join('.')
			};
		}
	}
	return {};
}
