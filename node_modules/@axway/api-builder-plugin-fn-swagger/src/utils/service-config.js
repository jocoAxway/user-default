const fs = require('fs');
const dot = require('dot');
const path = require('path');
const dirs = require('./dirs');
const createStubCredentials = require('./stub-credentials');
const confDir = path.join(process.cwd(), 'conf');
const ALLOWED_PLUGIN_CONFIG = [ 'uri' ];
const ALLOWED_REQUESTER_CONFIG = [ 'proxy', 'insecureSSL' ];

const template = `\
module.exports = {
	// The configuration settings for your Swagger service.
	pluginConfig: {
		'@axway/api-builder-plugin-fn-swagger': {
			'{{=it.name}}': {
				// It is possible to override Swagger URI options when constructing
				// outbound requests from the Swagger plugin.
				uri: {
					// protocol: 'https',
					// host: 'hostname',
					// port: 443,
					// basePath: '/api'
				}
			}
		}
	}{{? it.credentials.length }},
	// The following authorization credentials needed to use the Swagger service.
	// Please follow this guide to manually configure the credentials:
	// https://docs.axway.com/bundle/API_Builder_4x_allOS_en/page/api_builder_credentials.html
	authorization: {
		credentials: {
{{=it.credentials}}
		}
	}
{{?}}};
`;

/**
 * Tests whether or not the API Builder application is in developer mode.  The test
 * is to check to see if @axway/api-builder-admin exists.
 *
 * @returns {boolean} True if in developer mode.
 */
function isDeveloperMode() {
	try {
		// If we are in "development mode" we are going to have @axway/api-builder-admin
		// dependency installed. So we guarantee that only generate config files in
		// "development mode" and ensure immutable production environments.
		// eslint-disable-next-line import/no-unresolved
		require('@axway/api-builder-admin');
		return true;
	} catch (ex) {
		return false;
	}
}

/**
 * Generates configuration based on a unique Swagger service name (e.g. filename prefix).
 *
 * @param {string} swaggerName - The unique name of the Swagger service.
 * @param {string} swaggerTitle - The title from the Swagger definition.
 * @param {object} [credentials=null] - A set of stub credentials for the service, e.g.
 *		from `{@link createStubCredentials}`.
 * @returns {string} The Swagger service configuration file.
 */
function generateConfig(swaggerName, swaggerTitle, credentials = null) {
	const params = {
		name: swaggerName,
		credentials: ''
	};
	if (credentials) {
		// This isn't pretty, but it is quite challenging to generate configuration.
		// DoT did not do a good job of it.  The best approach was to JSON encode each
		// credential, and then munge it to have the correct indentation and quotation.
		Object.keys(credentials).forEach((name, i, arr) => {
			let credential = JSON.stringify(credentials[name], null, '\t');
			credential = credential
				.replace(/{/, `\t\t\t'${swaggerTitle} ${name}': {`)		// changes "{" to (indented) "$name: {"
				.replace(/\t+"(.*)":/g, '\t\t\t\t$1:')	// changes "key":"value" to (indented) key:"value"
				.replace(/"/g, '\'')					// changes all " quotes to '
				.replace(/}/, '\t\t\t}');				// indents trailing "}"

			if (i + 1 < arr.length) {
				credential += ',\n';
			}
			params.credentials += credential;
		});
	}

	dot.templateSettings = {
		...dot.templateSettings,
		strip: false
	};
	const fn = dot.template(template);
	return fn(params);
}

/**
 * Writes a file to disk. If a file already exists at the specified location,
 * the file will be written with .1 .2 etc.. appended to the name.  The `config`
 * should be generated from `{@link generateConfig}`.
 *
 * @param {string} serviceName - The service name, which is the config file prefix.
 * @param {object} config - The configuration data to write.
 * @param {object} logger - The logger which allow you to log from within the swagger plugin.
 */
function writeUniqueConfigFile(serviceName, config, logger) {
	const filename = write(serviceName);
	logger.info(`${filename} plugin configuration file has been copied to your API Builder conf directory. You must configure the file located in ${confDir}`);

	function write(serviceName, filename = serviceName, count = 0) {
		const fn = dirs.confFileLocation(filename);
		try {
			fs.statSync(fn);
			// File already exists. try with a different name.
			return write(serviceName, `${serviceName}.${count}`, ++count);
		} catch (err) {
			if (err.code === 'ENOENT') {
				fs.writeFileSync(fn, config);
				return fn;
			}
		}
	}
}

/**
 * Gets or generates the service configuration from `serviceConfig` by the name `swaggerName`.
 * If the configuration object exists in `serviceConfig`, it is returned.  If it does not
 * exist, then when in developer mode, it will generate and save a config file with stub
 * configuration and at the same time will add those stub credentials to the
 * CredentialManager so that the credentials are bootstrapped for the first time.
 *
 * @param {object} pluginConfig - The plugin configuration, e.g. `pluginConfig: { foo: {} }`
 * @param {string} swaggerName - The name of the Swagger service
 * @param {object} swagger - A Swagger definition
 * @param {object} logger - The logger which allow you to log from within the swagger plugin.
 * @return {object} A service configuration for the service.
 */
function getServiceConfig(pluginConfig, swaggerName, swagger, logger) {
	const cfg = {
		pluginConfig: {},
		requesterConfig: {}
	};

	// If there already exists a config file for this swagger, it will be passed in
	if (pluginConfig[swaggerName]) {
		const swaggerCfg = pluginConfig[swaggerName];
		// only copy/map over the allowed plugin configuration
		ALLOWED_PLUGIN_CONFIG.forEach((keyName) => {
			if (swaggerCfg.hasOwnProperty(keyName)) {
				cfg.pluginConfig[keyName] = swaggerCfg[keyName];
			}
		});
		// only copy/map over the allowed requester configuration
		ALLOWED_REQUESTER_CONFIG.forEach((keyName) => {
			if (swaggerCfg.hasOwnProperty(keyName)) {
				cfg.requesterConfig[keyName] = swaggerCfg[keyName];
			}
		});
		return cfg;
	}

	// If no config exists for this swagger, check if this is in developer mode, and if so,
	// generate a config file with stub credentials.
	if (isDeveloperMode()) {
		let APIBuilder;
		try {
			APIBuilder = require('@axway/api-builder-runtime');
		} catch (ex) {
			throw new Error('Plugin is not loaded via an existing @axway/api-builder-runtime instance');
		}
		const instance = APIBuilder.getGlobal();
		if (!instance) {
			throw new Error('No @axway/api-builder-runtime instance');
		}

		// builds a set of `credentials` from the found in the swagger `method.authorization`
		const stubCredentials = createStubCredentials(swagger, logger);

		// The plugin configuration does not yet exist, but the user is in developer
		// mode, so generate one and include credential stubs.
		const moduleExports = generateConfig(swaggerName, swagger.info.title, stubCredentials);
		writeUniqueConfigFile(swaggerName, moduleExports, logger);

		// As discussed 2018-11-19, we will get access to the APIBuilder runtime instance and
		// write all stub credentials to the CredentialManager.  This is so that these new
		// (stubbed) credentials can be bootstrapped and available to the UI the first time.
		// Afterwards, they will be read from the generated configuration file only.
		const credentialManager = instance.flowManager.credentialManager;
		Object.keys(stubCredentials)
			.forEach(credential => {
				credentialManager.addCredential({
					name: `${swagger.info.title} ${credential}`,
					...stubCredentials[credential]
				});
			});
	}

	return cfg;
}

exports = module.exports = {
	generateConfig,
	writeUniqueConfigFile,
	isDeveloperMode,
	getServiceConfig
};
