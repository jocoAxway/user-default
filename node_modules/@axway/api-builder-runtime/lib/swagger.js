const _ = require('lodash');
const chalk = require('chalk');
const util = require('util');
const Swagger = require('openapi-doc');
const pluralize = require('pluralize');
const schemas = require('axway-schema');
const apiBuilderConfig = require('@axway/api-builder-config');
const ObjectModel = require('./objectmodel');

var verbMap = {
	POST: 'create',
	GET: 'find',
	PUT: 'update',
	DELETE: 'delete'
};

var ResponseModel = {
	type: 'object',
	required: [
		'success',
		'request-id'
	],
	additionalProperties: false,
	properties: {
		code: {
			type: 'integer',
			format: 'int32'
		},
		success: {
			type: 'boolean',
			default: false
		},
		'request-id': {
			type: 'string'
		},
		message: {
			type: 'string'
		},
		url: {
			type: 'string'
		}
	}
};

var ErrorModel = {
	type: 'object',
	required: [
		'message',
		'code',
		'success',
		'request-id'
	],
	properties: {
		code: {
			type: 'integer',
			format: 'int32'
		},
		success: {
			type: 'boolean',
			default: false
		},
		'request-id': {
			type: 'string'
		},
		message: {
			type: 'string'
		},
		url: {
			type: 'string'
		}
	}
};

/**
 * Default response codes applied on the endpoints
 */
const defaultResponses = {
	401: {
		description: 'Unauthorized',
		schema: {}
	}
};

module.exports.bindRoutes = bindRoutes;
module.exports.generateSwagger = generateSwagger;
module.exports.schemaIdToSwaggerName = schemaIdToSwaggerName;

/**
 * Converts a schema id to a swagger friendly name. Conversion as per the ticket RDPP-1673
 *
 * @param {object} apibuilder - APIBuilder instance
 * @param {string} id - Schema identifier, e.g. schema:///foo
 */
function schemaIdToSwaggerName(id) {
	if (id.startsWith('schema:///')) {
		var ids = id.slice(10).split('/');
		var name = ids.slice(1).join('_');

		if (ids[0] && ids[0] !== 'model') {
			name = ids[0] + '.' + name;
		}
		return name;
	}
	return id;
}

function bindRoutes(apibuilder) {
	const apidocConfig = apibuilder.config.apidoc;
	const app = apibuilder.app;

	// If the admin is active, then bind the swagger docs. They are needed for the UI.
	if (!apidocConfig.disabled || !!apibuilder.admin) {
		const prefix = apidocConfig.prefix;
		apibuilder.logger.trace('Registering swagger routes under path ' + prefix);
		app.get(prefix + '/docs.json', util.deprecate(getDefinition, prefix + '/swagger.json should be used instead.'));
		app.get(prefix + '/swagger.json', getDefinition);
		apibuilder.logger.info('Access the swagger API documentation at ' + chalk.yellow.underline(apibuilder.baseurl + prefix + '/swagger.json'));
	}

	const objectModel = new ObjectModel(apibuilder);
	function getDefinition(req, res) {
		try {
			var keys = Object.keys(req.query),
				typeKeys = keys.filter(function (a) {
					return a.startsWith('endpoints/') || a.startsWith('apis/');
				}),
				force = req.query.force ? (req.query.force === 'true' || req.query.force === '1') : false,
				ignoreOverrides = req.query.ignoreOverrides ? (req.query.ignoreOverrides === 'true' || req.query.ignoreOverrides === '1') : false,
				host = req.get('host'),
				name,
				type,
				result;
			// extract name and type. eg. ?apis/appc.arrowdb/acl (type=apis, name=appc.arrowdb/acl)
			if (typeKeys.length) {
				type = typeKeys[0].split('/')[0];
				name = typeKeys[0].substr(type.length + 1, typeKeys[0].length).replace(/\.(json|html)/g, '');
			}
			result = generateSwagger(apibuilder, host, objectModel, type, name, force, req.secure, ignoreOverrides);
			if (typeof result === 'number') {
				res.sendStatus(result);
			} else {
				res.set('Content-Type', 'application/json');
				res.send(result);
			}
		} catch (ex) {
			apibuilder.logger.error('Error generating swagger:', ex);
			res.status(500).send({ error: 'Server error' });
		}
	}
}

/**
 * Get the models referenced by fields in model composition.
 */
function getCompositionModels(om, modelName, models) {
	var model = om.models[modelName];
	if (model) {
		var referencedModels = new Set(
			Object.keys(model.fields)
				.map(function (fieldName) {
					return model.fields[fieldName];
				})
				.filter(function (field) {
					return field.model && (field.type === 'array' || field.type === Array || field.type === 'object' || field.type === Object);
				})
				.map(function (field) {
					return field.model;
				})
				.filter(function (modelName) {
					return !models || !models.has(modelName);
				})
		);

		// Add the referenced models
		models = models || new Set();
		referencedModels.forEach(function (m) {
			models.add(m);
		});

		// Look for nested dependencies
		referencedModels.forEach(function (m) {
			getCompositionModels(om, m, models);
		});
	}

	return models;
}

// Get the models reference by the APIs
function getAPIModels(om) {
	var referenceModels = new Set();

	// Get a unique list of models reference by the API endpoints.
	Object.keys(om.apis).forEach(function (apiName) {
		var api = om.apis[apiName];
		referenceModels.add(apiName);
		(api.endpoints || []).forEach(function (endpoint) {
			if (endpoint.model) {
				referenceModels.add(endpoint.model);
			}
			if (endpoint.response) {
				referenceModels.add(endpoint.response);
			}
			if (endpoint.models) {
				endpoint.models.forEach(function (model) {
					referenceModels.add(model);
				});
			}
		});
	});

	// Extend the list to include models referenced via field composition
	var referenceAndCompositionlModels = new Set(Array.from(referenceModels).map(
		function (m) {
			return transformKeyForComparison(m);
		}
	));

	referenceModels.forEach(
		function (model) {
			var compModel = getCompositionModels(om, model);
			compModel && compModel.forEach(function (compModel) {
				return referenceAndCompositionlModels.add(transformKeyForComparison(compModel));
			});
		}
	);

	return _.pickBy(om.models, function (value, name) {
		return referenceAndCompositionlModels.has(transformKeyForComparison(name));
	});
}

/**
 * 	Generates a swagger document for the current api builder instance
 * @param {object} apibuilder api builder instance
 * @param {string} host host that is requesting the doc
 * @param {object} objectModel api builder object model instance
 * @param {string} type either 'apis' or 'endpoints' when fetching swagger by name
 * @param {string} name the name of the api/endpoint to generate swagger for
 * @param {bool} force include disabled endpoints in the requested swagger - does not effect requests for a specific endpoint/api
 * @param {bool} secure is the server running ssl?
 * @param {bool} ignoreOverrides do not set user provided overrides on the swagger document
 */
function generateSwagger(apibuilder, host, objectModel, type, name, force, secure, ignoreOverrides) {
	var swagger = new Swagger(),
		om;

	const docOverrides = ignoreOverrides ? {} : apibuilder.config.apidoc.overrides;
	// use overriden host or host from request, or fall back to localhost and server port.
	const myHost = docOverrides.host !== undefined ? docOverrides.host : host || '127.0.0.1' + (apibuilder.port ? ':' + apibuilder.port : '');
	const basePath = docOverrides.basePath !== undefined ? docOverrides.basePath : apibuilder.config.apiPrefix;
	// default to http, use https if accessed over ssl or use the override
	const mySchemes = docOverrides.schemes !== undefined ? docOverrides.schemes : [ !secure ? 'http' : 'https' ];
	const { apiPrefixSecurity } = apibuilder.config.accessControl;

	// Set the swagger API info
	swagger.info(
		apibuilder.metadata.name || 'API',
		apibuilder.metadata.version || '1.0',
		apibuilder.metadata.description || 'API description')
		.host(myHost);

	if (basePath) {
		swagger.basePath(basePath);
	}

	/* Applying globalSchemes here has no affect because there are no paths in the
	 * initial state.  The merge will first copy all global schemes to the current
	 * local paths, and delete the globals.  But since there are no paths, the globals
	 * are deleted.  So, the merge will have the affect of removing schemes from the
	 * document.  This is works as designed, just a little unexpected.  It is more
	 * correct to not have schemes in the Swagger - they default to the scheme used
	 * to access the document.  In fact, schemes do not detail how to access each scheme.
	 */
	// .globalSchemes(createSchemes(objectModel));

	apibuilder.metadata.author && swagger.contact(apibuilder.metadata.author);
	apibuilder.metadata.license && swagger.license(apibuilder.metadata.license);

	// return 404 for undefined name or invalid types
	if (type && (!name || [ 'apis', 'endpoints' ].indexOf(type) === -1)) {
		return 404;
	}

	// Merge in the valid enabled endpoints
	if (!type || type === 'endpoints') {
		if (apibuilder && apibuilder.endpoints) {
			if (type && Object.keys(apibuilder.endpoints).indexOf(name) === -1) {
				return 404;
			}
			function filter(swagger, path, verb) {
				if (force) {
					return true;
				}
				var xenabled = swagger.paths[path][verb]['x-enabled'];
				if (xenabled && xenabled.enabled === false) {
					return false;
				}
				return true;
			}
			Object.keys(apibuilder.endpoints).forEach(function (epName) {
				const xEnabled = apibuilder.endpoints[epName]['x-enabled'];
				let toMerge;
				if (!type && xEnabled && xEnabled.enabled) {
					// in case of a consolidated swagger, merge endpoints on their basepath to avoid
					// collision.  also need to filter out the disabled endpoint paths
					toMerge = {
						prefix: apibuilder.endpointSwaggers[epName].basePath,
						filter: filter,
						extensions: /^x-(?!(enabled|flow)$)/,
						mergeBlacklist: [ 'schemes', 'securityDefinitions' ]
					};
				} else if (epName === name) {
					swagger.basePath(basePath + (apibuilder.endpointSwaggers[epName].basePath || ''));
					toMerge = {
						filter: filter,
						extensions: /^x-(?!(enabled|flow)$)/,
						mergeBlacklist: [ 'schemes', 'securityDefinitions' ]
					};
				}
				if (toMerge) {
					if (apiPrefixSecurity !== 'none') {
						toMerge.defaultResponses = defaultResponses;
					}
					swagger.merge(apibuilder.endpointSwaggers[epName], toMerge);
				}
			});
		}
	}

	// Merge in the model endpoints
	var lookupDefinitions = {};
	if (!type || type === 'apis') {
		if (type) {
			om = _.clone(objectModel);
			var transQuery = transformKeyForComparison(name); // lower-case
			function matchesQuery(value, key) {
				return transformKeyForComparison(key) === transQuery;
			}
			om.apis = _.pickBy(om.apis, matchesQuery);
			if (!Object.keys(om.apis).length) {
				return 404;
			}
			om.models = getAPIModels(om);
		} else {
			om = objectModel;
		}
		if (om && om.apis && Object.keys(om.apis).length) {
			swagger.schemas(createDefinitions(apibuilder, om, lookupDefinitions));
			swagger.paths(createPaths(om, apibuilder, lookupDefinitions));
		}
	}

	// Security definition (see: apibuilder/lib/authentication/index.js)
	// The getSwaggerSecurity method is optional.  If the auth plugin defines one, then it
	// should be used.
	const sec = apibuilder.authStrategy.getSwaggerSecurity();
	if (sec && sec.securityDefinitions) {
		const defs = sec.securityDefinitions;
		if (defs) {
			Object.keys(defs).forEach(function (key) {
				swagger.securityDefinition(key, defs[key]);
			});
		}
		if (sec.security) {
			if (sec.security instanceof Array) {
				swagger.globalSecurity(sec.security);
			} else {
				apibuilder.logger && apibuilder.logger.error('invalid swagger security definition: ', sec.security);
			}
		}
	}

	var doc = swagger.apidoc();

	// Define the scheme used to access the document
	doc.schemes = mySchemes;

	// dereference all $ref to loaded schemas
	return schemas.dereference(doc, {
		target: '#/definitions',
		rename: schemaIdToSwaggerName
	});
}

function transformKeyForComparison(val) {
	return val.replace(/[^a-z0-9]/ig, '').toLowerCase();
}

function createDefinitions(apibuilder, objectModel, lookupDefinitions) {
	const retVal = {};
	const models = objectModel.models;

	Object.entries(models).forEach(([ modelName, model ]) => {
		let schema = [
			{
				key: `#/definitions/${modelName.replace(/\//, '_')}`,
				id: apibuilder.getModelSchemaId(model)
			},
			{
				key: `#/definitions/${modelName.replace(/\//, '_')}-ex`,
				id: apibuilder.getModelSchemaExId(model)
			}
		];

		if (!apiBuilderConfig.flags.enableModelsWithNoPrimaryKey || !(model.metadata && model.metadata.primarykey === null)) {
			schema.push(
				{
					key: `#/definitions/${modelName.replace(/\//, '_')}-full`,
					id: apibuilder.getModelSchemaFullId(model)
				},
				{
					key: `#/definitions/${modelName.replace(/\//, '_')}-fullEx`,
					id: apibuilder.getModelSchemaFullExId(model)
				}
			);
		}

		schema.forEach(({ key, id }) => {
			if (!schemas.get(id)) {
				let msg = `failed to get schema for model: ${modelName}`;
				apibuilder.logger.error(msg);
				throw new Error(msg);
			}
			lookupDefinitions[key] = id;
		});
	});

	retVal.ResponseModel = ResponseModel;
	retVal.ErrorModel = ErrorModel;

	return retVal;
}

// This mirrors the logic in APIBuilder.API for determining
// the api's singular/plural.
function getResponseKey(objectModel, endpoint, isArray) {
	var model;

	var singular = endpoint.singular;
	var plural = endpoint.plural;

	if (endpoint.response) {
		model = objectModel.models[endpoint.response];
		if (model) {
			singular = singular || model.singular || model.name;
			plural = plural || model.plural || model.name;
		}
	} else if (endpoint.model) {
		model = objectModel.models[endpoint.model];
		if (model) {
			singular = singular || model.singular || model.name;
			plural = plural || model.plural || model.name;
		}
	}

	var key = isArray ? plural : singular;
	if (!key) {
		return;
	}
	var i = key.lastIndexOf('/');
	if (i > 0) {
		key = key.substring(i + 1);
	}
	return pluralize(key.toLowerCase(), isArray ? null : 1) || 'result';
}

// Wrap the defined response in the ResponsModel structure.
function wrapResponses(objectModel, endpoint, responses, lookupDefinitions) {
	var wrapped = responses && {};
	Object.keys(responses || {}).forEach(function (status) {
		var response = responses[status];
		if (status === '200') {
			var schema = JSON.parse(JSON.stringify(ResponseModel));

			if (response.schema) {
				var isArray = response.schema.type === 'array';
				var key = getResponseKey(objectModel, endpoint, isArray);
				schema.required.push('key');
				schema.properties.key = {
					type: 'string',
					enum: [ key ]
				};
				if (isArray && response.schema.items.$ref) {
					if (lookupDefinitions.hasOwnProperty(response.schema.items.$ref)) {
						// swap #/definitions/testuser with schema:///packageName/testuser
						response.schema.items.$ref = lookupDefinitions[response.schema.items.$ref];
					}
				} else if (response.schema.$ref) {
					if (lookupDefinitions.hasOwnProperty(response.schema.$ref)) {
						// swap #/definitions/testuser with schema:///packageName/testuser
						response.schema.$ref = lookupDefinitions[response.schema.$ref];
					}
				}
				schema.properties[key] = JSON.parse(JSON.stringify(response.schema));
				schema.properties[key].description && delete schema.properties[key].description;
			}

			wrapped[status] = {
				description: response.description || endpoint.name + ' Response',
				schema: schema,
				headers: responses.headers,
				examples: responses.examples
			};
		} else {
			// Only wrapping success
			wrapped[status] = response;
		}
	});
	return wrapped;
}

function createPaths(objectModel, apiBuilder, lookupDefinitions) {
	const paths = {};
	const apis = objectModel.apis;
	const { apiPrefixSecurity } = apiBuilder.config.accessControl;

	for (var groupName in apis) {
		if (apis.hasOwnProperty(groupName)) {
			var api = apis[groupName];
			for (var i = 0; i < api.endpoints.length; i++) {
				var endpoint = api.endpoints[i],
					relativePath = translatePath(endpoint.path.split(apiBuilder.config.apiPrefix).pop()),
					def = paths[relativePath];
				if (endpoint.enabled === false) {
					continue;
				}
				if (!def) {
					paths[relativePath] = def = {};
				}
				var pathID = endpoint.method.toLowerCase();
				const addConsumes = [ 'post', 'put', 'patch', 'options' ].includes(pathID);
				def[pathID] = compact({
					description: endpoint.description,
					operationId: getOperationId(endpoint),
					deprecated: endpoint.deprecated,
					parameters: translateParameters(endpoint),
					responses: wrapResponses(objectModel, endpoint, endpoint.responses || api.responses || [], lookupDefinitions),
					tags: [ groupName ],
					produces: [
						'application/json',
						'application/xml',
						'text/yaml',
						'text/csv',
						'text/plain'
					],
					...addConsumes ? { consumes: [
						'application/json',
						'application/x-www-form-urlencoded',
						'multipart/form-data'
					] } : {}
				});

				if (!def[pathID].responses || Object.keys(def[pathID].responses).length === 0) {
					let responses = {
						default: {
							description: 'Response from Server',
							schema: {
								$ref: '#/definitions/ResponseModel'
							}
						}
					};
					if (apiPrefixSecurity !== 'none') {
						responses = {
							...defaultResponses,
							...responses
						};
					}
					def[pathID].responses = responses;
				} else if (apiPrefixSecurity !== 'none') {
					def[pathID].responses = {
						...defaultResponses,
						...def[pathID].responses
					};
				}
			}
		}
	}
	return {
		paths: paths
	};
}

function translatePath(path) {
	return path.replace(/:([^/]+)/g, '{$1}');
}

function translateParameters(endpoint) {
	var retVal = [],
		bodyParams;
	if (_.find(endpoint.parameters, { type: 'body' })) {
		bodyParams = {
			name: endpoint.nickname,
			in: 'body',
			description: endpoint.nickname + ' body',
			required: true,
			schema: {
				type: 'object',
				required: [],
				properties: {}
			}
		};
	}
	for (var name in endpoint.parameters) {
		if (endpoint.parameters.hasOwnProperty(name)) {
			var param = endpoint.parameters[name];
			switch (param.type) {
				case 'body':
					if (param.required) {
						bodyParams.schema.required.push(name);
					}
					bodyParams.schema.properties[name] = transformAPIBuilderProperty(param);
					break;
				default:
					if (param.type === 'form') {
						// We can't define both body and form params; there can be only one body per endpoint.
						if (bodyParams && param.required) {
							bodyParams.schema.required.push(name);
						}
						if (bodyParams) {
							bodyParams.schema.properties[name] = transformAPIBuilderProperty(param);
							break;
						}
					}
					// Force form parameters to be required (as required by the Swagger spec).
					if (param.type === 'path') {
						param.required = true;
					}
					var translated = {
						name: name,
						in: param.type,
						description: param.description,
						required: !!param.required,
						type: param.dataType || 'string'
					};
					// TODO: We need more information about the sub-types of objects and arrays.
					if (param.dataType === 'object') {
						translated.type = 'string';
					}
					if (param.dataType === 'array') {
						translated.items = { type: 'object' };
					}
					retVal.push(compact(translated));
					break;
			}
		}
	}
	if (bodyParams) {
		if (bodyParams.schema.required.length === 0) {
			delete bodyParams.schema.required;
		}
		retVal.push(bodyParams);
	}
	return retVal;
}

function transformAPIBuilderProperty(apibuilderProperty) {
	var dataType = apibuilderProperty.dataType || 'string';
	var swaggerProperty = {
		type: dataType,
		description: apibuilderProperty.description
	};
	switch (dataType) {
		case 'date':
			swaggerProperty.type = 'string';
			swaggerProperty.format = 'date';
			break;
		case 'array': {
			swaggerProperty.items = { type: 'string' };
			break;
		}
	}

	return swaggerProperty;
}

function getOperationId(endpoint) {
	var retVal = verbMap[endpoint.method] || endpoint.method.toLowerCase(),
		splits = endpoint.path.replace(/appc\./, '')
			.replace(/_[a-z]/ig, function (val) {
				return val[1].toUpperCase();
			})
			.slice(1).split('/');
	for (var i = 1; i < splits.length; i++) {
		var split = splits[i];
		if (split[0] === ':') {
			retVal += 'By' + split.slice(1).toUpperCase();
		} else if (split[0] !== undefined) {
			retVal += split[0].toUpperCase() + split.slice(1);
		}
	}
	return retVal;
}

function compact(obj) {
	return _.omitBy(obj, function (val, key) {
		if (Array.isArray(val)) {
			return val.length === 0;
		}
		if (_.isObject(val)) {
			obj[key] = compact(val);
			if (Object.keys(obj[key]).length === 0) {
				return false;
			}
		}

		return !val;
	});
}
