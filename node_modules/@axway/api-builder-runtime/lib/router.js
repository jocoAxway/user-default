/**
 * @class APIBuilder.Router
 */

const merge = require('lodash.merge');
/*
 * Handles routing requests through API Builder.
 * @param impl
 * @param config
 * @param apibuilder
 * @constructor
 */
function Router(impl, config, apibuilder) {

	impl && merge(this, impl);

	this.apibuilder = apibuilder;
	if (this.enabled === undefined) {
		this.enabled = true;
	}

	// incoming constructor config should overwrite implementation
	this.config = merge(impl && impl.config || {}, config);

	// if we provided a constructor in our impl, use it
	if (this.constructor && this.constructor !== Router && !this.constructor.super_) {
		this.constructor.call(this);
		Router.constructor.call(this);
	}

	if (!this.name) {
		throw new Error('required name missing on Router');
	}
}

/**
 * Returns a constructor function to generate a new Router endpoint.
 * Pass the constructor an APIBuilder configuration object and APIBuilder instance.
 * @static
 * @param {Dictionary<APIBuilder.Router>} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing name parameter or not called from a valid APIBuilder instance.
 */
Router.extend = function classExtend(impl) {
	/**
	 * Creates a Router.
	 */
	return function RouterConstructor(config, apibuilder) {
		if (!apibuilder) {
			throw new Error('invalid constructor. must be called with apibuilder instance as 2nd argument');
		}
		return new Router(impl, config, apibuilder);
	};
};

/**
 * Returns a constructor function to generate a new Router endpoint.
 * Pass the constructor an APIBuilder configuration object and APIBuilder instance.
 * @param {Dictionary<APIBuilder.Router>} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing name parameter.
 */
Router.prototype.extend = function instanceExtend(impl) {
	return Router.extend(merge(this, impl));
};

/**
 * Binds this route to the app instance.
 * @param {Object} app App instance.
 * @throws {Error} Missing app instance.
 */
Router.prototype.bind = function (app) {
	if (!app) {
		throw new Error('app required for bind');
	}
	var method = (this.method || 'GET').toLowerCase();
	app.logger.debug('binding route (' + method + ') ' + this.path);
	this.route = app[method](this.path, this.getMiddleware());
};

/**
 * Removes the route from the APIBuilder instance.
 * @param {Object} apibuilder APIBuilder instance.
 * @param {Function} callback Callback passed an Error object (or null if successful) and the removed route.
 */
Router.prototype.remove = function (apibuilder, callback) {
	apibuilder.routes = apibuilder.routes.filter(route => route !== this);
	// remove the routing entry from express
	var array = apibuilder.app._router.stack;
	for (var c = 0; c < array.length; c++) {
		var entry = array[c];
		if (entry.route && entry.route.path === this.path) {
			var stack = entry.route.stack;
			for (var i = 0; i < stack.length; i++) {
				if (stack[i].method.toLowerCase() === this.method.toLowerCase()) {
					stack.splice(i, 1);
					break;
				}
			}
			// no more routes, remove it
			if (stack.length === 0) {
				array.splice(c, 1);
			}
			break;
		}
	}
	callback && callback(null, this);
};

/**
 * Reloads the route. Call this function if changes were made to the route.
 * @param {Object} apibuilder APIBuilder instance.
 * @param {Function} callback Callback passed an Error object (or null if successful) and the reloaded route.
 */
Router.prototype.reload = function (apibuilder, callback) {
	if (this.filename) {
		var fs = require('fs');
		this.timestamp = fs.statSync(this.filename).mtime;
		var old = this;
		// remove the route
		this.remove(apibuilder, function () {
			// remove it from the apibuilder
			apibuilder.loadRoute(old.filename, function (err, route) {
				callback && callback(err, old, route);
			});
		});
	} else {
		callback && callback(null, this);
	}
};

/**
 * Gets the middleware block that provides access to the
 * route's action implementation.
 * Pass the function returned by this method a request object,
 * response object, and the function to call next.
 * @returns {Function}
 */
Router.prototype.getMiddleware = function getMiddleware() {
	var self = this;
	/**
	 * Handles the middleware request, making sure API Builder' security measures are applied and we are set up for handling
	 * the request.
	 */
	function routeMiddleware(req, resp, next) {
		try {
			req.params = merge(req.params, req._params);
			var action = self.action || self.execute; // allow both
			if (action) {
				if (action.length === 3) {
					var _render = resp.render,
						_rendered = false;
					/**
					 * do implicit or explicit handling of next in render
					 */
					resp.render = function (name, args, cb) {
						if (!_rendered) {
							_rendered = true;
							if (arguments.length > 2 && cb !== next) {
								// we need to render and pass the html back to the cb.
								_render.call(resp, name, args, cb);
							} else {
								// otherwise, we need to render AND send the html.
								_render.call(resp, name, args, function (err, html) {
									if (err) {
										next(err);
									} else {
										if (html) {
											resp.send(html);
										}
										next();
									}
								});
							}
						}
					};
					return action(req, resp, next);
				} else {
					action(req, resp);
					return next();
				}
			} else {
				return next();
			}
		} catch (e) {
			next(e);
		}
	}
	routeMiddleware._name = 'router:' + this.name;
	routeMiddleware.filename = this.filename;
	routeMiddleware.description = this.description;
	return routeMiddleware;
};

module.exports = Router;
