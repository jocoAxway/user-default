/* r.e. setImmediate:
	If anything inside a promise callback is thrown, the promise will automatically be rejected.
	We don't want it to happen in these cases - we want the uncaughtException handler to catch these.
	If we don't use setImmediate to take the callback out of the grasp of the promise, then we will en
	up with UnhandledPromiseRejectionWarnings.
	Don't mix and match promise/callback syntax, kids!
	see:
	https://github.com/nodejs/node/issues/9242
	https://github.com/stevemao/promise-to-callback/blob/master/index.js#L12
 */

/**
 * @class APIBuilder
 */
exports = module.exports = APIBuilder;
var consoleLog = console.error.bind(console);
var pendingRequests = 0;
var lastGCCheck = Date.now();
var stopping = false;

var SWAGGER_EXTENSION = /^x-/;

// set the name of the node process
process.title = 'API Builder';

var express = require('express'),
	_ = require('lodash'),
	events = require('events'),
	fs = require('fs-extra'),
	path = require('path'),
	URL = require('url'),
	util = require('util'),
	async = require('async'),
	walkSync = require('walk-sync'),
	debug = require('debug')('apibuilder'),
	pkg = require('../package.json'),
	Metadata = require('./metadata'),
	Logger = require('./logger'),
	memwatch,
	Loader = require('./loader'),
	Middleware = require('./middleware'),
	Block = require('./block'),
	Router = require('./router'),
	FlowManager = null,
	FlowNode = null,
	registerFlowCoreNodeHandlers = null,
	unregisterFlowCoreNodeHandlers = null,
	APIBuilderFlowInvoke = null,
	registerAPIBuilderNodeHandlers = null,
	unregisterAPIBuilderNodeHandlers = null,
	CodeblockMetadata = null,
	Endpoints = null,
	CredentialManager,
	registerAuthorizationNodeHandlers,
	unregisterAuthorizationNodeHandlers,
	API = require('./api'),
	orm = require('arrow-orm'),
	uuid = require('uuid-v4'),
	paths = require('./paths'),
	plugins = require('./plugins'),
	requireUncached = require('require-uncached'),
	pluralize = require('pluralize'),
	chalk = require('chalk'),
	Authentication = require('./authentication'),
	getAccessControlMiddleware = require('./authentication/access-control'),
	Swagger = require('./swagger'),
	connectors = {},
	globalAPIBuilder,
	inGetConnector,
	pendingModels,
	loadedModelDirs = [],
	instantiations = [],
	servers = [],
	schemas = null,
	flagsCfg = require('./flags/flags.json'),
	apiBuilderConfig = require('@axway/api-builder-config');

// Intentionally leave this as separate const declaration
// The starting point for code evolution ...
const CompositeFactory = require('./composite');
const utils = require('./utils');

try {
	memwatch = require('memwatch-next');
} catch (err) {
	// appc-memwatch isn't installed. Carry on anyway.
}

util.inherits(APIBuilder, events.EventEmitter);

// allow people to reference the built-in debug module
// TODO: Deprecate me?
APIBuilder.debug = debug;

// merge in orm into our APIBuilder
for (var key in orm) {
	if (orm.hasOwnProperty(key)) {
		APIBuilder[key] = orm[key];
		orm[key].APIBuilder = APIBuilder;
	}
}

APIBuilder.API = API;
APIBuilder.Block = Block;
APIBuilder.Formation = require('./formatters');
APIBuilder.Loader = Loader;
APIBuilder.Logger = Logger;
APIBuilder.Metadata = Metadata;
APIBuilder.Middleware = Middleware;
APIBuilder.ORM = orm;
APIBuilder.Router = Router;
APIBuilder.Version = pkg.version;
APIBuilder.Release = (pkg['api-builder'] && pkg['api-builder'].release) || APIBuilder.Version;

/**
 * Setup known deprecations.  Use `registerDeprecationUse` to mark deprecated features so be
 * logged on startup.
 * @param {object} apibuilder - The APIBuilder instance.
 */
function setupDeprecations(apibuilder) {
	apibuilder.deprecations = requireUncached('../deprecations.json');

	apibuilder.registerDeprecationUse = (id) => {
		apibuilder.deprecations.features[id].active = true;
	};
}

/**
 * Handle legacy configuration, upgrade and mark deprecated feature use.
 * @param {object} apibuilder - The APIBuilder instance.
 */
function handleLegacyConfig(apibuilder) {
	const { config } = apibuilder;

	if (config.admin.apiDocPrefix !== undefined) {
		apibuilder.registerDeprecationUse('apiDocPrefix');
	}

	if (config.admin.disableAPIDoc !== undefined) {
		apibuilder.registerDeprecationUse('disableAPIDoc');
	}

	if (config.APIKeyAuthType !== undefined
		|| config.APIKeyAuthPlugin !== undefined) {
		apibuilder.registerDeprecationUse('perURLAuthentication');
	}

	// move legacy apidoc config from admin section to apidoc section or use default
	if (config.apidoc.prefix === undefined) {
		config.apidoc.prefix = config.admin.apiDocPrefix || '/apidoc';
	}
	if (config.apidoc.disabled === undefined) {
		config.apidoc.disabled = !!config.admin.disableAPIDoc;
	}
	// "Kobe" release made API Builder secure by default.  If accessControl is not defined, then
	// move legacy config and configure it to be backwardly compatible.  It looks kinda scary
	// setting / to public.
	if (!config.accessControl) {
		config.accessControl = {
			apiPrefixSecurity: config.APIKeyAuthType || 'basic',
			plugin: config.APIKeyAuthPlugin,
			public: [ '/' ]
		};
		if (!config.APIKeyAuthType) {
			// if not defined, use 'none'
			config.accessControl.apiPrefixSecurity = 'none';
		}

		delete config.APIKeyAuthType;
		delete config.APIKeyAuthPlugin;
	}
	// assign the new value back for backwards compatability
	config.admin.apiDocPrefix = config.apidoc.prefix;
	config.admin.disableAPIDoc = config.apidoc.disabled;
}

/**
 * API Builder constructor function.
 * It produces API Builder instances and in cases loadOnly is false spin up express application/s
 *
 * @param {*} config the initial configuration file the service is started
 * @param {*} loadOnly if true does not spin up express application
 */
function APIBuilder(config, loadOnly) {
	this.initialConfig = config !== undefined ? JSON.parse(JSON.stringify(config)) : null;
	if (instantiations !== undefined) {
		instantiations.push(this);
	}
	this.apibuilderPlugins = {};
	this.config = new Loader(config && config.dir, config);

	// set defaults
	this.port = this.config.port || 8080;
	this.config.ssl && (this.config.ssl.port = this.config.ssl.port || 8443);
	this.config.apiPrefix = this.config.apiPrefix || '/api';
	this.config.admin = this.config.admin || {};
	this.config.apidoc = this.config.apidoc || { overrides: {} };
	this.config.apidoc.overrides = this.config.apidoc.overrides || {};

	// Set known deprecation info in one place.  This will be used to mark deprecated
	// features on startup.
	setupDeprecations(this);

	// Upgrade config and register deprecation messages
	handleLegacyConfig(this);

	// Run validation on the config
	validateConfig(this.config);

	// Infer the need of web resource allocation like static web and renderers
	const webDirectory = this.config.dir && path.join(this.config.dir, 'web');
	const publicDirectory = webDirectory && path.join(webDirectory, 'public');
	const routesDirectory = webDirectory && path.join(webDirectory, 'routes');
	// configWeb is internal prop that holds flags to specify
	// the need to initialize resources related with web app capabilities
	// like static server and renderers.
	// In the future this might be turned into official configuration strategy in app config
	this.configWeb = {
		needStaticServer: publicDirectory && fs.existsSync(publicDirectory),
		needRenderers: routesDirectory && fs.existsSync(routesDirectory)
	};
	if (this.configWeb.needRenderers) {
		this.registerDeprecationUse('apiBuilderWeb');
	}
	// end of Infer logic

	this.loadOnly = loadOnly;
	this.ignoreDuplicateModels = !!this.config.ignoreDuplicateModels;

	if (!globalAPIBuilder) {
		globalAPIBuilder = this;
		// since the continuation listeners potentially has a ton of listeners on startup
		globalAPIBuilder.setMaxListeners(Number.MAX_VALUE);
	}

	// Set the logger.  Allow an instance of logger to be passed in.
	this.logger = (config && config.logger) || Logger.createLogger({
		level: this.config.logLevel || 'NONE'
	});

	// Initialize the base url
	let baseurl = this.config.baseurl || 'http://localhost';
	baseurl = `${baseurl}${baseurl.endsWith(':') ? '' : ':'}`;
	if (baseurl.toLowerCase().startsWith('https://')) {
		baseurl = `${baseurl}${this.config.ssl.port}`;
	} else {
		baseurl = `${baseurl}${this.port}`;
	}

	// add the flags
	apiBuilderConfig.setLogger(this.logger);
	const flags = Object.entries(flagsCfg)
		.reduce((col, [ key, value ]) => {
			col[key] = {
				...value,
				enabled: (this.config && this.config.flags && this.config.flags.hasOwnProperty(key)) ? this.config.flags[key] : value.default
			};
			return col;
		}, {});
	apiBuilderConfig.flags = flags;

	// Require these after setting the flags as the flags may affect their interfaces
	const AxwayFlow = require('axway-flow');
	FlowManager = AxwayFlow.FlowManager;
	FlowNode = AxwayFlow.FlowNode;
	registerFlowCoreNodeHandlers = AxwayFlow.register;
	unregisterFlowCoreNodeHandlers = AxwayFlow.unregister;
	schemas = require('axway-schema');
	APIBuilderFlowInvoke = require('@axway/api-builder-flow-invoke');
	registerAPIBuilderNodeHandlers = APIBuilderFlowInvoke.register;
	unregisterAPIBuilderNodeHandlers = APIBuilderFlowInvoke.unregister;
	CodeblockMetadata = APIBuilderFlowInvoke.CodeblockMetadata;
	Endpoints = require('arrow-endpoint');

	// Initialize the Credential Manager
	initCredentialManager(baseurl, this);

	// this is the default path (inside if). we use this
	// as a way to be able to load up API Builder but without
	// creating the server infrastructure. this is useful for
	// being able to programatically load models, connectors, etc
	if (!loadOnly) {

		var self = this;
		this.express = express;
		var server = this.app = express();

		var healthCheckAPI = this.config.healthCheckAPI;
		var healthCheckError;
		if (healthCheckAPI) {
			try {
				healthCheckAPI = require(path.resolve(process.cwd(), healthCheckAPI));
			} catch (e) {
				healthCheckError = e;
			}
		}

		// handle any API Runtime Services health checks -- allow the user to specify their own
		// plugin or we'll provide a basic one that simply returns success if we are reachable
		// and not in shutdown phase
		server.get('/apibuilderPing.json', healthCheckAPI || function (req, resp) {
			return resp.json({ success: !self.shuttingdown });
		});

		if (healthCheckError) {
			this.logger.trace(healthCheckError.stack);
			this.logger.error('error loading health check plugin', healthCheckAPI, healthCheckError);
		}

		// add graceful shutdown middleware which will send 503 responses to
		// any incoming connection requests while we're in shutdown mode. any
		// front end load balancer (like API Runtime Services) should correctly
		server.use(function (req, resp, next) {
			if (self.shuttingdown) {
				resp.shouldKeepAlive = false;
				resp.set('Connection', 'close');
				resp.set('Cache-Control', 'no-cache, no-store, max-age=0');
				resp.set('Pragma', 'no-cache');
				resp.status(503);
				resp.end('Server is shutting down');
			} else {
				next();
			}
		});

		// add the request-id helper
		express.request.getId = function () {
			if (!this._reqid) {
				this._reqid = uuid();
			}
			return this._reqid;
		};

		process.removeListener('unhandledRejection', function () {
			process.on('unhandledRejection', function (reason, p) {
				this.logger.error('Unhandled rejection at: Promise', p, 'reason:', reason);
			}.bind(this));
		}.bind(this));

		addLocals(this, this.app, baseurl);

		// bind a logger to the server itself
		server.logger = this.logger;

		var appPkg = path.join(config && config.dir || process.cwd(), 'package.json');
		if (fs.existsSync(appPkg)) {
			appPkg = require(appPkg);
			this.logger.info(chalk.blue.bold(`API Builder/${APIBuilder.Release} (${APIBuilder.Version})`) + ' ' + chalk.yellow(`${appPkg.name}/${appPkg.version}`));
		} else {
			appPkg = {};
			// fallback if we can't find package.json for app
			this.logger.info(chalk.blue.bold(`API Builder/${APIBuilder.Release} (${APIBuilder.Version})`));
		}
		this.projectName = appPkg.name ? path.basename(appPkg.name) : 'apibuilder-app';

		this.metadata = {
			name: appPkg.name,
			version: appPkg.version,
			description: appPkg.description,
			author: appPkg.author,
			license: appPkg.license
		};

		if (this.config.apikey) {
			this.logger.info('APIKey is:', chalk.gray(this.config.apikey));
		}

		var sessionConfig = this.config && this.config.session || {};

		server.use(function (req, resp, next) {
			req.pendingReqCount = ++pendingRequests;
			req.server = self;
			if (!self.config.disableServerBanner) {
				resp.set('Server', 'API Builder/' + pkg.version);
			}
			resp.set('Request-Id', req.getId());
			resp.locals['request-id'] = req.getId();
			req.logger = resp.logger = req.log = req.log || self.logger.scope(req);
			next();
		});

		// This should always be at the top before anything else but after setting up the logger
		server.use(startRequestMiddleware);

		// setup static route to web/public.  this is placed before the authenticated api/routes,
		// otherwise static routes will not work.  e.g. the UI requests /index.html which routes
		// to ./web/public.
		if (this.configWeb.needStaticServer) {
			// Add CORs headers for the Static Resources
			server.use(async (req, resp, next) => {
				// A list of the allowed methods for the static resources
				const ALLOWED_STATIC_METHODS = [ 'GET' ];

				const corsConfig = self.config.cors || {};

				if (isCORSReq(req, corsConfig)) {
					const isStatic = await isStaticResource(publicDirectory, req.path).then((staticResource) => {
						return new Promise((resolve) => {
							if (staticResource) {
								let corsConf = _.clone(corsConfig);

								// Add the allowed methods for the CORS config
								corsConf.defMethods = ALLOWED_STATIC_METHODS;
								addCORsHeaders(corsConf, req, resp);

								resolve(true);
							}
							resolve(false);
						});
					});

					if (isStatic && isPreflight(req)) {
						return resp.status(200).end();
					}
				}

				next();
			});

			setupStaticPublicMiddleware(server, this.config.dir);
		}

		// create the authentication strategy and middleware.
		setupAuthenticationStrategy(this, server);

		// create the generic express middleware.
		// FIXME: the constructor for this is a bit of a mess, but changing the interface to
		// to make it simpler is not in scope.
		this.middleware = new Middleware(server, this.config.dir, sessionConfig, {
			...this.config,
			// The `enableStaticPublicDirectory` is an internal configuration option to allow the
			// middleware to load the public static routes, unless it is disabled.  It is disabled
			// here because it is loaded above.
			enableStaticPublicDirectory: false,

			// If false this flag allows skipping the renderers loading
			enableRenderers: this.configWeb.needRenderers
		});

		server.on('after', endRequestMiddleware);

		// Add CORs headers
		server.use(function (req, resp, next) {
			if (isCORSReq(req, self.config.cors)) {
				var apis;
				const requestPath = req.path;

				if ((requestPath === self.apidocPath) || (requestPath === self.apidocPathLegacy)) {
					// Setup CORS on API doc
					apis = [{
						method: 'GET'
					}];
				} else {
					// Setup CORS on API urls.
					apis = API.getAPIsForPath(requestPath) || [];
				}

				if (apis.length) {
					var corsConf = _.clone(self.config.cors || {}),
						preflight = isPreflight(req),
						methods = {},
						headers = {};

					// extract related data from the api object (methods, headers etc)
					if (preflight) {
						// CORS should be enabled for our logs XHR
						apis.forEach(function (api) {
							methods[api.method.toUpperCase()] = undefined;
						});
					} else {
						apis.forEach(function (api) {
							// extract headers from the response definition
							api.responses && Object.keys(api.responses).forEach(function (response) {
								var hdrs = api.responses[response].headers;
								hdrs && Object.keys(hdrs).forEach(function (header) {
									// storing in an object to avoid dedupe cost
									headers[header] = undefined;
								});
							});
						});
					}

					// insert extracted data into the cors configs to be used by the addCORsHeaders
					corsConf.defMethods = Object.keys(methods);
					corsConf.defHeaders = Object.keys(headers);
					addCORsHeaders(corsConf, req, resp);
					if (preflight) {
						return resp.status(200).end();
					}
				}
			}
			next();
		});

		try {
			// load up admin if enabled
			if (this.config.admin && this.config.admin.enabled) {
				// eslint-disable-next-line import/no-unresolved
				const Admin = require('@axway/api-builder-admin');
				this.admin = new Admin();

				// Authorization callbacks only registered if we have Admin console for now.
				server.get(this.config.authorization.callback, CredentialManager.middleware);
			} else {
				// admin is completely disabled
				this.logger.info('API Builder Console is disabled');
			}
		} catch (e) {
			// Ignore error if admin cannot be loaded
		}

		this.logger.trace('creating APIBuilder server instance on port %d', this.port);
	} else {
		this.pkg = pkg;
	}

	if (this.config.printEnvVars) {
		this.logger.trace(process.env);
	}

	// pass the config to components but remove some parts
	const { name, port, admin, session, apikey } = this.config;
	this.objConfig = { name, port, admin, session, apikey };

	schemas.setLogger(this.logger);

	this.flowManager = new FlowManager(this.logger, CredentialManager);
	this.models = {};
	this.apis = [];
	this.blocks = {};
	this.registeredNodes = [];
	this.routes = [];
	this.codeblocks = {};
	this.endpoints = {};
	this.endpointSwaggers = {};
	this.addCORsHeaders = addCORsHeaders;
	this.isPreflight = isPreflight;
	this.isCORSReq = isCORSReq;

	if (!loadOnly) {
		this.on('reload', this.reload);
	}

	loadInternalConnectors();

	// start loading our server
	// TODO: try and control this with server.start instead so that it can call a callback
	process.nextTick(this.load.bind(this));
}

function validateConfig(config) {
	// validate apidoc overrides configuration
	const apidocOverrides = config.apidoc.overrides;
	// Verify that scheme contains 0 or 1 of http, https, ws, wss
	const schemes = apidocOverrides.schemes;
	if (schemes !== undefined) {
		let invalid = !Array.isArray(schemes) || !schemes.length;
		if (!invalid) {
			const valid = [ 'http', 'https', 'ws', 'wss' ];
			// remove duplicates and filter out invalid schemes
			const filtered = [ ...new Set(schemes) ]
				.filter(s => valid.includes(s));
			// if the length is different then there were some invalid values
			if (filtered.length !== schemes.length) {
				invalid = true;
			}
		}
		if (invalid) {
			throw new Error('apidoc.overrides.schemes configuration is invald. Value bust be an array containing 0 or 1 of "http", "https", "ws", "wss"');
		}
	}
	const host = apidocOverrides.host;
	if (host !== undefined && typeof host !== 'string') {
		throw new Error('apidoc.overrides.host configuration is invalid. Value must be a string');
	}
	const basePath = apidocOverrides.basePath;
	if (basePath !== undefined && basePath !== null && (typeof basePath !== 'string' || !(basePath[0] === '/'))) {
		throw new Error('apidoc.overrides.basePath configuration is invalid. Value must be a string and start with a leading /, or null to specify no basePath');
	}
	const proxyUri = config.proxy;
	if (proxyUri !== undefined && typeof proxyUri !== 'string') {
		throw new Error('proxy configuration is invalid. Value must be a string');
	}
	const apiPrefix = config.apiPrefix;
	if (typeof apiPrefix !== 'string' || !(apiPrefix[0] === '/')) {
		throw new Error('apiPrefix configuration is invalid. Value must be a string and start with a leading "/".');
	}

	if (config.baseurl && config.baseurl.toLowerCase().startsWith('https://') && !config.ssl) {
		throw new Error(`baseurl in the config is set to the secure url ${config.baseurl}. \
However SSL has not been enabled on this service. For details on configuring SSL see https://docs.axway.com/bundle/API_Builder_4x_allOS_en/page/enable_a_secure_https_listener.html`);
	}
	if (!config.accessControl.hasOwnProperty('public')) {
		throw new Error('accessControl.public is required.  Value must be an empty array, or array of path strings prefixed with a leading "/"');
	}
}

/**
 * Initialize Credentila Manager and registers all credentials in API Builder.
 * The function is also responsible to preserve valid authorizations across reloads if they have not been touched.
 *
 * @param {*} baseurl the baseurl.
 * @param {*} apiBuilder API Builder instance.
 */
function initCredentialManager(baseurl, apiBuilder) {
	apiBuilder.config.authorization = apiBuilder.config.authorization || {};
	apiBuilder.config.authorization.callback = apiBuilder.config.authorization.callback || '/auth/callback';
	const FlowAuth = require('@axway/axway-flow-authorization');
	CredentialManager = FlowAuth.CredentialManager;
	registerAuthorizationNodeHandlers = FlowAuth.register;
	unregisterAuthorizationNodeHandlers = FlowAuth.unregister;
	CredentialManager.setLogger(apiBuilder.logger);

	CredentialManager.config = {
		baseurl,
		...apiBuilder.config.authorization,
		credentials: mergeCredentials(baseurl, apiBuilder.config.authorization.callback)
	};

	/**
	 * Responsible to update the list with managed by Credential Manager credentials.
	 * baseurl and callback are used to calculate redirect_uri used by oauth2 authorization.
	 *
	 * On system restart the Credential Manager must manage the updated list with credentials
	 * - deleted credentials must not be managed
	 * - newly added credentials must be managed
	 * - modified credentials should be invalidated
	 * - not modified credentials should be preserved
	 *
	 * There are two types of credential attributes - manually managed and dynamically managed by CM.
	 * The algorithm here decides how to reset oauth2 credentials when checking manually managed attributes for changes.
	 *
	 * @param {*} baseurl service base url
	 * @param {*} callback service callback url
	 * @returns {array} the new list with credentails that must be managed by Credential Manager
	 */
	function mergeCredentials(baseurl, callback) {
		const previouslyManagedCredentials = CredentialManager.getCredentialConfigs() || {};
		const newCredentials = apiBuilder.config.authorization.credentials || {};
		if (Object.keys(previouslyManagedCredentials).length === 0 || Object.keys(newCredentials).length === 0) {
			// No merge required.
			return newCredentials;
		}

		// Delete any removed credentials
		Object.keys(previouslyManagedCredentials)
			.filter(name => !newCredentials.hasOwnProperty(name))
			.forEach(name => CredentialManager.removeCredential(name));

		// Merge the old details into the new credential.
		Object.keys(newCredentials)
			// Filter newly added
			.filter(name => previouslyManagedCredentials.hasOwnProperty(name))
			// Leave only oauth2 since they are the only refreshable at the moment
			.filter(name => newCredentials[name].type === 'oauth2')
			// Merge
			.forEach(name => {
				const providedProps = [ 'authentication_url', 'client_id', 'client_secret', 'flow', 'token_url' ];
				const existing = previouslyManagedCredentials[name];
				const newCred = newCredentials[name];
				const newRedirectUri = newCred.redirect_uri || baseurl + callback;
				if (providedProps.every(key => newCred[key] === existing[key]) && newRedirectUri === existing.redirect_uri) {
					// If the provided props and redirect_uri stays the same we keep the previously claculated managed dependencies
					newCred.expiry = existing.expiry;
					newCred.access_token = existing.access_token;
					newCred.refresh_token = existing.refresh_token;
					newCred.scope = existing.scope;
				}
			});

		return newCredentials;
	}
}

/**
 * This is invoked only when constructing APIBuilder instance.
 * Internal connectors are created once and reloaded on APIBuilder restart.
 * getConnector will always find these already instantiated.
 */
function loadInternalConnectors() {
	// Load memory connector
	APIBuilder.registerConnector(new APIBuilder.MemoryConnector());

	// Load composite connector
	APIBuilder.registerConnector(CompositeFactory(APIBuilder));
}

// TODO: Deprecate me?
function addLocals(server, app, baseurl) {
	app.locals.appc_external_url = server.baseurl = baseurl;
	app.locals.appc_external_apidoc_path_legacy = server.apidocPathLegacy = server.config.apidoc.prefix + '/docs.json';
	app.locals.appc_external_apidoc_path = server.apidocPath = server.config.apidoc.prefix + '/swagger.json';
	app.locals.appc_external_apidoc_url = server.apidocurl = app.locals.appc_external_url + app.locals.appc_external_apidoc_path;
	server.logger.trace('setting app locals', app.locals);
}

function isCORSReq(req, corsConfig) {
	var origin = req.headers.origin || '',
		host = req.headers.host || '',
		originHost = URL.parse(origin, false).host,
		confOrigin = corsConfig && corsConfig['Access-Control-Allow-Origin'];

	// reset the lastIndex of the RegExp (else wont work for the next request)
	confOrigin && confOrigin.lastIndex && (confOrigin.lastIndex = 0);

	// first check if its a valid CORS request by checking if the origin contains the host.
	// Then check if the origin is allowed or not based on the configuration (The match covers
	// *, single or space separated values, array and regex)
	return origin && originHost !== host
		&& (confOrigin === '*'
		|| (typeof confOrigin === 'string' && confOrigin.split(/\s* /).indexOf(origin) !== -1)
		|| (confOrigin instanceof Array && confOrigin.indexOf(origin) !== -1)
		|| (confOrigin instanceof RegExp && confOrigin.test(origin)));
}

function isPreflight(req) {
	return req.method === 'OPTIONS' && !!req.headers['access-control-request-method'];
}

/* List of default headers the server accepts. Can be overridden in config using:
	cors: {
		'Access-Control-Allow-Headers': ['foo-header', 'bar-header']
	}
*/
var DEFAULT_SAFE_REQUEST_HEADERS = [
	'x-requested-with',
	'accept',
	'origin',
	'content-type',
	'authorization',
	'x-titanium-id',
	'x-native-id'
];

/* List of default headers the server whitelists that browsers are allowed to access.
	Can be overridden in config using:
	cors: {
		'Access-Control-Expose-Headers': ['foo-header', 'bar-header']
	}

	NOTE: The 6 headers are always exposed by default are:
	Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma
*/
var DEFAULT_SAFE_EXPOSE_HEADERS = [
	'request-id',
	'response-time'
];

/**
 * Adds required CORS headers to the response (assuming its a valid and allowed CORS request)
 * Implementation is based on https://www.w3.org/TR/2014/REC-cors-20140116/
 * @param {object} config - apibuilder configuration.cors (support 2 additional fields,
 *                          1) defMethods: array of methods found in the API definition
 *                          2) defHeaders: array of headers found in the API definition
 * @param {Object} req - Express' request object
 * @param {object} resp - Express' response object
 * @returns
 */
function addCORsHeaders(config, req, resp) {
	var corsConfig = config || {},
		confCredentials = corsConfig['Access-Control-Allow-Credentials'],
		origin = req.headers.origin;

	// convert single or comma seperated values to an array (lower case)
	function convertToArray(value) {
		if (Array.isArray(value)) {
			return value.map(function (val) {
				return val.toLowerCase();
			});
		} else if (typeof value === 'string' || value instanceof String) {
			return value.trim().split(/\s*,\s*/).map(function (val) {
				return val.toLowerCase();
			});
		} else {
			return [];
		}
	}

	resp.setHeader('Access-Control-Allow-Origin', origin);
	resp.setHeader('vary', 'Origin');

	if (isPreflight(req)) {
		var confMethods = convertToArray(corsConfig['Access-Control-Allow-Methods']),
			safeHeaders = corsConfig.safeHeaders || DEFAULT_SAFE_REQUEST_HEADERS,
			confHeaders = convertToArray(corsConfig['Access-Control-Allow-Headers']),
			allowHeaders = confHeaders.length ? confHeaders : safeHeaders,
			defMethods = corsConfig.defMethods || [],
			allowMethods = [];

		// calculate the allowed methods based on bound methods and the ones in the config
		confMethods = confMethods.map(function (val) {
			return val.toUpperCase();
		});
		allowMethods = confMethods.length ? _.intersection(defMethods, confMethods) : defMethods;
		// set allow-methods and allow-headers(all supported headers) value
		resp.setHeader('Access-Control-Allow-Methods', allowMethods.join(', '));
		resp.setHeader('Access-Control-Allow-Headers', allowHeaders.join(', '));
	} else {
		// if its an actual request
		// populate the value of expose-headers from configs, definitions and DEFAULT_SAFE_EXPOSE_HEADERS
		var confExpose = convertToArray(corsConfig['Access-Control-Expose-Headers']),
			defHeaders = convertToArray(corsConfig.defHeaders),
			exposeHeaders = _.uniq(confExpose.concat(DEFAULT_SAFE_EXPOSE_HEADERS, defHeaders));
		resp.setHeader('Access-Control-Expose-Headers', exposeHeaders.join(', '));
	}
	confCredentials && resp.setHeader('Access-Control-Allow-Credentials', confCredentials);
}

/**
 * Returns the middleware instance containing the Express app instance.
 * @returns {APIBuilder.Middleware}
 */
APIBuilder.prototype.getMiddleware = function () {
	return this.middleware;
};

/**
 * Tracks all instantiations.
 */
APIBuilder.trackInstantiations = function () {
	instantiations = [];
};

/*
 * used for testing only
 *
 * @private
 */
APIBuilder.resetGlobal = function () {
	if (instantiations !== undefined) {
		instantiations.forEach(function (apibuilder) {
			if (apibuilder.logger && apibuilder.logger.requestLogger && apibuilder.logger.requestLogger.streams) {
				apibuilder.logger.requestLogger.streams.forEach(function (f) {
					f.stream.end();
				});
			}
		});
		instantiations = [];
	}
	APIBuilder.ORM.MemoryConnector.resetPrimaryKeys();
	connectors = {};
	loadedModelDirs = [];
	globalAPIBuilder = null;
	pendingRequests = 0;
};

/**
 * Gets a reference to the first instantiated APIBuilder server.
 * @returns {APIBuilder}
 */
APIBuilder.getGlobal = function () {
	return globalAPIBuilder;
};

/*
 * start a data connector and call next when completed
 */
function startDataconnector(instance, connector, next) {
	if (connector.connect && !instance.loadOnly && !connector.started) {
		// if the connector is disabled, don't start it
		if (connector.enabled === false || (connector.config && connector.config.enabled === false)) {
			if (!connector.enableWarning) {
				// only warn once
				instance.logger.info(chalk.green('connector/' + connector.name) + ' is disabled in config. will not start it and it won\'t be available');
			}
			connector.enabled = false;
			connector.enableWarning = true;
			return next();
		}
		instance.logger.info('Starting ' + chalk.green('connector/' + connector.name + (connector.version ? ('@' + connector.version) : '')));
		connector.connect(function (err) {
			if (err) {
				err = new Error('Error loading connector/' + connector.name + '. ' + (err.message || err));
				return next(err);
			}
			connector.started = true;
			connector.enabled = true;
			instance.logger.info('Started ' + chalk.green('connector/' + connector.name));
			next && next();
		});
	} else {
		next && next();
	}
}

/**
 * Returns the full path of the component directory.
 * @param {String} type Component type, that is, `api`, `block`, `model`, `route`, `node`.
 * @returns String
 */
APIBuilder.prototype.getComponentDir = function getComponentDir(type) {
	if (type === 'route') {
		// these live in a little bit of a different location
		return path.resolve(path.join(this.config.dir || process.cwd(), 'web', 'routes'));
	} else {
		return path.resolve(path.join(this.config.dir || process.cwd(), `${type}s`));
	}
};

/**
 * Loads an API from an API file. The file must exist and be a valid API. No error checking is performed.
 * @param {String} fn Filename of the API.
 * @param {Function} [cb] Callback passed an Error object (or null if successful), the API instance, and the API class.
 */
APIBuilder.prototype.loadApi = function loadAPI(fn, cb) {
	try {
		this.logger.debug('attempting to load API', fn);
		let APIClass = paths.requireComponent(fn, true);
		if (!APIClass) {
			this.logger.trace(APIClass);
			throw new Error('Error loading api at ' + fn);
		}
		if (!_.isFunction(APIClass)) {
			this.logger.trace(APIClass);
			throw new Error('Error loading api at ' + fn + '. this module did not export a Class');
		}
		let api = new APIClass(this.objConfig, this, fn);
		this.apis.push(api);
		this.triggerReloadedIfRequired(false, [{ fn: this.app }]);
		cb && setImmediate(() => cb(null, api, APIClass));
	} catch (ex) {
		if (cb) {
			return cb(ex);
		} else {
			throw ex;
		}
	}
};

/**
 * Loads a Model from a Model file. The file must exist and be a valid Model. No error checking is performed.
 * @param {String} fn Filename of the Model.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Model class.
 */
APIBuilder.prototype.loadModel = function loadModel(fn, cb) {
	try {
		this.logger.debug('attempting to load model', fn);
		let Model = paths.requireComponent(fn, true);
		if (!Model) {
			this.logger.trace(Model);
			throw new Error('Error loading model at ' + fn);
		}
		if (!_.isObject(Model)) {
			this.logger.trace(Model);
			throw new Error('Error loading model at ' + fn + '. this module did not load properly');
		}
		if (!_.isFunction(Model.create) && !Model.loadingModels) {
			this.logger.trace(Model);
			throw new Error('Error loading model at ' + fn + '. this module did not export a Class');
		}
		if (!Model.loadingModels && (!_.isObject(Model.fields) || !Object.keys(Model.fields).length)) {
			this.logger.trace(Model);
			throw new Error('Error loading model at ' + fn + '. this model did not contain any fields');
		}
		// if we don't provide a connector, attempt to get the connector global default the config
		// this makes it nice since i can simply put my default in the config and i don't need to specify
		// on each and every model
		Model.connector = Model.connector || this.config.defaultConnector;
		Model.filename = fn;
		if (!Model.generated) {
			Model.timestamp = fs.statSync(fn).mtime;
		}
		Model.name && (this.models[Model.name] = Model);
		this.triggerReloadedIfRequired(false, [{ fn: Model }]);
		cb && setImmediate(() => cb(null, Model));
	} catch (ex) {
		if (cb) {
			return cb(ex);
		} else {
			throw ex;
		}
	}
};

/**
 * Loads a Block from a Block file. The file must exist and be a valid Block. No error checking is performed.
 * @param {String} fn Filename of the Block.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Block class.
 */
APIBuilder.prototype.loadBlock = function loadBlock(fn, cb) {
	try {
		this.logger.debug('attempting to load block', fn);
		let Block = paths.requireComponent(fn, true);
		if (!Block) {
			this.logger.trace(Block);
			throw new Error('Error loading block at ' + fn);
		}
		if (!_.isFunction(Block)) {
			this.logger.trace(Block);
			throw new Error('Error loading block at ' + fn + '. this module did not export a Class');
		}
		let block = new Block(this.objConfig, this);
		Block.filename = block.filename = fn;
		Block.timestamp = block.timetsamp = fs.statSync(fn).mtime;
		this.blocks[block.name] = block;
		this.triggerReloadedIfRequired(false, [{ fn: block }]);
		cb && setImmediate(() => cb(null, Block));
	} catch (ex) {
		if (cb) {
			return cb(ex);
		} else {
			throw ex;
		}
	}
};

/**
 * Loads a Flow from a flow file. The file must exist and be a valid Flow.
 * @param {String} fn Filename of the flow.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Flow class.
 */
APIBuilder.prototype.loadFlow = function loadFlow(fn, cb) {
	this.logger.debug('attempting to load flow', fn);
	return this.flowManager.load(fn).then(
		function (flow) {
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(null, flow);
			});
		},
		function (err) {
			this.logger.error(err);
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(new Error('Error loading flow at ' + fn));
			});
		}.bind(this));
};

/*
 * Parses and validates a swagger document
 * See Endpoints.validateSwagger for details about validation types performed.
 * @param {string|object} swagger - swagger document
 * @returns {Promise<object>} valid swagger
 */
APIBuilder.prototype.validateSwagger = (swagger) => {
	return Endpoints.validateSwagger(swagger);
};

/**
 * Loads an endpoint from a file.
 * @param  {string} fn [path to file]
 * @param  {Function} cb [callback to for error handle]
 */
APIBuilder.prototype.loadEndpoint = function loadEndpoint(fn, cb) {
	this.logger.debug('attempting to load endpoint', fn);
	return Endpoints.load(fn, this.getFlows()).then(
		function (loaded) {
			var endpointName = path.basename(fn, '.json');
			this.endpoints[endpointName] = loaded.endpoint;
			this.endpointSwaggers[endpointName] = loaded.swagger;
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(null, loaded);
			});
		}.bind(this),
		function (err) {
			var error = 'Error loading endpoint at ' + fn;
			// err can contain .errors or is an exception
			var errors = [ error ];
			if (err.errors) {
				errors.push(' ');
				err.errors.forEach(function (e) {
					errors.push(JSON.stringify(e));
				});
			} else {
				errors.push((err + '').replace(/^Error:\s+/, '; '));
			}
			var msg = errors.join('').trim();
			this.logger.error(msg);
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(new Error(msg));
			});
		}.bind(this));
};

/**
 * Loads a Route from a Route file. The file must exist and be a valid Route. No error checking is performed.
 * @param {String} fn Filename of the Route.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Route class.
 */
APIBuilder.prototype.loadRoute = function loadRoute(fn, cb) {
	try {
		this.logger.debug('attempting to load route', fn);
		var Router = paths.requireComponent(fn, true);
		if (!Router) {
			this.logger.trace(Router);
			throw new Error('Error loading route at ' + fn);
		}
		if (!_.isFunction(Router)) {
			this.logger.trace(Router);
			throw new Error('Error loading route at ' + fn + '. this module did not export a Class');
		}
		var route = new Router(this.objConfig, this);
		this.routes.push(route);
		Router.filename = route.filename = fn;
		Router.timestamp = route.timestamp = fs.statSync(fn).mtime;
		this.triggerReloadedIfRequired(false, [{ fn: route }]);
		cb && setImmediate(() => cb(null, Router));
	} catch (ex) {
		if (cb) {
			return cb(ex);
		} else {
			throw ex;
		}
	}
};

/**
 * Loads a Codeblock from a Codeblock file. The file must exist and be a valid Codeblock. No error checking is performed.
 * @param {String} fn Filename of the Codeblock.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Codeblock class.
 */
APIBuilder.prototype.loadCodeblock = function loadCodeblock(fn, cb) {
	var msg;
	this.logger.debug('attempting to load codeblock', fn);

	CodeblockMetadata.load(fn, {
		logger: this.logger
	}).then(
		function (meta) {
			// all checks pass. Read the codeblock and save it in the instance
			// get codeblock function file
			var absPath = path.resolve(path.dirname(fn), meta.path);
			try {
				meta.action = requireUncached(absPath);
			} catch (ex) {
				msg = 'Error loading codeblock at ' + fn + '. ' + ex;
				this.logger.error(msg);
				// See "r.e. setImmediate" comment above
				setImmediate(function () {
					cb && cb(new Error(msg));
				});
				return;
			}
			if (typeof (meta.action) !== 'function') {
				msg = 'Error loading codeblock at ' + fn + '. module is not a function';
				this.logger.error(msg);
				// See "r.e. setImmediate" comment above
				setImmediate(function () {
					cb && cb(new Error(msg));
				});
				return;
			}

			this.codeblocks[meta.name] = meta;
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(null, meta);
			});
		}.bind(this),
		function (err) {
			this.logger.error(err);
			this.logger.error('Error loading codeblock at ' + fn);
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(err);
			});
		}.bind(this)
	);
};

APIBuilder.prototype.registerNode = 	function registerNode(node) {
	if (!node || !node.specs) {
		throw new Error('Not a flow-node component');
	}
	Object.keys(node.specs).forEach(
		(name) => {
			const uri = FlowManager.formatNodeHandlerUri(node.name, name);
			const spec = JSON.parse(JSON.stringify(node.specs[name]));
			spec.type = uri;

			class Node extends FlowNode { }
			Object.entries(node.specs[name].methods).forEach(([ methodName, methodDef ]) => {
				Node.prototype[methodName] = methodDef.action;
			});

			this.registeredNodes.push(uri);
			this.flowManager.registerNode(uri, Node, function () {
				return spec;
			});
		}
	);
};

APIBuilder.prototype.loadNode = function loadNode(fn, cb) {
	if (fn.match(/[/\\]package.json$/)) {
		// not a node_module - it is jut local ./nodes
		return this.loadNode(path.dirname(fn), cb);
	}

	new Promise((resolve) => resolve(require(fn)))
		.then((node) => this.registerNode(node))
		.then(() => cb && setImmediate(() => cb()))
		.catch(err => {
			const msg = `Error loading node module at ${fn}. ${err.message || err}`;
			cb && cb(msg);
		});
};

APIBuilder.prototype.loadSchema = function loadSchema(fn, cb) {
	this.logger.debug('attempting to load schema', fn, 'with scope, \'' + this.projectName + '\'');
	// adding schema as per the ticket RDPP-1673
	schemas.add(fn, 'schema:///schema/' + this.projectName + '/' + path.basename(fn, '.json'));
	cb();
};

/*
 * internally used to trigger a reloaded event if necessary
 */
APIBuilder.prototype.triggerReloadedIfRequired = function triggerReloadedIfRequired(force, obj, err) {
	if (!stopping && (force || this.loaded) && !this.pendingReload) {
		this.logger.debug('reloaded', obj);
		this.emit('reloaded', obj && Array.isArray(obj) ? obj : [ obj ], err);
	}
};

/**
 * Loads all service components.
 * @param {Function} callback Callback to execute after loading each component. Passed an Error object if any.
 */
APIBuilder.prototype.loadComponents = function loadComponents(componentTypes, callback) {
	var instance = this;
	var tasks = [];

	// Dataconnectors are identified by having a "connector" key. Load any dataconnectors specified
	// in the configuration.
	Object.keys((this.config && this.config.connectors) || {})
		.filter(name => this.config.connectors[name].connector)
		.forEach(name => {
			// Connector aliases cannot be plugin names
			if (plugins.isPluginName(name)) {
				const message = `Error configuring dataconnector ${name}. You cannot use the a plugin name as the alias in the configuration.`;
				this.logger.error(message);
				callback(message);
			}
			const loadedConnector = this.getConnector(name, false);
			if (loadedConnector) {
				tasks.push((cb) => {
					startDataconnector(this, loadedConnector, cb);
				});
			}
		});

	// load connectors, models, blocks, apis, and then routes from directories (in that order)
	// first using the node_modules (the true) and then
	// using the cwd/<type> (the false)
	componentTypes.forEach(function (type) {
		var xtype = type.replace(/^@/g, ''),
			typeName = xtype.charAt(0).toUpperCase() + xtype.substring(1),
			mn = 'load' + typeName,
			loadFn;
		if (!instance[mn]) {
			throw new Error('Missing method: ' + mn);
		}
		loadFn = instance[mn].bind(instance);

		// set a flag that we're loading
		tasks.push(function (cb) {
			instance['loading' + typeName + 's'] = true;
			cb();
		});

		// look inside project directories
		iterateComponentDir(instance, type, fn => {
			tasks.push(cb => loadFn(fn, cb));
		});

		tasks.push(function (cb) {
			// delete our flag
			delete instance['loading' + typeName + 's'];
			// fire an event that we're done loading in case
			// we have someone listening for pending models to finish before continuing
			instance.emit('loaded' + typeName + 's');
			cb();
		});
	});

	async.series(tasks, callback);
};

/*
 * called internally to start loading server. when you call start, it will wait until the
 * loaded event is fired
 */
APIBuilder.prototype.load = function load(callback) {
	// Initialize the plugin details and then load components
	const exitOnPluginFailure = this.config && this.config.flags && this.config.flags.exitOnPluginFailure;
	plugins.findPlugins(this.config, this.logger)
		.then(
			apibuilderPlugins => {
				this.apibuilderPlugins = apibuilderPlugins;
			},
			err => {
				// If findPlugins rejected, throw the err and stop
				// the server in the catch
				if (exitOnPluginFailure) {
					throw err;
				}
				if (callback) {
					callback(err);
				} else {
					this.emit('error', err);
				}
			}
		)
		.then(
			() => {
				// Load the components
				this.loadComponents([ 'schema', 'model', 'block', 'api', 'route' ], (err) => {
					if (!err) {
						// indicate we've started and emit loading event
						this.loaded = true;
						// convert models to schema and register them after all the models are loaded
						Object.values(this.models).forEach((model) => {
							this.modelToSchema(model).forEach((schema) => schemas.add(schema));
						});
						this.emit('loaded');
					} else if (callback) {
						callback(err);
					} else {
						this.emit('error', err);
					}
				});
			}
		)
		.catch(err => {
			// Log the error and stop safely
			// This catch also catches previously uncaught promise
			// rejections if connectors failed to start
			const errMsg = err && err.message || err;
			this.logger.error('server failed to start');
			errMsg && this.logger.error(errMsg);
			this.stop();
		});
};

/*
 * utility function to iterate a component directory and for each component found, call
 * the foundCallback function will the parameter of the path to the component
 */
function iterateComponentDir(instance, type, foundCallback) {
	const dir = instance.getComponentDir(type);
	instance.logger.trace('iterateComponentDir', type, dir);
	if (fs.existsSync(dir)) {
		if (type === 'model') {
			try {
				var appcJSON = require(dir + '/../appc.json');
				if (appcJSON && appcJSON.type === 'connector') {
					instance.logger.trace('skipping iterateComponentDir for ' + appcJSON.type, type, dir);
					return;
				}
			} catch (e) {
				// Ignore errors
			}
			if (loadedModelDirs.indexOf(dir) >= 0) {
				instance.logger.trace('iterateComponentDir already read', type, dir);
				return;
			}
			loadedModelDirs.push(dir);
		}

		if (type === 'codeblock' || type === 'flow' || type === 'endpoint' || type === 'schema') {
			var jsonfileRE = /^((?!_))(.*)?\.json$/;
			walkSync(dir).forEach(function fileIterator(file) {
				if (jsonfileRE.test(path.basename(file))) {
					var fn = path.join(dir, file);
					foundCallback(fn);
				} else {
					instance.logger.trace('iterateComponentDir - skipping...', file);
				}
			});
		} else {
			var jsfileRE = /^((?!_))(.*)?\.js$/;
			walkSync(dir).forEach(function fileIterator(file) {
				if (jsfileRE.test(path.basename(file))) {
					var fn = path.join(dir, file);
					foundCallback(fn);
				} else {
					instance.logger.trace('iterateComponentDir - skipping...', file);
				}
			});
		}
	} else {
		instance.logger.trace('iterateComponentDir not found', type, dir);
	}
}

/**
 * Returns a configuration value for the key (or a provided default value if not found).
 * @param {String} key Key to retrieve.
 * @param {Any} def Default value to return if the key cannot be found.
 */
APIBuilder.prototype.get = function get(key, def) {
	return this.config[key] || def;
};

/**
 * returns false if the model name passed in does not exist.
 * It handles the fatal error if the model does exist.
 *
 * At the moment it returns true, but it should stop the server
 */
function isModelDuplicate(modelName) {
	if (globalAPIBuilder && (modelName in globalAPIBuilder.models)) {
		if (globalAPIBuilder.ignoreDuplicateModels) {
			return false;
		}
		// Model already exists!
		throw new Error('Model name: ' + modelName + ' exists in multiple places');
	} else {
		return false;
	}
}

/**
 * Executes a security middleware call, which authenticates the request.  This is no longer called
 * internally, but remains public method on the APIBuilder interface.
 * @param {Object} req Request object.
 * @param {Object} resp Response object.
 * @param {Function} next Next function to call.
 */
APIBuilder.prototype.executeSecurityMiddleware = function executeSecurityMiddleware(req, resp, next) {
	return this.accessControlMiddleware(req, resp, next);
};

/*
 * calls callback with true if available, false if not
 */
function isPortAvailable(port, cb, tries) {
	tries = (tries || 0) + 1;
	var net = require('net'),
		server = net.createServer();

	server.listen(port, function (err) {
		if (err) {
			return cb(err);
		}

		var newcb;
		if (port === 0) {
			// pick a random port when 0 is used
			// we need to increment in user land and then verify again (below)
			port = server.address().port + 10;
			newcb = cb;
			cb = null;
		}
		server.once('close', function () {
			cb && cb(true, port);
			if (newcb) {
				// we need to verify our new port assigned to
				// make sure it's available since platforms don't
				// guarantee they are available
				// http://stackoverflow.com/questions/9901043/how-does-node-js-choose-random-ports
				return isPortAvailable(port, newcb, tries);
			}
		});
		server.close();
	});
	server.once('error', function (err) {
		try {
			server.close();
		} catch (e) {
			// Ignore error
		}
		if (err.code !== 'EADDRINUSE' || tries > 3) {
			cb && cb(false);
		} else {
			// on restart, sometimes a bind will fail, so let's try it again
			// for up to 3 times
			setTimeout(function () {
				isPortAvailable(port, cb, tries);
			}, 10);
		}
	});
}

/**
 * Starts the server.
 * @param {Function} [callback] Callback passed an Error object.
 * @throws Error
 */
APIBuilder.prototype.start = function start(callback) {
	// this can happen if you call loadOnly in constructor and then later
	// try and start the server
	if (!this.app) {
		var error = new Error('invalid state. no internal app was created. did you call loadOnly in the APIBuilder constructor?');
		if (callback) {
			return callback(error);
		} else {
			throw error;
		}
	}

	// if we started and then stopped and now we're restarting, we need to reload this
	if (this.shuttingdown) {
		this.logger.trace('re-start after a shutdown');
		var self = this;
		this.shuttingdown = false;
		return async.each(this.apis, function (api, cb) {
			api.remove(self, cb);
		}, function (err) {
			if (err) {
				return callback(err);
			}
			async.each(self.routes, function (route, cb) {
				if (route) {
					route.remove(self, cb);
				} else {
					cb();
				}
			}, function (err) {
				if (err) {
					return callback(err);
				}
				Object.keys(self.blocks).forEach(function (name) {
					var block = self.blocks[name];
					block.removeAllListeners();
				});
				self.models = {};
				self.apis = [];
				self.blocks = {};
				self.routes = [];
				self.load(function (err) {
					if (err) {
						return callback(err);
					}
					self.start(callback);
				});
			});
		});
	}

	if (!callback) {
		callback = function (err) {
			if (err) {
				this.logger.error('server failed to start');
				this.logger.error(err);
				this.emit('error', err);
			} else if (this.port) {
				this.logger.info('server started on port', this.port);
			} else {
				this.logger.info('server started');
			}
		}.bind(this);
	}

	if (!this.loaded) {
		this.logger.debug('waiting on server to finish loading');
		// we haven't finished loading, wait for the loading event to
		// fire and then re-entrant the start function
		return this.on('loaded', function () {
			return this.start(callback);
		}.bind(this));
	}

	this.logger.debug('starting', this.port);
	this.emit('starting');
	if (process.send && process.connected) {
		process.send('starting');
	}

	var tasks = [],
		listener,
		instance = this;

	// check the port to make sure its free
	tasks.push(function checkPortTask(next) {
		isPortAvailable(this.port, function (available, port) {
			if (!available) {
				return next(new Error('Assigned port (' + this.port + ') is already in use. '
					+ 'Please see if you have a running instance of this service on this machine. '
					+ 'You can also specify the port using the PORT environment variable when starting '
					+ 'the server or change in your config file.'));
			}
			// assign it in case it was wildcard
			this.port = port || this.port;
			this.logger.debug('port', port, 'available for use');
			return next();
		}.bind(this));
	}.bind(this));

	// load schemas
	tasks.push(function loadSchemasTask(next) {
		this.logger.debug('loading schemas');
		try {
			// register plugin schema
			const schema = (this.apibuilderPlugins && this.apibuilderPlugins.schema) || [];
			schema.forEach(s => schemas.add(s));
			schemas.loadSync();
		} catch (ex) {
			this.logger.error('error loading schemas', ex);
			return next(ex);
		}
		next();
	}.bind(this));

	// start any connectors that haven't been connected
	Object.keys(connectors).forEach(function connectorIterator(connectorName) {
		var connector = connectors[connectorName];
		if (!connector.connected) {
			tasks.push(function connectorConnectTask(cb) {
				startDataconnector(instance, connector, cb);
			});
		}
	});

	// finish loading flows, after registering node handlers
	tasks.push(function loadCodeblocks(next) {
		this.loadComponents([ 'codeblock' ], function (err) {
			this.logger.debug('Done loading codeblocks');
			next(err);
		}.bind(this));
	}.bind(this));

	// register node handlers.  has to be done after connectors, and done after checking
	// to see if port is in use (existing tests depend on that).
	tasks.push(function registerNodeHandlers(next) {
		try {
			// register flow-nodes from plugins
			const flownodes = (this.apibuilderPlugins && this.apibuilderPlugins.flownodes) || {};
			Object.keys(flownodes).forEach(moduleName => {
				Object.entries(flownodes[moduleName])
					.forEach(([ name, flownode ]) => this.registerNode({
						name: moduleName,
						specs: {
							[name]: flownode
						}
					}));
			});
			registerFlowCoreNodeHandlers(instance.flowManager);
			registerAPIBuilderNodeHandlers(instance);
			registerAuthorizationNodeHandlers(instance.flowManager);
		} catch (ex) {
			return next(ex);
		}
		next();
	}.bind(this));

	// finish loading flows, after registering node handlers
	tasks.push(function loadFlows(next) {
		this.loadComponents([ 'flow', 'endpoint' ], function (err) {
			this.logger.debug('Done loading flows and endpoints');
			next(err);
		}.bind(this));
	}.bind(this));

	// turn our models into apis
	tasks.push(function createModelAPIs(next) {
		this.createAPIsFromModels();
		next();
	}.bind(this));

	// check our APIs and Routes for uniqueness
	tasks.push(function checkAPIs(next) {
		var uniqueMap = {},
			routesAndAPIs = [].concat(this.apis, this.routes);
		for (var i = 0; i < routesAndAPIs.length; i++) {
			var obj = routesAndAPIs[i];
			// replace path params to a placeholder identifier. /foo/:id and /foo/:bar should collide
			var pathTransformed = obj.path.replace(/(:(.*?)(?=\/|$))/g, ':pathParamPlacehdr');
			if (!obj.enabled) {
				continue;
			} else if (uniqueMap[obj.method.toLowerCase() + ':' + pathTransformed]) {
				this.logger.warn('Multiple APIs or Routes registered for the same path and method; please disable or change the path of all but one of them for consistent results:');
				this.logger.warn(' - ' + obj.method + ' ' + obj.path);
				this.logger.warn(' - to disable a Model method, use `actions: [ ... ]` or `disabledActions: [ "' + obj.describes + '" ]`');
				this.logger.warn(' - to disable an API or Route, use `enabled: false');
				break;
			} else {
				uniqueMap[obj.method.toLowerCase() + ':' + pathTransformed] = true;
			}
		}
		// check endpoints for duplicate routes, if found, mark the whole endpoint invalid
		var endpointsMap = {};
		Object.keys(this.endpoints).forEach(function (ep) {
			var basepath = Endpoints.getRuntimeBasePath(this, this.endpoints[ep]);
			Object.keys(this.endpoints[ep].paths).forEach(function (path) {
				if (SWAGGER_EXTENSION.test(path)) {
					return;
				}
				Object.keys(this.endpoints[ep].paths[path]).forEach(function (method) {
					if (SWAGGER_EXTENSION.test(method) || method === 'parameters') {
						return;
					}
					var fullpath = basepath + path;
					fullpath = Endpoints.endpointToExpress(fullpath);
					// replace path params to a placeholder identifier. /foo/:id and /foo/:bar should collide
					var pathTransformed = fullpath.replace(/(:(.*?)(?=\/|$))/g, ':pathParamPlacehdr');
					var pathSignature = method + ':' + pathTransformed;
					var seen = endpointsMap[pathSignature];
					var spacer = chalk.grey('       | - ');
					var msg;

					// if route clashes with other endpoints, disable both endpoints
					if (seen) {
						msg = 'Duplicate Endpoint for path "' + method.toUpperCase() + ' ' + path + '" found in Endpoint "' + seen.endpoint + '" and ' + ep + '\n';
						msg += spacer + 'to disable an API or Route, use `enabled: false`\n';
						msg += spacer + 'to disable flow based API endpoints group, use `x-enabled: { enabled: false }`';

						// Disable the whole endpoints
						this.endpoints[ep] = Endpoints.disableEndpoint(this.endpoints[ep], msg);
						this.endpoints[seen.endpoint] = Endpoints.disableEndpoint(this.endpoints[seen.endpoint], msg);

						// Set the errors on the methods that have duplicate paths.
						this.endpoints[ep].paths[path][method] = Endpoints.disableEndpoint(this.endpoints[ep].paths[path][method], msg);
						this.endpoints[seen.endpoint].paths[seen.path][seen.method] = Endpoints.disableEndpoint(this.endpoints[seen.endpoint].paths[seen.path][seen.method], msg);
					} else {
						endpointsMap[pathSignature] = {
							endpoint: ep,
							path,
							method
						};
					}

					// if route clashes with API/Routes, disable the endpoint
					if (uniqueMap[pathSignature]) {
						msg = 'Duplicate Endpoint for path "' + method.toUpperCase() + ' ' + path + '": Multiple APIs or Routes registered for the same path and method\n';
						msg += spacer + 'to disable an API or Route, use `enabled: false`\n';
						msg += spacer + 'to disable flow based API endpoints group, use `x-enabled: { enabled: false }`';

						this.endpoints[ep] = Endpoints.disableEndpoint(this.endpoints[ep], msg);
						this.endpoints[ep].paths[path][method] = Endpoints.disableEndpoint(this.endpoints[ep].paths[path][method], msg);
					} else {
						uniqueMap[pathSignature] = true;
					}
				}.bind(this));
			}.bind(this));
		}.bind(this));
		next();
	}.bind(this));

	// bind our apis
	tasks.push(function (next) {
		sortAPIsOrRoutes(this.apis);
		var keys = {};
		this.apis.forEach(function (api) {
			if (api.enabled) {
				// keep track of already bound apis and only bind once (save memory)
				var key = api.method + api.path;
				if (key in keys) {
					return;
				}
				keys[key] = 1;
				api.bind(instance.app);
			}
		});
		next();
	}.bind(this));

	// bind our endpoints to flows
	tasks.push(function (next) {
		Endpoints.bind(instance, this.endpoints, Swagger.schemaIdToSwaggerName);
		next();
	}.bind(this));

	// bind our routes
	tasks.push(function (next) {
		sortAPIsOrRoutes(this.routes);
		var keys = {};
		this.routes.forEach(function (route) {
			if (route.enabled) {
				// keep track of already bound routes and only bind once (save memory)
				var key = route.method + route.path;
				if (key in keys) {
					return;
				}
				keys[key] = 1;
				route.bind(instance.app);
			}
		});
		next();
	}.bind(this));

	// bind swagger routes
	tasks.push(function (next) {
		Swagger.bindRoutes(this);
		next();
	}.bind(this));

	// start the admin server
	tasks.push(function (next) {
		if (this.admin) {
			this.admin.start(this, next);
		} else {
			next();
		}
	}.bind(this));

	// start up the server
	tasks.push(function appListenTask(next) {
		this.emit('listening');
		if (process.send && process.connected) {
			process.send('listening');
		}
		if (this.config.ssl) {
			var https = require('https');
			var sslPort = this.config.ssl.port;
			this.sslServer = https.createServer(this.config.ssl, this.app).listen(sslPort);
			utils.enableGracefulDestroy(this.sslServer);
			if (this.config.timeout !== undefined) {
				this.sslServer.setTimeout(this.config.timeout);
			}
			this.logger.info('SSL bound to port', sslPort);
			this.sslPort = sslPort;
		}
		this.server = this.app.listen(this.port, next);
		utils.enableGracefulDestroy(this.server);
		if (this.config.timeout !== undefined) {
			this.server.setTimeout(this.config.timeout);
		}
	}.bind(this));

	tasks.push(function startedTask(next) {
		this.emit('listen');
		this.emit('started');
		if (process.send && process.connected) {
			process.send('listen');
			process.send('started');
		}
		this.proxy && listener && this.proxy.removeListener('connected', listener);
		servers.push(this);
		next();
	}.bind(this));

	// Test for configured data connectors whose plugins aren't installed.
	tasks.push((next) => {
		Object.keys((this.config && this.config.connectors) || {})
			.filter(name => this.config.connectors[name].connector)
			.forEach(name => {
				if (!this.getConnector(name)) {
					this.logger.warn(`Unused connector configured: ${name}. Required dataconnector ${this.config.connectors[name].connector} is not installed.`);
				}
			});
		next();
	});

	// Log deprecation warnings
	tasks.push((next) => {
		const { url, features } = this.deprecations;
		const deprecations = Object.values(features).filter(d => d.active);
		deprecations.forEach(d => {
			this.logger.warn(`Deprecation: ${d.message}. For more info see ${url}${d.anchor}`);
		});
		next();
	});

	// Log credentials status
	tasks.push((next) => {
		const credCfgs = CredentialManager.getCredentialConfigs();
		if (credCfgs && Object.keys(credCfgs).length > 0) {
			Object.entries(credCfgs).forEach(([ name, cfg ]) => {
				if (cfg.status.action === 'needsAuth') {
					this.logger.warn(`Credential ${name} requires authorization.`);
				}
			});
		}
		next();
	});

	async.series(tasks, function (err) {
		callback(err);
	});
};

/**
 * Get the id of the model schema that has all the fields but no id and
 * does not allow additionalProperties. Used in create/update etc.
 *
 * @param {Model} model The model to get the schema id for.
 * @param {string} suffix The suffix to append.
 */
APIBuilder.prototype.getModelSchemaId = function (model, suffix) {
	// schema id as per the ticket RDPP-1673
	return `schema:///model/${model.name}${suffix || ''}`;
};

/**
 * Get the id of the model schema that has all the fields but no id and
 * allows additionalProperties.
 *
 * @param {Model} model The model to get the schema id for.
 */
APIBuilder.prototype.getModelSchemaExId = function (model) {
	return this.getModelSchemaId(model, '-ex');
};

/**
 * Get the id of the model schema that has all the fields including id
 * but also allows additionalProperties. Used in the swagger for programmatic
 * APIs to allow composition with the ResponseModel.
 *
 * @param {Model} model The model to get the schema id for.
 */
APIBuilder.prototype.getModelSchemaFullExId = function (model) {
	return this.getModelSchemaId(model, '-fullex');
};

/**
 * Get the id of the model schema that has all the fields including id
 * and does not allow additionalProperties. Used in the endpoint returns
 * and endpoint upsert.
 * @param {Model} model The model to get the schema id for.
 */
APIBuilder.prototype.getModelSchemaFullId = function (model) {
	return this.getModelSchemaId(model, '-full');
};

/**
 * Given a model, this method computes an array of json-schemas
 * @param  {Object} model - The apibuilder model to use
 * @return {Array}       An array of schemas
 */
APIBuilder.prototype.modelToSchema = function (model) {
	const required = [];
	const properties = {};

	if (!(model instanceof APIBuilder.Model)) {
		model = new APIBuilder.Model(model.name, model, true);
	}

	/**
	 * Casts a string representation of a value to the property type
	 * @param  {String} type  - The type to cast to
	 * @param  {(String|Any)} value - The value we want to cast/return
	 * @return {Any}
	 */
	const castModelDefault = (type = 'string', value) => {
		// Throw an error if the type and string value are not compatible
		function throwInvalidType(value, type) {
			throw new Error(`Invalid default value "${value}" for type "${type}" in model "${model.name}"`);
		}

		// Assert that the parsed/interprated value is the correct type
		function verifyType(value, type) {
			if (!(Object.prototype.toString.call(value).toLowerCase() === `[object ${type}]`)) {
				throwInvalidType(value, type);
			}
		}

		// check that the type is correct
		if (typeof value !== 'string') {
			verifyType(value, type);
			return value;
		}

		// Cast the strings to their correct type
		try {
			switch (type) {
				case 'integer':
				case 'number':
					const num = Number(value);
					isNaN(num) && (() => {
						throw new Error();
					})();
					return num;
				case 'date':
					return new Date(value).toISOString();
				case 'boolean':
				case 'array':
				case 'object':
					// Parse and verify type
					const parsedVal = JSON.parse(value);
					verifyType(parsedVal, type);
					return parsedVal;
				default:
					return value;
			}
		} catch (e) {
			throwInvalidType(value, type);
		}
	};

	Object.entries(model.fields).forEach(([ name, field ]) => {
		if (field.required) {
			required.push(name);
		}
		properties[name] = {};

		// Record any defaults or descriptions
		if ('default' in field) {
			properties[name].default = castModelDefault(field.type, field.default);
		}
		if ('description' in field) {
			properties[name].description = field.description;
		}

		// Build out or properties object
		properties[name].type = field.type;
		switch (field.type) {
			case 'date':
				properties[name].type = 'string';
				properties[name].format = 'date-time';
				break;
			case 'array':
				// TODO: We need more information about the array sub-type here. See RDPP-1672
				properties[name].items = {};
				break;
			case 'object':
				// TODO: We need more information about the object properties here. See RDPP-1672
				properties[name].additionalProperties = true;
				break;
			case 'string':
			case 'number':
			case 'integer':
			case 'boolean':
				properties[name].type = field.type;
				break;
			default:
				properties[name].type = 'string';
				break;
		}
	});

	// NOTE: You can't do composition between these schemas using allOf as each
	// clause needs to be independently enforcable, so additionalPropertes false
	// won't work.

	// Extensible schema for describing the model fields (used in schema composition).
	const modelSchemaEx = {
		id: this.getModelSchemaExId(model),
		type: 'object',
		properties: properties,
	};
	if (required.length > 0) {
		modelSchemaEx.required = required;
	}

	// Schema for describing the model fields (used in create/update).
	const modelSchema = JSON.parse(JSON.stringify(modelSchemaEx));
	modelSchema.id = this.getModelSchemaId(model);
	modelSchema.additionalProperties = false;

	const modelSchemas = [
		modelSchema,
		modelSchemaEx
	];

	// Extensible schema for model fields containing Id (used in API swagger returns)
	const pkName = model.getPrimaryKeyName();

	if (!apiBuilderConfig.flags.enableModelsWithNoPrimaryKey || pkName) {
		const pkType = apiBuilderConfig.flags.usePrimaryKeyType ? { type: model.getPrimaryKeyType() } : {};
		const modelSchemaFullEx = JSON.parse(JSON.stringify(modelSchemaEx));
		modelSchemaFullEx.id = this.getModelSchemaFullExId(model);
		modelSchemaFullEx.properties[pkName] = pkType;
		modelSchemaFullEx.required = (modelSchemaFullEx.required || []).concat(pkName);
		modelSchemas.push(modelSchemaFullEx);

		// Schema for model fields containing Id (used in endpoint upsert/returns)
		const modelSchemaFull = JSON.parse(JSON.stringify(modelSchemaFullEx));
		modelSchemaFull.id = this.getModelSchemaFullId(model);
		modelSchemaFull.additionalProperties = false;
		modelSchemas.push(modelSchemaFull);
	}

	return modelSchemas;
};

/**
 * Generates the standardized APIs from all loaded models.
 */
APIBuilder.prototype.createAPIsFromModels = function () {
	Object.keys(this.models).forEach(function routeModelIterator(name) {
		var model = this.models[name];
		this.createAPIsFromModel(model);
	}.bind(this));
};

/**
 * Generates the standardized APIs from a particular model.
 */
APIBuilder.prototype.createAPIsFromModel = function (model) {
	if (model.connector && typeof model.connector === 'string') {
		try {
			model._connector = model.connector;
			model.connector = this.getConnector(model.connector, true);
			model.connector.emit('init-model', model);
		} catch (e) {
			this.logger.trace(e.stack);
			throw new Error('Error loading connector: ' + model._connector + ' for model: ' + model.name + '. ' + e.message);
		}
	}
	if (model.autogen) {
		var modelAPIs = makeAPIsFromModel(model, this.config.apiPrefix);
		modelAPIs.forEach(function modelAPIConstructorIterator(API) {
			var api = new API(this.objConfig, this);
			this.apis.push(api);
		}.bind(this));
	}
};

/**
 * Sort the APIs or Routes (we need wildcard paths to be registered later in the process).
 */
function sortAPIsOrRoutes(apisOrRoutes) {
	apisOrRoutes.sort(function (a, b) {
		if (a.sort < b.sort) {
			return 1;
		} else if (a.sort > b.sort) {
			return -1;
		}
		// shortest paths first
		return a.path.length > b.path.length;
	});
}

function makeAPIsFromModel(model, apiPrefix) {
	// if autogen off, don't generate APIs for Model
	if (!model.autogen || (model.connector && model.connector.enabled === false) || !model.connector) {
		return [];
	}

	var apis = [],
		name = model.name;

	model.prefix = model.prefix || apiPrefix + '/' + name.toLowerCase();
	model.singular = model.singular || pluralize(name.toLowerCase(), 1);
	model.plural = model.plural || pluralize(name.toLowerCase());

	for (var key in model) {
		if (key.slice(-3) === 'API') {
			var val = model[key],
				isAPIDescriptor = _.isFunction(val),
				describes = key.slice(0, -3),
				describesUC = describes.substr(0, 1).toUpperCase() + describes.substr(1),
				enabled = true;

			if (!isAPIDescriptor) {
				continue;
			}
			var api = model[key]();
			if (!api) {
				continue;
			}

			// Check to see if the underlying connector has the necessary methods to support this API.
			var connectorMethods = (api.dependsOnAny || api.dependsOnAll || [ describes ]).filter(function (depConnectorMethod) {
				return !!model.getConnector()[depConnectorMethod];
			});
			if (connectorMethods.length < (api.dependsOnAll ? api.dependsOnAll.length : 1)) {
				enabled = false;
				delete api.enabled;
			}

			// Should we disable based on our action or action groups being disabled?
			if (model.actions.indexOf(describes) === -1 && (!api.actionGroup || model.actions.indexOf(api.actionGroup) === -1)) {
				enabled = false;
			}
			if (model.disabledActions && model.disabledActions.indexOf(describes) >= 0) {
				enabled = false;
				delete api.enabled;
			}

			// Handle some defaults for the API.
			if (!api.path) {
				api.path = model.prefix;
			} else if (api.path.substr(0, 2) === './') {
				api.path = model.prefix + api.path.substr(1);
			}
			_.defaultsDeep(api, {
				responses: {
					401: {
						description: 'This request requires user authentication, as configured by the server.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					404: {
						description: 'No results were found.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					500: {
						description: 'Something went wrong during the request; check out the logs on your server.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					504: {
						description: 'The request took too long to process, and the server timed it out.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					default: {
						description: 'Response from Server',
						schema: {
							$ref: '#/definitions/ResponseModel'
						}
					}
				}
			});

			apis.push(API.extend(_.defaults(api, {
				uiSort: Number.MAX_VALUE,
				enabled: enabled,
				generated: true,
				group: name,
				describes: describes,
				method: 'GET',
				parameters: {},
				singular: model.singular,
				plural: model.plural,
				model: name,
				pre: _.flatten(_.compact([
					model['pre' + describesUC], model['before' + describesUC],
					model['pre' + (api.method || 'GET')], model['before' + (api.method || 'GET')],
					model.pre, model.before
				])),
				post: _.flatten(_.compact([
					model['post' + describesUC], model['after' + describesUC],
					model['post' + (api.method || 'GET')], model['after' + (api.method || 'GET')],
					model.post, model.after
				]))
			})));
		}
	}

	return apis;
}

/**
 * Removes an API from the server.
 * @param {String} filename Name of the file of the API to remove.
 * @param {Function} [callback] Callback function passed an Error object (or null if successful).
 */
APIBuilder.prototype.removeAPIByFilename = function removeAPIByFilename(filename, callback) {
	var api = _.filter(this.apis, function (api) {
		return api.filename === filename;
	})[0];

	if (api) {
		api.remove(this, function (err) {
			this.triggerReloadedIfRequired(true, { filename: api }, err);
			callback && callback();
		}.bind(this));
	} else {
		callback && callback(new Error('couldn\'t find an API at ' + filename));
	}
};

/**
 * Reloads any changes found in Models, Blocks, Routes or APIs.
 * @param {Function} [callback] Callback to execute after the reload.
 */
APIBuilder.prototype.reload = function reload(callback) {
	this.logger.debug('reload called');
	this.stop(() => {
		globalAPIBuilder = new APIBuilder(this.initialConfig);
		globalAPIBuilder.start((err) => {
			if (!err) {
				this.logger.debug('reload finished!');
			}
			if (callback) {
				return callback(err, globalAPIBuilder);
			} else if (err) {
				this.emit('error', err);
			}
		});
	});
};

/**
 * Stops the APIBuilder server instance.
 * @param {Function} [callback] Callback to execute after the server stops.
 */
APIBuilder.prototype.stop = function stop(callback) {
	this.shuttingdown = true;

	if (!this.server) {
		this.logger.debug('stop called but server not started');
	}

	var tasks = [];

	// NOTE: the timing on this part of code is particularly sensitive to log_test
	// and tx_log_test (or at least I think it was timing).  The `schemas.clear`
	// used to reload global schemas on clear, but found that the child in log_test
	// was being prematurely exiting on `schemas.clear`.  Fixing the schemas so that
	// it did not reload, fixed the issue.  I doubt this will be the last time we
	// revisit the log_test/child timing issue.

	// clear schemas
	tasks.push(function (next) {
		this.logger.trace('clearing schemas');
		schemas.clear();
		next();
	}.bind(this));

	if (this.server && !this.stopped) {
		for (var c = 0; c < servers.length; c++) {
			var server = servers[c];
			if (server === this) {
				servers.splice(c, 1);
				break;
			}
		}

		this.stopped = true;
		this.logger.debug('stopping');
		this.emit('stopping');
		if (process.send && process.connected) {
			process.send('stopping');
		}

		// first stop the server so we don't serve request
		tasks.push(function serverCloseTask(next) {
			try {
				// ignore any errors on shutdown
				this.server.destroy(next);
			} catch (e) {
				next();
			}
		}.bind(this));

		// stop the SSL server if we have one
		if (this.sslServer) {
			tasks.push(function serverCloseTask(next) {
				try {
					// ignore any errors on shutdown
					this.sslServer.destroy(next);
				} catch (e) {
					next();
				}
			}.bind(this));
		}

		/**
		 * Disconnect all dataconnectors if provided a disconnect method
		 * Delete the models associated with the connector (generated and fs)
		 * so that we don't run into duplicate errors when loadComponents tries to load fs models.
		 * Delete the _createdModelsFromSchema flag so arrow-orm knows to re-grab models from schema (generated).
		 * Delete connector.started so startDataconnector() will kick off
		 */
		Object.keys(connectors).forEach(function stopConnectorIterator(name) {
			var connector = connectors[name];
			connector.disconnect && tasks.push(function connectorDisconnectTask(next) {
				connector.disconnect(next);
			});

			tasks.push(function resetConnectors(next) {
				delete connectors[name];
				next();
			});
		});

		tasks.push(function (next) {
			// This clean up method is registered only if renderers has been configured on the first place.
			// So we might skip registering if this.configWeb.needRenderers is false.
			// But to avoid edge cases where the needRenders is out of sync we always register this callback function
			// but only call cleanuWatcher in case hbs middleware has been registered.
			var handlebars = this.getMiddleware().getRendererEngine('hbs');
			// stop the handlerbars watcher if running
			handlebars && handlebars.cleanupWatchers();
			next();
		}.bind(this));

		// now fire our lifecycle event
		async.series(tasks, function asyncCallback() {
			this.emit('stopped');
			if (process.send && process.connected) {
				process.send('stopped');
			}
			this.logger.info('Server stopped');
			loadedModelDirs = [];
			callback && callback();
		}.bind(this));
	} else {
		async.series(tasks, function asyncCallback() {
			this.logger.info('Server stopped');
			this.emit('stopped');
			loadedModelDirs = [];
			callback && callback();
		}.bind(this));
	}

	// Unregister node handlers.  This is not done as a task because it is possible
	// to be partially started (and fail).  These need to be done reglardless of
	// start state.
	this.registeredNodes.forEach(function (uri) {
		this.flowManager.unregisterNode(uri);
	}.bind(this));
	this.registeredNodes = [];
	unregisterFlowCoreNodeHandlers(this.flowManager);
	unregisterAPIBuilderNodeHandlers(this);
	unregisterAuthorizationNodeHandlers(this.flowManager);
};

/**
 * @method createLogger
 * Creates a logger instance.
 * @param {Object} config
 * @param {Object} opts Additional initialization options.
 * Refer to the [bunyan documentation](https://www.npmjs.com/package/bunyan).
 * @returns {APIBuilder.Logger}
 */
/**
 * @method createLogger
 * @static
 * Creates a logger instance.
 * @param {Object} config - Logger config options.
 * @param {Object} opts - Deprecated: Additional initialization options.
 * @returns {APIBuilder.Logger}
 */
APIBuilder.prototype.createLogger
	= APIBuilder.createLogger = Logger.createLogger;

// create a continuation monkey patch in the case the server hasn't yet loaded
// and we've created a Model
function createModelClassContinuationPatch(Model) {
	if (globalAPIBuilder && !globalAPIBuilder.loaded) {
		// monkey patch any methods that must have a valid connector that is running before we can call it
		var methods = [
			'create', 'delete', 'replace', 'save', 'update', 'delete', 'deleteAll', 'find', 'findAll', 'findByID',
			'findById', 'findOne', 'fetch', 'query', 'remove', 'removeAll'
		];
		methods.forEach(function (fnName) {
			var ModelFn = Model[fnName];
			if (ModelFn) {
				Model[fnName] = createModelMethodMonkeyPatch(Model, ModelFn, fnName);
			}
		});

		// unwrap the methods after the apibuilder loads
		function builderLoader() {
			var methods = [
				'create', 'delete', 'replace', 'save', 'update', 'delete', 'deleteAll', 'find', 'findAll', 'findByID',
				'findById', 'findOne', 'fetch', 'query', 'remove', 'removeAll'
			];
			methods.forEach(function (fnName) {
				if (Model[fnName] && Model[fnName].originalFunction) {
					Model[fnName] = Model[fnName].originalFunction;
				}
			});
			globalAPIBuilder.removeListener('loaded', builderLoader);
		}
		globalAPIBuilder.on('loaded', builderLoader);
	}
}

// create a function wrapper that will watch for the server to finish loading
// (which will have started the connectors) before we actually continue with the
// function. the method (fn) being passed in must be async for this to work
function createModelMethodMonkeyPatch(ModelClass, fn, name) {
	// if we're not yet loaded, we can't call methods against the
	// ModelClass. in which case we're going to wait until we're loaded
	// and then once loaded, we'll continue
	function modelMethodMonkeyPatched() {
		var args = arguments;
		function builderLoader() {
			// make sure we resolve the connector to the real connector instance
			if (typeof ModelClass.connector === 'string') {
				ModelClass.connector = APIBuilder.getConnector(ModelClass.connector);
			}
			globalAPIBuilder.removeListener('loaded', builderLoader);
			// re-patch it back to the original so subsequent doesn't come back through this block anymore
			ModelClass[name] = fn;
			// go ahead invoke
			return fn.apply(ModelClass, args);
		}
		// wait for loaded to fire
		if (globalAPIBuilder.loaded) {
			builderLoader();
		} else {
			globalAPIBuilder.on('loaded', builderLoader);
		}
	}

	modelMethodMonkeyPatched.originalFunction = fn;

	return modelMethodMonkeyPatched;
}

/*
 * monkey patch Model.extend to make sure that we set the instance of the
 * connector before returning
 */
var ModelExtend = APIBuilder.Model.extend;
var ModelReduce = APIBuilder.Model.reduce;

APIBuilder.Model.extend = createModelMonkeyPatch(ModelExtend, 'extend');
APIBuilder.Model.reduce = createModelMonkeyPatch(ModelReduce, 'reduce');

function createModelMonkeyPatch(ModelClass, method) {
	function createModel() {
		// if we're extending a named model, resolve it first
		var model;
		if (arguments.length === 3) {
			// if we're in the middle of loading models on startup, we need to deal
			// with the case we are extending a model that has not been loaded yet,
			// in which case we want to record the dependency and then load later
			if (globalAPIBuilder && globalAPIBuilder.loadingModels) {
				var args = arguments,
					self = this;
				function fn() {
					globalAPIBuilder.removeListener('loadedModels', fn);
					return createModel.apply(self, args);
				}
				return globalAPIBuilder.on('loadedModels', fn);
			}
			// tricky. we need to check to see if the incoming connector referenced by
			// the new model is referencing a connector that is disabled and if so, just
			// return null so that the model load just fails silently (which is OK)
			if (arguments[2].connector) {
				var connector = typeof arguments[2].connector === 'string' ? APIBuilder.getConnector(arguments[2].connector) : arguments[2].connector;
				if (connector && !connector.enabled) {
					var connectorName = connector.name || arguments[2].connector;
					globalAPIBuilder && globalAPIBuilder.logger.debug('connector (' + connectorName + ') disabled, skipping model', arguments[1]);
					return;
				}
			}
			var extendModel = typeof arguments[0] === 'string' ? APIBuilder.getModel(arguments[0], true) : arguments[0],
				name = arguments[1],
				def = arguments[2];
			model = extendModel[method](name, def);
			// we need to set in case it wasn't set. this happens in cases where we loaded async
			model.name = name;
			model._parent = extendModel;
			model._supermodel = extendModel.name;
			if (!model.connector) {
				model.connector = extendModel.connector;
			}
			// if the extended model is autogen (like a built-in connector model) but we didn't
			// specify one in our own definition, assume we want to autogen it
			if (!extendModel.autogen && def.autogen === undefined) {
				model.autogen = true;
			}
			// make sure we record it. this happens in the case we async load and we didn't put it in
			// because of that...
			if (!isModelDuplicate(model.name)) {
				globalAPIBuilder.models[model.name] = model;
			}
		} else {
			// else we're creating a simple new model
			model = ModelClass.apply(APIBuilder.Model, arguments);
			isModelDuplicate(model.name);
		}

		if (model.connector && typeof model.connector === 'string') {
			// if we're running and we have a string, resolve it
			if (globalAPIBuilder && globalAPIBuilder.loaded) {
				model._connector = model.connector;
				model.connector = APIBuilder.getConnector(model.connector, true);
				model.connector.emit('init-model', model);
			} else {
				// we need to monkey patch to create continuation
				createModelClassContinuationPatch(model);
			}
		} else if (model.connector) {
			model.connector.emit('init-model', model);
		}

		return model;
	}
	return createModel;
}

/**
 * Creates a model class.
 * @static
 * @param {String} name Name of the new Model.
 * @param {APIBuilderModelDefinition} definition Model definition object.
 * @returns {APIBuilder.Model}
 */
APIBuilder.createModel = function _createModel() {
	return globalAPIBuilder.createModel.apply(globalAPIBuilder, arguments);
};

/**
 * @method createModel
 * @alias #static-method-createModel
 */
APIBuilder.prototype.createModel = APIBuilder.Model.extend;

/**
 * Adds a model class(es) on this instance.
 * @param {APIBuilder.Model/Array<APIBuilder.Model>} model Model class(es) to add.
 */
APIBuilder.prototype.addModel = function addModel() {
	for (var c = 0; c < arguments.length; c++) {
		var ModelClass = arguments[c];
		if (!isModelDuplicate(ModelClass.name)) {
			this.models[ModelClass.name] = ModelClass;
		}
		// Has the server already started?
		if (this.server) {
			var startAt = this.apis.length;
			this.createAPIsFromModel(ModelClass);
			for (var i = startAt; i < this.apis.length; i++) {
				this.apis[i].bind(this.app);
			}
		}
	}
};

/**
 * Gets a model by name.
 * @static
 * @param {String} name Name of the model to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the model could not be found.
 * @returns {APIBuilder.Model}
 * @throws Error
 */
APIBuilder.getModel = function _getModel() {
	return globalAPIBuilder && globalAPIBuilder.getModel.apply(globalAPIBuilder, arguments);
};

/**
 * @alias #static-method-getModel
 */
APIBuilder.prototype.getModel = function getModel(name, failIfMissing) {
	if (!this.models) {
		// this is only initialized that the end of the APIBuilder constructor, so if an error/exception is
		// thrown early (e.g. in validateConfig), then this will not be set.
		return null;
	}
	// in case you specify connector/appc.mysql/model - strip out the connector portion
	name = String(name || '').replace('connector/', '');
	var result = this.models[name];
	if (!result) {
		var tokens = name.split('/');
		if (tokens.length > 1) {
			var connectorName = tokens[0],
				modelName = tokens[1],
				connector = connectors[connectorName];
			if (!connector && failIfMissing) {
				throw new Error('Couldn\'t find connector named: ' + connectorName);
			}
			result = connector && connector.models && (connector.models[modelName] || connector.models[connectorName + '/' + modelName] || connector.models[connector.name + '/' + modelName]);
		}
	}
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find model named: ' + name);
	}
	return result;
};

/**
 * Gets an array of APIs available to the instance.
 * @returns {Array<APIBuilder.API>}
 */
APIBuilder.prototype.getAPIs = function getAPIs() {
	return this.apis;
};

/**
 * Returns an API for the given path and optional method in the case where more than one method.
 * may be invoked on a path. If you defined a nickname when creating the API instance, you may pass
 * the nickname to the function rather than the path and method.
 * @param {String} path Path of the API (or its nickname).
 * @param {String} [method] HTTP verb.
 * @returns {APIBuilder.API}
 */
APIBuilder.prototype.getAPI = function getAPI(path, method) {
	var pathAsRoute = path;
	if (path.substring(0, 1) !== '/') {
		pathAsRoute = '/' + path;
	}
	for (var c = 0; c < this.apis.length; c++) {
		if ((this.apis[c].path === pathAsRoute
			|| this.apis[c].nickname === path) && (!method || (method && this.apis[c].method.toUpperCase() === method.toUpperCase()))) {
			return this.apis[c];
		}
	}
};

/**
 * Adds an API on this instance.
 * @param {APIBuilder.API} api API to add.
 */
APIBuilder.prototype.addAPI = function addAPI(APIConstructor) {
	if (_.isFunction(APIConstructor)) {
		var api = new APIConstructor(this.config, this);
		this.apis.push(api);
	} else {
		this.apis.push(APIConstructor);
	}
};

/**
 * Gets all models availabe to the instance.
 * @returns {Array<APIBuilder.Model>}
 */
APIBuilder.prototype.getModels = function getModels() {
	return this.models;
};

/**
 * Gets a block by name.
 * @param {String} name Name of the block to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the block could not be found.
 * @returns {APIBuilder.Block}
 * @throws Error
 */
APIBuilder.prototype.getBlock = function getBlock(name, failIfMissing) {
	var result = this.blocks[name];
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find block named: ' + name);
	}
	return result;
};

/**
 * Gets all the flow definitions availabe to the instance.
 * @returns {Object}
 */
APIBuilder.prototype.getFlows = function getFlows() {
	return this.flowManager.getFlows();
};

/**
 * Gets the flow definition by id.
 * @param {String} flowId The id of the flow to retrieve.
 * @returns {Object}
 */
APIBuilder.prototype.getFlow = function getFlow(flowId) {
	return this.flowManager.getFlow(flowId);
};

/**
 * gets the schema for a specific node handlers
 * @param  {string} type - type/name of the schema
 * @return {Object}      - the schema for the handler
 */
APIBuilder.prototype.getRegisteredNodeSpec = function getRegisteredNodeSpec(type) {
	return this.flowManager.getRegisteredNodeSpec(type);
};

/**
 * gets all the schemas for the node handlers
 * @return {Object} - the schemas for the handlers
 */
APIBuilder.prototype.getRegisteredNodeSpecs = function getRegisteredNodeSpecs() {
	return this.flowManager.getRegisteredNodeSpecs();
};

/**
 * Gets an endpoint by path
 * @param  {String} endpoint The endpoint to get. ie '/greet'
 * @return {Object} or undefined
 */
APIBuilder.prototype.getEndpoint = function (endpoint) {
	return this.endpoints[endpoint];
};

/**
 * Gets all loaded endpoints
 * @return {Object}
 */
APIBuilder.prototype.getEndpoints = function () {
	return this.endpoints || {};
};

/**
 * Gets a route by name.
 * @param {String} name Name of the route to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the route could not be found.
 * @returns {APIBuilder.Router}
 * @throws Error
 */
APIBuilder.prototype.getRoute = function getBlock(name, failIfMissing) {
	var result = _.find(this.routes, { name: name });
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find route named: ' + name);
	}
	return result;
};

/**
 * Adds the block(s) on this instance.
 * @param {APIBuilder.Block/Array<APIBuilder.Block>} block Block(s) to add.
 */
APIBuilder.prototype.addBlock = function () {
	for (var c = 0; c < arguments.length; c++) {
		var Block = arguments[c];
		this.blocks[Block.name] = Block;
	}
};

/**
 * Gets all blocks.
 * @returns Array<APIBuilder.Block>
 */
APIBuilder.prototype.getBlocks = function getBlocks() {
	return this.blocks;
};

/**
 * Gets a codeblock by name.
 * @param {String} name Name of the codeblock to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the codeblock could not be found.
 * @returns {APIBuilder.Codeblock}
 * @throws Error
 */
APIBuilder.prototype.getCodeblock = function getCodeblock(name, failIfMissing) {
	var result = this.codeblocks[name];
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find codeblock named: ' + name);
	}
	return result;
};

/**
 * Gets all codeblocks.
 * @returns Array<APIBuilder.Codeblock>
 */
APIBuilder.prototype.getCodeblocks = function getCodeblocks() {
	return this.codeblocks;
};

/**
 * Returns a registered connector by name.
 * @static
 * @param {String} name Name of the connector to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the connector could not be found.
 * @throws Error
 */
APIBuilder.getConnector = function _getConnector() {
	if (!globalAPIBuilder) {
		throw new Error('an APIBuilder instance has not yet been created');
	}
	return globalAPIBuilder.getConnector.apply(globalAPIBuilder, arguments);
};

/**
 * Gets a connector by name.
 * @param {String} name Name of the connector to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the connector could not be found.
 * @throws Error
 */
APIBuilder.prototype.getConnector = function getConnector(name, failIfMissing) {
	if (!name) {
		throw new Error('missing name');
	}

	let connector = connectors[name];
	if (connector) {
		return connector;
	}

	// Find connector config
	let pluginName;
	let config = this.config || new Loader() || {};

	if (config.connectors && name in config.connectors) {
		config = config.connectors[name];
		pluginName = config.connector;
	}

	if (!pluginName) {
		throw new Error(`Dataconnector ${name} is not configured correctly.`);
	}

	if (this.apibuilderPlugins && this.apibuilderPlugins.dataconnector
			&& this.apibuilderPlugins.dataconnector.hasOwnProperty(pluginName)) {
		// Instantiate the connector
		try {
			const ConnectorFactory = plugins.loadPlugin(this.apibuilderPlugins.dataconnector[pluginName].path);
			if (ConnectorFactory) {
				// re-entrant flag in case a Connector inadvertently calls APIBuilder.loadModelsForConnector
				// during this ConnectorFactory.create which will cause us to re-enter this method into an
				// infinite recursion problem .. so we note and then do it again later if we have this happen
				inGetConnector = true;
				const Connector = ConnectorFactory.create(APIBuilder, this);
				inGetConnector = false;
				connector = new Connector(config || {});
				if (connector) {
					connector.filename = this.apibuilderPlugins.dataconnector[pluginName].path;
					connector.name = name;
					this.registerConnector(connector);
					// if we have a post create lifecycle callback, call it
					// this will allow connectors to do things like call APIBuilder.loadModelsForConnector
					// after the connector is instantiated but before it is returned. If we don't do this
					// we will get into an infinite loop where things done in the constructor (like load models)
					// that require the connector will attempt to re-instantiate the connector again (since it's not done registering)
					if (pendingModels) {
						connector.models = APIBuilder.loadModelsForConnector(connector.name, pendingModels.module, pendingModels.dir);
						pendingModels = null;
					}
					if (connector.postCreate) {
						connector.postCreate.call(connector);
					}
				}
			}
		} catch (e) {
			this.logger.error('Error loading connector: ' + name, e);
			throw e;
		}
	}
	if (!connector && failIfMissing) {
		throw new Error('Couldn\'t find connector named: ' + name);
	}

	return connector;
};

/**
 * @method getConnectors
 * Gets a list of registered connectors and service connectors.
 * @returns {Array}
 */
APIBuilder.prototype.getConnectors = function getConnectors() {
	var combinedConnectors = Object.assign({}, connectors);
	// For the moment, the UI displays installed 'Connectors'.  That will probably change to
	// installed 'Plugins' in the near future, and the `filter` will not be required.
	if (this.apibuilderPlugins && this.apibuilderPlugins.plugins) {
		this.apibuilderPlugins.plugins
			.filter(a => a.name.match(/api-builder-plugin-sc-.+?$/))
			.forEach(meta => {
				combinedConnectors[meta.name] = {
					type: 'serviceconnector',
					version: meta.version,
					name: meta.name,
					description: meta.description,
					// orm glue
					config: {
						documented: false
					}
				};
			});
	}
	return combinedConnectors;
};

/**
 * @method registerConnector
 * @static
 * Registers a connector.
 * @param {APIBuilder.Connector} connector Connector to register.
 */
/**
 * @method registerConnector
 * @alias #static-method-registerConnector
 */
APIBuilder.registerConnector
	= APIBuilder.prototype.registerConnector = function registerConnector(connector) {
		connectors[connector.name] = connector;

		// attach a get model convenience function on the connector
		if (!connector.getModel) {
			connector.getModel = function (name) {
				return this.models && (this.models[name] || this.models[this.name + '/' + name]);
			};
		}

		if (connector.models) {
			Object.keys(connector.models).forEach(function keyIterator(name) {
				var model = connector.models[name];
				// map to the real connector instance
				model.connector = connector;
			});
		}
	};

function loadModels(models, dir, connectorName) {
	if (loadedModelDirs.indexOf(dir) >= 0) {
		return;
	}
	loadedModelDirs.push(dir);
	fs.readdirSync(dir).forEach(function modelResolver(name) {
		var p = path.join(dir, name);
		if (fs.statSync(p).isDirectory()) {
			loadModels(models, p, connectorName);
		} else if (path.extname(p) === '.js' && path.basename(p).charAt(0) !== '_') {
			// only do .js files that don't start with _
			var model = paths.requireComponent(p);
			if (model && !(model.name in models)) {
				if (model.fields && Object.keys(model.fields).length) {
					models[model.name] = model;
					globalAPIBuilder && (model.connector = APIBuilder.getConnector(connectorName));
					model.filename = p;
					globalAPIBuilder && globalAPIBuilder.addModel(model);
				}
			} else {
				throw new Error('Model: ' + model.name + ' already exists in connector: ' + connectorName);
			}
		}
	});
}

/**
 * Removes a model from this instance.
 * @param {APIBuilder.Model} model Model to remove.
 */
APIBuilder.prototype.removeModel = function (model) {
	delete this.models[model.name];
};

/**
 * Removes a connector.
 * @param {APIBuilder.Connector} connector Connector to remove.
 */
APIBuilder.prototype.removeConnector = function (connector) {
	delete this.connectors[connector.name];
};

/**
 * Removes a block.
 * @param {APIBuilder.Block} block Block to remove.
 */
APIBuilder.prototype.removeBlock = function (block) {
	delete this.blocks[block.name];
};

/**
 * Removes an API.
 * @param {APIBuilder.API} api API to remove.
 */
APIBuilder.prototype.removeAPI = function (api) {
	for (var c = 0; c < this.apis.length; c++) {
		var a = this.apis[c];
		// eslint-disable-next-line security/detect-possible-timing-attacks
		if (a === api) {
			this.apis.splice(c, 1);
			break;
		}
	}
	api.remove(this);
};

/**
 * Removes a route.
 * @param {APIBuilder.Router} route Route to remove.
 */
APIBuilder.prototype.removeRoute = function (route) {
	if (route) {
		for (var i = 0; i < this.routes.length; i++) {
			var currentRoute = this.routes[i];
			if (currentRoute === route) {
				this.routes.splice(i, 1);
				break;
			}
		}
		route.remove(this);
	}
};

/**
 * returns an APIBuilder toJSON description
 */
APIBuilder.prototype.toJSON = function () {
	return '[object APIBuilder]';
};

/**
 * returns an util.inspect description
 */
APIBuilder.prototype.inspect = function () {
	return '[object APIBuilder]';
};

/**
 * Dynamically loads the models into the server if the connector updates them dynamically
 * (i.e. after connect has run and started);
 */
APIBuilder.prototype.registerModelsForConnector = function registerModelsForConnector(connector, models) {
	if (!models || !_.isObject(models)) {
		throw new Error('Invalid argument passed to registerModelsForConnector: connector/' + connector.name + '; models must be an object.');
	}

	// Remove models that have no fields as they are not usable.
	models = Object.keys(models).reduce(function (col, name) {
		if (models[name].fields && Object.keys(models[name].fields).length) {
			col[name] = models[name];
		}
		return col;
	}, {});

	Object.keys(models).forEach(function (name) {
		var Model = models[name];
		if (Model.visible || Model.visible === undefined) {
			this.models[name] = Model;
		}
	}.bind(this));
};

/**
 * Called by a connector to attempt to load any connector bundled models.
 * @param {String} connectorName Name of the connector.
 * @param {Object} module Connector module instance.
 * @param {String} dir Directory of the connector's models. Default is the connector's models folder.
 */
APIBuilder.loadModelsForConnector = function loadModelsForConnector(connectorName, module, dir) {
	if (inGetConnector) {
		// handle re-entrant issue with ConnectorFactory that calls this during
		// instantiation if we're still loading. will cause us to do this after its done
		pendingModels = { module: module, dir: dir };
		return;
	}
	var modelsDir = path.resolve(dir || path.join(path.dirname(path.dirname(module.filename)), 'models'));

	// attempt to load any models packaged with the connector
	if (fs.existsSync(modelsDir)) {
		var models = {};
		loadModels(models, modelsDir, connectorName);
		return models;
	}
};

// map helper functions
APIBuilder.pluralize = function doPluralize(name) {
	return pluralize(name);
};

APIBuilder.singularize = function doSingularize(name) {
	return pluralize(name, 1);
};

/**
 * Determines wheather or not the requested path is to one of the static resources.
 *
 * @param {string} publicDirectory - The path to the static resources in the application.
 * @param {string} resourcePath - The path to the requested resource.
 *
 * @returns {Promise} - Promise object represents the boolean equivelent to being a static resource or not.
 */
function isStaticResource(publicDirectory, resourcePath) {
	return new Promise((resolve) => {
		// Check if the file exists in the public directory.
		fs.access(path.join(publicDirectory, resourcePath), fs.constants.F_OK, (error) => {
			const isStatic = !error;

			resolve(isStatic);
		});
	});
}

function setupStaticPublicMiddleware(server, appdir) {
	server.use(express.static(path.join(appdir, 'web', 'public')));
}

function setupAuthenticationStrategy(apiBuilder, server) {
	apiBuilder.authStrategy = new Authentication(apiBuilder);
	apiBuilder.accessControlMiddleware = getAccessControlMiddleware({
		logger: apiBuilder.logger,
		config: apiBuilder.config,
		authStrategy: apiBuilder.authStrategy,
		isCORSReq,
		isCORSPreflight: isPreflight,
		caseSensitive: () => {
			// this is a function to allow this to be set by the application
			return apiBuilder.app.get('case sensitive routing') || false;
		}
	});
	server.use(apiBuilder.accessControlMiddleware);
}

function startRequestMiddleware(req, resp, next) {
	// handle serialization to the log so that we only dump a subset of the object
	req.inspect = function () {
		return '[object Request]';
	};
	req.toJSON = function () {
		// express creates a circular reference to req.res and res.req.
		return {
			method: req.method,
			url: req.url,
			headers: req.headers,
			remoteAddress: req.connection.remoteAddress,
			remotePort: req.connection.remotePort
		};
	};
	resp.inspect = function () {
		return '[object Response]';
	};
	resp.toJSON = function () {
		// express creates a circular reference to req.res and res.req.
		return {
			statusCode: resp.statusCode,
			headers: resp.getHeaders ? resp.getHeaders() : resp._headers,
			body: resp.body
		};
	};
	req.logger.logRequest(req);
	next();
}

/**
 * called at the end of a request once it's done sending
 */
function endRequestMiddleware(req, resp) {
	if (req.pendingReqCount) {
		pendingRequests--;
		if (pendingRequests < 0) {
			pendingRequests = 0;
		}
		req.pendingReqCount = null;
		var logger = req.server.logger;
		resp.on('finish', () => {
			req.logger.logResponse(resp);
		});

		// if no pending requests and we haven't do a GC in awhile, let's attempt to GC if
		// our heap usage is >1M
		if (memwatch && pendingRequests === 0 && (Date.now() - lastGCCheck) > 60000) {
			lastGCCheck = Date.now();
			var heapUsed = process.memoryUsage().heapUsed / 1024;
			if (heapUsed > 1000000) {
				(logger.debug || consoleLog)('triggering gc, heap usage', heapUsed + 'k');
				memwatch.gc();
			}
		}
	}
}

// shutdown all servers and then exit
function shutdownAllServers(exitCode, dontexit) {
	if (stopping) {
		return;
	}
	stopping = true;
	exitCode = exitCode === undefined ? 0 : exitCode;
	async.each(servers, function (server, cb) {
		server.stop(cb);
	}, function () {
		stopping = false;
		if (dontexit) {
			return;
		}
		process.exit(exitCode);
	});
}

// restart all servers by first stopping and then restarting them
function restartAllServers() {
	if (stopping) {
		return;
	}
	async.each(servers, function (server, cb) {
		server.pendingReload = true;
		server.loaded = false;
		server.stop(function (err) {
			if (err) {
				return cb(err);
			}
			stopping = false;
			pendingRequests = 0;
			server.pendingReload = false;
			server.start(function (err) {
				server.loaded = true;
				cb(err);
			});
		});
	});
}

// normal shutdown type signals
// for now, we're going to ignore SIGHUP since that can be sent on terminal
// disconnect or backgrounding
[ 'exit', 'SIGINT', 'SIGTERM', 'SIGQUIT' ].forEach(function (name) {
	process.on(name, shutdownAllServers);
});

// restart if we receive the SIGUSR2 signal
process.on('SIGUSR2', function () {
	consoleLog('apibuilder.js: signal received SIGUSR2 restarting');
	restartAllServers();
});

// on SIGABRT we are going to send an abort which should core on *nix platforms
process.on('SIGABRT', function () {
	shutdownAllServers(0, true);
	process.abort();
});

// monitor any unhandled exceptions
process.on('uncaughtException', function (error) {
	if (_.isObject(error)) {
		consoleLog('Uncaught Exception', error.message);
		try {
			error.stack && consoleLog(error.stack);
		} catch (e) {
			// Ignore errors
		}
	} else {
		consoleLog('Uncaught Exception', error);
	}
	// if we get an unhandled exception we need to crash the process
	process.exit(1);
});

// monitor any memory leaks
memwatch && memwatch.on('leak', function (info) {
	consoleLog('memory leak detected', info);
});
