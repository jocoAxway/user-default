const fs = require('fs'),
	path = require('path'),
	Logger = require('./logger'),
	_ = require('lodash'),
	merge = require('lodash.merge'),
	requireUncached = require('require-uncached'),
	envRegex = /^(.*\.)?(default|local)\.js$/;

/**
 * Loads up the configuration files in to the global $config object.
 */
function Loader(dirname, defaultConfig) {
	const logger = Logger.createLogger();
	const logs = []; // we do not know log-level until we read config; save up log messages
	const configFiles = [];

	// dirname is the configuration directory path
	dirname = dirname && fs.existsSync(dirname) && path.basename(dirname) === 'conf' ? dirname : path.join(dirname || process.cwd(), 'conf');

	// merge in defaultConfig
	let config = { dir: path.dirname(dirname) };
	if (defaultConfig && _.isObject(defaultConfig)) {
		config = merge(defaultConfig, config);
	}

	// Process all the other config files found
	fs.existsSync(dirname) && fs.readdirSync(dirname)
		.filter(n => /\.js$/.test(n))
		.forEach(fn => {
			// only local and default config files allowed
			if (envRegex.test(fn) && !fn.startsWith('.')) {
				const file = path.join(dirname, fn);
				configFiles.push(file);
			} else {
				const confStr = `conf${path.sep}`;
				logs.push(logger.warn.bind(logger, `skipping ${confStr}${fn}. Use ${confStr}local.js or ${confStr}default.js`));
			}
		});

	const orderedConfigs = sortConfig(configFiles);
	if (orderedConfigs.length === 0) {
		logs.push(logger.debug.bind(logger, 'no configuration files loaded'));
	} else {
		logs.push(logger.debug.bind(logger, `configuration applied in this order: ${orderedConfigs}`));
	}

	// now merge them in the right order
	orderedConfigs.forEach(file => {
		mix(config, requireUncached(file));
	});

	logger.level(config.logLevel || 'NONE');
	logs.forEach(log => log());

	return config;
}

const sortConfig = (configs) => {
	const configsMap = {};
	configs.forEach(fn => {
		const name = path.basename(fn);
		const match = envRegex.exec(name);
		if (match) {
			const envName = match[2];
			configsMap[envName] = (configsMap[envName] || []).concat(fn);
		}
	});
	// Sort both default and local groups
	configsMap.default && configsMap.default.sort();
	configsMap.local && configsMap.local.sort();

	// now combine the config file lists, local will override any defaults
	const ordered = (configsMap.default || [])
		.concat(configsMap.local || []);
	return ordered;
};

/**
 * Combines the src object into the dest object
 * @param  {Object} dest - The destination object getting updated
 * @param  {Object} src  - The object to pull properties from
 */
const mix = (dest, src) => {
	Object.keys(src).forEach(function (p) {
		if (dest.hasOwnProperty(p) && Object.prototype.toString.call(dest[p]) === '[object Object]') {
			mix(dest[p], src[p]);
		} else {
			dest[p] = src[p];
		}
	});
};

Loader.sortConfig = sortConfig;
module.exports = Loader;
