const fs = require('fs');
const path = require('path');
const util = require('util');
const apiBuilderConfig = require('@axway/api-builder-config');

const readdirAsync = util.promisify(fs.readdir);
const accessAsync = util.promisify(fs.access);

// The regexes to determine the module type.
const PLUGIN_REGEX = /^(?:@(.+)\/)?api-builder-plugin-.+$/;

/**
 * Plugin error message
 * @param {string} name plugin name
 * @param {object|string} err error or error message
 */
function errorMsg (name, err) {
	return `Error loading plugin: ${name}. ${err && err.message || err}`;
}

/**
 * Check if module is a dataconnector module.
 * @private
 * @param {*} mod The export from the module.
 * @returns {boolean} true if this module is a data connector.
 */
function isDataConnector(module) {
	return module && typeof module === 'object' && typeof module.create === 'function';
}

/**
 * Check if a module is a plugin.
 * @private
 * @param {*} mod The export from the module.
 * @returns {boolean} true if this module is a plugin.
 */
function isPlugin(module) {
	return typeof module === 'function';
}

/**
 * Determine the type of the plugin.
 * @private
 * @param {object} plugin Plugin object
 * @returns {string} The type of the module. Possible values: ['dataconnector', 'plugin'].
 */
function classify(plugin, logger) {
	if (isDataConnector(plugin.module)) {
		return 'dataconnector';
	} else if (isPlugin(plugin.module)) {
		return 'plugin';
	} else {
		logger.warn(errorMsg(plugin.name, 'Plugins should export a function.'));
	}
}

/**
 * Add the plugin metadata to the the plugin descriptor
 * @param {object} plugin The plugin descriptor.
 */
function addMetaData(logger, plugin) {
	plugin.version = '';
	plugin.description = '';
	try {
		const pkginfo = require(`${plugin.path}/package.json`);
		plugin.name = pkginfo.name;
		plugin.version = pkginfo.version;
		plugin.description = pkginfo.description;
	} catch (ex) {
		logger.warn(`Unable to find package.json in ${plugin.path}. You might want to run 'npm init' to create one.`);
	}
	return plugin;
}

function resolveModule2(plugin, config, logger) {
	const scopedConfig = getScopedConfig(config, plugin);
	try {
		plugin.module = loadPlugin(plugin.path);
	} catch (err) {
		return Promise.reject(errorMsg(plugin.name, err));
	}
	if (isDataConnector(plugin.module)) {
		plugin.type = 'dataconnector';
		return Promise.resolve(plugin);
	} else if (isPlugin(plugin.module)) {
		plugin.type = 'plugin';

		// start a promise chain first in case plugin.module is not a promise and throws.
		return Promise.resolve()
			.then(() => {
				const options = {
					// Freeze the scopped logger, to prevent malicious changes
					logger: Object.freeze(logger.scope(null, { prefix: `[${plugin.name}]` }))
				};
				// execute the plugin function.
				return plugin.module(scopedConfig, options);
			})
			.then(pluginData => {
				// could be undefined if there was an error - we will ignore it later
				plugin.module = pluginData;
				return plugin;
			}, (err) => {
				return Promise.reject(errorMsg(plugin.name, err));
			});
	} else {
		return Promise.reject(errorMsg(plugin.name, 'Plugins should export a function.'));
	}
}

/**
 * Classifies and resolves the plugin module.
 * @param {object} plugin - The plugin descriptor
 * @param {object} config - The service config
 * @param {object} logger - The api builder config
 * @returns {Promise} A promise that resolves the plugin's module and returns the resolved plugin object.
 */
function resolveModule(plugin, config, logger) {
	try {
		plugin.module = loadPlugin(plugin.path);
	} catch (err) {
		logger.warn(errorMsg(plugin.name, err));
		return Promise.resolve(plugin);
	}
	plugin.type = classify(plugin, logger);
	if (plugin.type !== 'plugin') {
		return Promise.resolve(plugin);
	}
	const scopedConfig = getScopedConfig(config, plugin);
	// start a promise chain first in case plugin.module is not a promise and throws.
	return Promise.resolve()
		.then(() => {
			const options = {
				// Freeze the scopped logger, to prevent malicious changes
				logger: Object.freeze(logger.scope(null, { prefix: `[${plugin.name}]` }))
			};

			// execute the plugin function.
			return plugin.module(scopedConfig, options);
		})
		.catch(err => {
			// catch any loading errors and log them
			logger.warn(errorMsg(plugin.name, err));
		})
		.then(pluginData => {
			// could be undefined if there was an error - we will ignore it later
			plugin.module = pluginData;
			return plugin;
		});
}

/**
 * Classifies and resolves the plugin config.
 * @param {object} plugin - The plugin descriptor
 * @param {object} config - The service config
 * @returns {object} The plugin config object.
 */
function getScopedConfig(config, plugin) {
	if (apiBuilderConfig.flags.enableScopedConfig) {
		config.pluginConfig = config.pluginConfig || {};
		return Object.freeze({ proxy: config.proxy, ...config.pluginConfig[plugin.name] });
	}
	const scopedConfig = config.pluginConfig ? { proxy: config.proxy, ...config.pluginConfig[plugin.name] } : config;
	return scopedConfig;
}

/**
 * List the modules in a directory, if there are scoped modules they are
 * also returned.
 * @private
 * @param {string} dir The folder from which to list the modules.
 * @returns {Promise} A promise that when resolved will return an array of { name, path }.
 */
function listDir(dir) {
	return readdirAsync(dir).then(
		(modules) => {
			return Promise.all(
				modules.map(module => {
					if (/^@/.test(module)) {
						// Scoped
						return readdirAsync(path.join(dir, module)).then(
							subs => subs.map(sub => ({
								name: `${module}/${sub}`,
								path: path.join(dir, module, sub)
							}))
						);
					}
					// Not scoped
					return {
						name: module,
						path: path.join(dir, module)
					};
				})
			);
		}
	);
}

/**
 * Walk the specified path and list the contents of the path or null if no access.
 * @private
 * @param {string} pathToWalk The folder to walk.
 * @returns {Promise} When resolved a list containing module descriptors { name, path } and/or nulls if no access.
 */
function walkPath(pathToWalk) {
	return accessAsync(pathToWalk, fs.constants.R_OK).then(
		() => listDir(pathToWalk),
		() => null // No Access
	);
}

/**
 * Find all the plugin modules on the search path.
 * @param {object} config - The configuration to use when loading the plugin.
 * @param {object} logger - The api builder logger.
 * @returns {Promise} When resolved a map of all the available plugins grouped
 * by type: { dataconnector: { name1: {name1, path1, version1, description1}, ... nameN: {nameN, pathN, versionN, descriptionN} }, }.
 */
function findPlugins(config, logger) {
	const searchPaths = [
		path.join(process.cwd(), 'node_modules')
	];

	// Walk the search paths and filter the results
	return Promise.all(searchPaths.map(walkPath))
		.then(
			// Flatten
			moduleDirs => {
				const filtered = {};
				moduleDirs.forEach(
					moduleDir => moduleDir && moduleDir.forEach(
						module => {
							if (!module) {
								return;
							}
							if (Array.isArray(module)) {
								module.forEach(scoped => {
									filtered[scoped.name] = scoped;
								});
							} else {
								filtered[module.name] = module;
							}
						})
				);
				return filtered;
			}
		)
		.then(
			// Filter to plugin modules
			modules => {
				return Object.keys(modules)
					.filter(name => isPluginName(name))
					.reduce((acc, cur) => {
						acc[cur] = modules[cur];
						return acc;
					}, {});
			}
		)
		.then(
			// Load metadata from package.json
			plugins => {
				Object.values(plugins).forEach(addMetaData.bind(null, logger));
				return plugins;
			}
		)
		.then(
			// Classify and resolve modules
			plugins => {
				if (apiBuilderConfig.flags.exitOnPluginFailure) {
					return Promise.all(Object.values(plugins).map(plugin => (
						resolveModule2(plugin, config, logger)
					)));
				} else {
					return Promise.all(Object.values(plugins).map(plugin => (
						resolveModule(plugin, config, logger)
					)));
				}
			}
		)
		.then(
			// Duck typing
			plugins => {
				return Object.keys(plugins).reduce((acc, name) => {
					const info = plugins[name];

					// check if the plugins were loaded correctly;
					if (!info.module || !info.type) {
						return acc;
					}

					if (info.type === 'plugin') {
						const { flownodes, schema } = info.module;
						// combine flow-nodes if found from each plugin
						if (flownodes) {
							acc.flownodes = {
								[info.name]: info.module.flownodes,
								...acc.flownodes
							};
						}
						// combine schema if found from each plugin
						if (schema) {
							acc.schema = acc.schema.concat(schema);
						}
					} else {
						acc[info.type][info.name] = {
							name: info.name,
							path: info.path,
							version: info.version,
							description: info.description
						};
					}
					acc.plugins.push(info);
					logger.info(`Registered plugin: ${info.name}`);
					return acc;
				}, {
					dataconnector: {},
					flownodes: {},
					schema: [],
					plugins: []
				});
			}
		);
}

function loadPlugin(name) {
	return require(name);
}

function isPluginName(name) {
	return PLUGIN_REGEX.test(name);
}

exports = module.exports = {
	findPlugins,
	loadPlugin,
	isPluginName
};
