const pathToRegexp = require('path-to-regexp');
const chalk = require('chalk');

/**
 * Gets access-control middleware.
 *
 * @param {object} options - Options
 * @param {object} options.config - The API Builder config.
 * @param {object} options.authStrategy - An initialized authentication strategy.
 * @param {object} options.logger - The API Builder logger.
 *
 * @return {object} An express middleware to control authenticated access.
 */
function getAccessControlMiddleware(options) {
	const {
		config,
		authStrategy,
		logger,
		caseSensitive,
		isCORSReq,
		isCORSPreflight
	} = options;

	// check options
	[ 'config', 'authStrategy', 'logger' ].forEach((attr) => {
		if (!options.hasOwnProperty(attr)) {
			throw new Error(`internal error - expected ${attr}`);
		}
	});

	let initialized = null;
	let apiPrefix;
	let publicPaths;

	// load the defined authentication strategy
	return (req, resp, next) => {
		if (!initialized) {
			// Delay initialization of paths until the application starts.
			initialized = initializePaths(config, (caseSensitive && caseSensitive()));
			apiPrefix = initialized.apiPrefix;
			publicPaths = initialized.publicPaths;
		}

		// note: the order is important
		if (isCORSReq(req, config.cors) && isCORSPreflight(req)) {
			// CORS handling and CORS preflight requests are handled further down the
			// middleware chain - in Endpoints.addCors and in apibuilder.js isCORSReq.
			// CORS preflight requests did not previously require authentication.  So,
			// without this check, it would be a breaking change.
			next();
		} else if (config.accessControl.apiPrefixSecurity === 'plugin'
			&& authStrategy.matchURL
			&& authStrategy.matchURL(req)) {
			// matched the request path against the API prefix using old plugin matchURL
			// the validateRequest next signature is (err, passed, result).  this code
			// more/less came from APIBuilder.prototype.executeSecurityMiddleware, and
			// it used to call executeAuth, which was invoking sync/async exactly the
			// same as AuthStrategy.prototype.validateRequest above.
			//
			// NOTE: This code is intentionally duplicated to make it easier to delete.
			authStrategy.validateRequest(req, resp, (err, passed, result) => {
				if (passed === true) {
					return next();
				}
				logger.scope(req).info(`Failed authentication to ${chalk.grey(req.path)}`);
				if (err || result) {
					sendError(err, result, req, resp);
				} else {
					sendUnauthorized(req, resp);
				}
			});
		} else if (apiPrefix.exec(req.path) !== null) {
			// matched the request path against the API prefix
			if (config.accessControl.apiPrefixSecurity === 'none') {
				return next();
			} else {
				// the validateRequest next signature is (err, passed, result).  this code
				// more/less came from APIBuilder.prototype.executeSecurityMiddleware, and
				// it used to call executeAuth, which was invoking sync/async exactly the
				// same as AuthStrategy.prototype.validateRequest above.
				authStrategy.validateRequest(req, resp, (err, passed, result) => {
					if (passed === true) {
						return next();
					}
					logger.scope(req).info(`Failed authentication to ${chalk.grey(req.path)}`);
					if (err || result) {
						sendError(err, result, req, resp);
					} else {
						sendUnauthorized(req, resp);
					}
				});
			}
		} else if (publicPaths.find(pubpath => pubpath.exec(req.path) !== null)) {
			next();
		} else {
			logger.scope(req).info(`Denied access to ${chalk.grey(req.path)}`);
			sendNotFound(req, resp);
		}
	};
}

/**
 * AccessControl is constructed too early to allow the application time to set the case-
 * sensitivity.  Having express and AccessControl use the _same_ sensitivity ensures
 * it behaves as expected.  Otherwise, AccessControl would be case-insensitive and the
 * worst-case is that AccessControl matches and validates /API/greet and express later
 * fails to route to it.  There is an edge-case where the user wants to use /API as a
 * public path.  In that case, the application would require authentication to what was
 * supposed to be a public path.
 *
 * @param {object} config - The API Builder config.
 * @param {bool} [caseSensitive=false] - Sets the case sensitivity of the path match.
 * @return {object} An apiPrefix regex and array of publicPaths regex.
 */
function initializePaths(config, caseSensitive = false) {
	const regexOptions = {
		sensitive: caseSensitive
	};

	// convert public paths
	const publicPaths = (config.accessControl.public
		&& config.accessControl.public instanceof Array
		&& config.accessControl.public.map(a => toExpressPath(a, regexOptions))) || [];

	// add the Swagger apidoc if enabled
	if (config.apidoc && !config.apidoc.disabled) {
		publicPaths.push(toExpressPath(config.apidoc.prefix, regexOptions));
	}

	// add the admin API if enabled
	if (config.admin && config.admin.enabled) {
		publicPaths.push(toExpressPath('/console', regexOptions));
		publicPaths.push(toExpressPath('/adminapi', regexOptions));

		// add the authorization callback (if admin is emabled)
		if (config.authorization && config.authorization.callback) {
			publicPaths.push(toExpressPath(config.authorization.callback, regexOptions));
		}
	}

	const apiPrefix = toExpressPath(config.apiPrefix, regexOptions);

	return {
		apiPrefix,
		publicPaths
	};
}

/**
 * Convert path into an express path regex that will convert, e.g. /console to
 *  ^/console(/*)?$, which would be capable of matching /console, /console/,
 * and /console/foo.
 *
 * @param {string} src - The path to convert.
 * @return {string} The express regexp
 */
function toExpressPath(src, options) {
	// strip trailing slash
	const stripped = src.replace(/\/$/, '');
	// by default, case-insensitive
	return pathToRegexp(`${stripped}(/.*)?`, null, options);
}

/**
 * Sends 401 unauthorized error.
 * @param {object} req - The express request object.
 * @param {object} resp - The express response object.
 */
function sendUnauthorized(req, resp) {
	sendError({
		statusCode: 401,
		id: 'com.appcelerator.api.unauthorized',
		message: 'Unauthorized'
	}, null, req, resp);
}

/**
 * Sends 404 not found.
 * @param {object} req - The express request object.
 * @param {object} resp - The express response object.
 */
function sendNotFound(req, resp) {
	resp.status(404).send('Not Found');
}

/**
 * Sends error.
 * @param {object} [err] - An error with id, statusCode, and message.  If not supplied, defaults are applied.
 * @param {object} [result] - The result.  If not supplied, a default one is applied.
 * @param {object} req - The express request object.
 * @param {object} resp - The express response object.
 */
function sendError(err, result, req, resp) {
	resp.status(err && err.statusCode || 401);
	if (req.accepts('json')) {
		resp.json(result || {
			id: err && err.id || 'com.appcelerator.api.unauthorized',
			message: err && err.message || 'Unauthorized',
			success: false
		});
	} else {
		// 'txt' is correct https://expressjs.com/en/api.html#res.type
		resp.type('txt')
			.send(err && err.message || 'Unauthorized');
	}
}

module.exports = getAccessControlMiddleware;
