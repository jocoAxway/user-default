const contentType = require('content-type');
const qs = require('qs');
const request = require('request');
const { status, States } = require('../status');
const { typeofCredential } = require('./handlerUtils');

const CRED_ATTRS = [ 'access_token', 'authentication_url', 'client_id', 'client_secret', 'flow', 'token_url', 'redirect_uri', 'refresh_token', 'scope' ];

/**
 * Do type specific initialization of the credential.
 * @param {object} config The config.
 * @param {object} credential The credential to initialize.
 */
function initCredential(config, credential) {
	/**
	 * Tests a credential has no undefined values.
	 *
	 * @param {object} credential - The credential.
	 * @param {object} tcred - The redential types from typeofCredential.
	 * @returns {boolean} True if this is a valid credential.
	 */
	function validCredential(credential, tcred) {
		return CRED_ATTRS.every(a => tcred[a] !== 'undefined');
	}

	/**
	 * Tests for a valid static access token.  Note that this is the only case that allows
	 * undefined values.  Specifically this case:
	 *
	 * "type": "oauth2",
	 * "client_id": null | undefined,
	 * "client_secret": null | undefined,
	 * "authentication_url": null | undefined,
	 * "token_url": null | undefined,
	 * "scope": null | undefined,
	 * "refresh_token": null | undefined,
	 * "access_token": "non-null"
	 *
	 * @param {object} credential - The credential.
	 * @param {object} tcred - The redential types from typeofCredential.
	 * @returns {boolean} True if this credential is a valid static access token.
	 */
	function hasStaticAccessToken(credential, tcred) {
		return tcred.access_token === 'string' && CRED_ATTRS
			.filter(a => ![ 'access_token', 'redirect_uri' ].includes(a))
			.every(a => tcred[a] !== 'string');
	}

	/**
	 * Tests for missing client credentials.  Specifically where either client_id or
	 * client_secret are null, but neither are string.
	 *
	 * "type": "oauth2",
	 * "client_id": null,
	 * "client_secret": null,
	 * "authentication_url": "non-null-looks-like-url",
	 * "token_url": "non-null-looks-like-url",
	 * "scope": "null-or-string",
	 * "refresh_token": null,
	 * "access_token": null
	 *
	 * @param {object} credential - The credential.
	 * @param {object} tcred - The redential types from typeofCredential.
	 * @returns {boolean} True if this credential needs client configuration.
	 */
	function needsClient(credential, tcred) {
		return tcred.authentication_url === 'string'
			&& tcred.token_url === 'string'
			&& tcred.flow === 'string'
			&& (tcred.client_id === 'null' || tcred.client_secret === 'null')
			&& (tcred.client_id !== 'string' || tcred.client_secret !== 'string')
			&& tcred.scope !== 'undefined'
			&& tcred.access_token === 'null'
			&& tcred.refresh_token === 'null';
	}

	/**
	 * Tests for credentials that are valid enough to begin the access code grant flow.
	 *
	 * "type": "oauth2",
	 * "client_id": "non-null",
	 * "client_secret": "non-null",
	 * "authentication_url": "non-null-looks-like-url",
	 * "token_url": "non-null-looks-like-url",
	 * "scope": "null-or-string",
	 * "refresh_token": null,
	 * "access_token": null
	 *
	 * @param {object} credential - The credential.
	 * @param {object} tcred - The redential types from typeofCredential.
	 * @returns {boolean} True if this credential has enough to begin access code grant flow.
	 */
	function hasGrantConfig(credential, tcred) {
		return CRED_ATTRS
			.filter(a => [ 'client_id', 'client_secret', 'redirect_uri' ].includes(a))
			.every(a => tcred[a] === 'string');
	}

	/**
	 * Formats the authentication URL for the credential.
	 *
	 * @param {object} credential - The credential.
	 * @param {object} tcred - The redential types from typeofCredential.
	 * @returns {string} A formatted URL.
	 */
	function formatAuthURL(credential, tcred) {
		const query = {};
		[ 'redirect_uri', 'client_id', 'scope' ]
			.filter(a => tcred[a] === 'string')
			.forEach(a => query[a] = credential[a]);
		query.state = credential.name;
		return `${credential.authentication_url}${credential.authentication_url.indexOf('?') === -1 ? '?' : '&'}response_type=code&${qs.stringify(query)}`;
	}

	// Default redirect_uri
	if (!credential.redirect_uri && config.baseurl && config.callback) {
		credential.redirect_uri = config.baseurl + config.callback;
	}

	// Get the typeof for all credential attrs
	const tcred = CRED_ATTRS.reduce((acc, cur) => {
		acc[cur] = typeofCredential(credential[cur]);
		return acc;
	}, {});

	// Validate the credential
	const has = {
		ValidCredential: validCredential(credential, tcred),
		StaticAccessToken: hasStaticAccessToken(credential, tcred),
		NeedsClient: needsClient(credential, tcred),
		RefreshToken: tcred.refresh_token === 'string',
		AuthUrl: tcred.authentication_url === 'string',
		TokenUrl: tcred.token_url === 'string',
		FlowGrant: tcred.flow === 'string',
		GrantConfig: hasGrantConfig(credential, tcred)
	};

	// Create the formatted authentication url here to allow for customization
	if (has.AuthUrl) {
		credential.formatted_authentication_url = formatAuthURL(credential, tcred);
	}

	// Assume error
	credential.status = status({
		credential: States.credential.none,
		action: States.action.none
	});

	if (has.StaticAccessToken) {
		credential.status = status({
			credential: States.credential.ok,
			action: States.action.none
		});
	} else if (!has.ValidCredential) {
		// intentionally after StaticAccessToken
		const attr = CRED_ATTRS.find(a => tcred[a] === 'undefined');
		throw new Error(`Invalid configuration for credential ${credential.name}. ${attr} is undefined`);
	} else if (has.NeedsClient) {
		credential.status = status({
			credential: States.credential.none,
			action: States.action.needsClient
		});
	} else if (has.GrantConfig) {
		// There is sufficient information for a refresh-token or auth-code grant flow, *except* that
		// authentication_url, token_url, refresh_token, and access_token have not been tested.
		if (!has.TokenUrl) {
			throw new Error(`Invalid configuration for credential ${credential.name}. token_url should be provided`);
		} else if (!has.FlowGrant) {
			throw new Error(`Invalid configuration for credential ${credential.name}. flow grant type "accessCode" should be provided`);
		} else if (!has.RefreshToken && !has.AuthUrl) {
			throw new Error(`Invalid configuration for credential ${credential.name}. refresh_token or authentication_url should be provided`);
		} else if (tcred.access_token === 'null' && !has.RefreshToken) {
			credential.status = status({
				credential: States.credential.none,
				action: States.action.needsAuth
			});
		} else if (tcred.access_token === 'null' && has.RefreshToken) {
			credential.status = status({
				credential: States.credential.none,
				action: States.action.needsRefresh
			});
		} else {
			credential.status = status({
				credential: States.credential.ok,
				action: States.action.none
			});
		}
	} else if (!has.AuthUrl && !has.TokenUrl) {
		throw new Error(`Invalid configuration for credential ${credential.name}. Requires an access_token, or authentication_url and/or token_url should be provided.`);
	}
}

/**
 * Get the access token.
 * @param {object} credential The credential to get the token for.
 * @returns {*} The current access_token.
 */
function token(credential) {
	return credential.access_token || null;
}

/**
 * Refresh the access token.
 * @param {object} credential The managed credential.
 * @returns {Promise} A promise that resolves with the refreshed credential.
 */
function refresh(credential) {
	if (!refreshable(credential)) {
		return Promise.resolve(credential);
	}
	return oauthRefresh(credential);
}

/**
 * Perform the code grant to authorize the credential.
 *
 * @param {object} credential The managed credential.
 * @param {object} options The authorization options.
 * @returns {Promise} A promise that resolves with the authorized credential.
 */
function authorize(credential, options) {
	return oauthCode(credential, options.code);
}

/**
 * Is this credential this
 * @param {object} credential The credential to refresh.
 * @returns {boolean} true if the credential can be refreshed.
 */
function refreshable(credential) {
	return [ 'token_url', 'client_id', 'client_secret', 'redirect_uri', 'refresh_token' ]
		.every(key => credential.hasOwnProperty(key) && typeof credential[key] === 'string')
		&& !(credential.status && credential.status.action === States.action.needsAuth);
}

/**
 * Perform a refresh_token grant to refresh an access_token.
 * @param {object} credential The managed credential.
 * @returns {Promise} A promise that resolves with the new refreshed credential.
 */
function oauthRefresh(credential) {
	return oauthRequest(credential, {
		grant_type: 'refresh_token',
		refresh_token: credential.refresh_token
	});
}

/**
 * Perform a authorization_code grant to redeem a code.
 * @param {object} credential The managed credential the code is being redeemed for.
 * @param {string} code The code to redeem.
 * @returns {Promise} A promise that resolves with the new credential.
 */
function oauthCode(credential, code) {
	return oauthRequest(credential, {
		grant_type: 'authorization_code',
		code
	});
}

/**
 * Perform an oauth credential request and process the result.
 *
 * @param {object} credential The credential the request relates to.
 * @param {object} params The request specific parameters.
 * @returns {Promise} A promise that resolves with the new credential.
 */
function oauthRequest(credential, params) {
	const newCred = JSON.parse(JSON.stringify(credential));

	params = [ 'client_id', 'client_secret', 'redirect_uri' ].reduce((col, cur) => {
		col[cur] = credential[cur];
		return col;
	}, params);

	const opts = {
		method: 'POST',
		uri: credential.token_url,
		headers: {
			'content-type': 'application/x-www-form-urlencoded'
		},
		body: qs.stringify(params)
	};

	return new Promise((resolve, reject) => {
		request(opts,
			(err, response) => {
				if (err) {
					return reject(err);
				} else if (response.statusCode !== 200) {
					return reject(response.body || `${response.statusCode}${response.statusMessage ? ' ' + response.statusMessage : ''}`);
				}

				const respContentType = contentType.parse(response.headers['content-type']);
				if (respContentType.type !== 'application/json') {
					return reject(`Unsupported mime-type: ${response.headers['content-type']}`);
				}
				const respObj = JSON.parse(response.body);
				newCred.access_token = respObj.access_token;
				newCred.expiry = respObj.hasOwnProperty('expires_in') ? Date.now() + (respObj.expires_in * 1000) : null;
				newCred.scope = respObj.scope ? respObj.scope : newCred.scope;
				newCred.refresh_token = respObj.refresh_token ? respObj.refresh_token : newCred.refresh_token;

				newCred.status = newCred.access_token
					? status({ credential: States.credential.ok, action: States.action.none })
					: status(credential.status, { credential: States.credential.none });
				resolve(newCred);
			}
		).on('error', (err) => reject(err));
	});
}

exports = module.exports = {
	initCredential,
	refreshable,
	refresh,
	token,
	authorize
};
