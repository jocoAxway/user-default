const { FlowManager } = require('axway-flow');
const ArrowNode = require('./arrowNode');
const ArrowQueryOptions = require('./arrowqueryoptions');

/**
 * Get the APIs that are supported by the model/connector.
 * @param {APIBuilder} apibuilder - the API Builder instance
 * @param {object} model - the model to generate a spec for
 * @returns {array} array of APIs supported by the model
 */
function _getSupportedAPIs(apibuilder, model) {
	const apis = [];
	const connector = model.connector && typeof model.connector === 'string' ? apibuilder.getConnector(model.connector) : model.connector;

	if (!connector) {
		return apis;
	}

	for (const key in model) {
		// APIBuilder expects the model to advertise it's supported APIs by providing methods that have an
		// API suffix. Here we're using the same logic - any method on Model with an API suffix is a
		// potential API - with some caveats.
		//
		// Models may have custom APIs beyond what is described in Arrow ORM - these are not supported
		// by this node handler and will be ignored. Also the connector must also support all the method
		// dependencies for that API.
		//
		// e.g. Model.findAndModifyAPI advertises the 'findAndModify' from the Model API but as there is
		// a dependsOnAll: ['query', 'create', 'save'] in the API descriptor, the API is only supported
		// if the connector supports 'query, 'create' and 'save' methods.
		//
		if (model[key] && (key.slice(-3) === 'API')) {
			const name = key.slice(0, -3);
			if (model[name] && Object.getPrototypeOf(model).hasOwnProperty(name)) {
				// Check to see if the underlying connector has the necessary methods to support this API.
				const apiDef = model[key]();
				const reqConnectorMethods = apiDef.dependsOnAny || apiDef.dependsOnAll || [ name ];
				const connectorMethods = reqConnectorMethods.filter(method => {
					if (method === 'findByID') {
						// Some connectors use old mappings, to maintain support remap to the standard action.
						return !!connector[method]
							|| !!connector['findById']
							|| !!connector['findOne'];
					}
					return !!connector[method];
				});

				if (connectorMethods.length >= (apiDef.dependsOnAll ? reqConnectorMethods.length : 1)) {
					apis.push(name);
				} else {
					apibuilder.logger && apibuilder.logger.trace && apibuilder.logger.trace(`  unsupported API on Connector: ${name}`);
				}
			} else {
				apibuilder.logger && apibuilder.logger.trace && apibuilder.logger.trace(`  unsupported API on Model: ${name}`);
			}
		}
	}

	return apis;
}

/**
 * Check if the model has an autogenerated primary key.
 * @param {Model} model The model to check.
 * @returns {boolean} true if this Models primary key is autogenerated.
 */
function _isAutoGeneratedPK(model) {
	let autogenerated = true; // Assume it is for legacy reasons
	if (model.metadata && model.metadata.primarykey && model.metadata.hasOwnProperty('primaryKeyDetails')) {
		autogenerated = !!model.metadata.primaryKeyDetails.autogenerated;
	}
	return autogenerated;
}

/**
 * Get the spec for the model method.
 * @param {APIBuilder} apibuilder - the API Builder instance
 * @param {object} model - the model to generate a spec for
 * @param {string} methodName - the name of the method to get a spec for
 * @returns {object} generated node handler spec
 */
function _getMethodSpec(apibuilder, model, methodName) {
	let spec;
	const pkName = model.getPrimaryKeyName();

	switch (methodName) {
		case 'count':
			spec = {
				description: 'Gets a count of records.',
				parameter: {
					type: 'object',
					properties: {
						where: ArrowQueryOptions.where
					},
					additionalProperties: false
				},
				outputs: {
					next: {
						description: `Successfully counted records of ${model.name}.`,
						context: '$.count',
						schema: {
							type: 'number'
						}
					}
				}
			};
			break;
		case 'create':
			spec = {
				description: 'Creates a new model object.',
				parameter: {
					type: 'object',
					properties: {
						data: {
							$ref: _isAutoGeneratedPK(model) ? apibuilder.getModelSchemaId(model) : apibuilder.getModelSchemaFullId(model)
						}
					},
					additionalProperties: false,
					required: [ 'data' ]
				},
				outputs: {
					next: {
						description: `Successfully created a ${model.name}.`,
						context: '$.created',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					}
				}
			};
			break;
		case 'delete':
			spec = {
				description: 'Deletes the model object.',
				parameter: {
					type: 'object',
					properties: {
						[pkName]: {
							type: model.getPrimaryKeyType()
						}
					},
					required: [ pkName ],
					additionalProperties: false
				},
				outputs: {
					next: {
						description: `Successfully deleted the ${model.name}.`,
						context: '$.deleted',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					notfound: {
						description: 'No model instance found.'
					}
				}
			};
			break;
		case 'deleteAll':
			spec = {
				description: 'Deletes all the model objects.',
				parameter: {
					properties: {},
					additionalProperties: false
				},
				outputs: {
					next: {
						description: `Successfully deleted all the ${model.name}.`,
						context: '$.deletedAll',
						schema: {
							type: 'array',
							items: {
								$ref: apibuilder.getModelSchemaFullId(model)
							}
						}
					}
				}
			};
			break;
		case 'distinct':
			const distinctOpts =  { ...ArrowQueryOptions };
			delete distinctOpts.sel;
			delete distinctOpts.unsel;
			spec = {
				description: 'Finds unique values using the provided field.',
				parameter: {
					type: 'object',
					properties: {
						...distinctOpts,
						field: {
							type: 'string',
							description: 'The field that must be distinct.',
							enum: pkName ? [ pkName, ...Object.keys(model.fields) ] : Object.keys(model.fields)
						}
					},
					required: [ 'field' ],
					additionalProperties: false
				},
				outputs: {
					next: {
						description: `Successfully found all unique values of ${model.name}.`,
						context: '$.distinct',
						schema: {
							type: 'array',
							items: {
								$ref: apibuilder.getModelSchemaFullId(model)
							}
						}
					}
				}
			};
			delete spec.parameter.properties.sel;
			delete spec.parameter.properties.unsel;
			break;
		case 'findAll':
			spec = {
				description: 'Finds all model instances.',
				parameter: {
					properties: {},
					additionalProperties: false
				},
				outputs: {
					next: {
						description: `Successfully found all ${model.name}.`,
						context: '$.foundAll',
						schema: {
							type: 'array',
							items: {
								$ref: apibuilder.getModelSchemaFullId(model)
							}
						}
					}
				}
			};
			break;
		case 'findAndModify':
			spec = {
				description: 'Modifies a single instance. Although the query may match multiple instances, only the first one will be modified.',
				parameter: {
					type: 'object',
					properties: {
						...ArrowQueryOptions,
						args: {
							type: 'object',
							description: 'Optional parameters.',
							properties: {
								new: {
									type: 'boolean',
									description: 'Set to true to return the new model instead of the original model.'
								},
								upsert: {
									type: 'boolean',
									description: 'Set to true to allow the method to create a new model.'
								}
							}
						},
						data: {
							$ref: apibuilder.getModelSchemaId(model)
						}
					},
					required: [ 'data' ],
					additionalProperties: false
				},
				outputs: {
					next: {
						description: `Successfully found and modified ${model.name}.`,
						context: '$.foundAndModified',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					notfound: {
						description: 'No matching model found.'
					}

				}
			};
			break;
		case 'findByID':
			spec = {
				description: 'Finds model instance by ID.',
				parameter: {
					type: 'object',
					properties: {
						[pkName]: {
							type: model.getPrimaryKeyType()
						}
					},
					required: [ pkName ],
					additionalProperties: false
				},
				outputs: {
					next: {
						description: `Successfully found instance of ${model.name} by ID.`,
						context: '$.foundByID',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					notfound: {
						description: 'No model instance found.'
					}
				}
			};
			break;
		case 'query':
			spec = {
				description: 'Queries for particular model records.',
				parameter: {
					type: 'object',
					properties: {
						...ArrowQueryOptions
					},
					additionalProperties: false
				},
				outputs: {
					next: {
						description: `Successfully queried the ${model.name}.`,
						context: '$.queried',
						schema: {
							type: 'array',
							items: {
								$ref: apibuilder.getModelSchemaFullId(model)
							}
						}
					}
				}
			};
			break;
		case 'update':
			spec = {
				description: 'Updates a model instance.',
				parameter: {
					type: 'object',
					properties: {
						[pkName]: {
							type: model.getPrimaryKeyType()
						},
						data: {
							$ref: apibuilder.getModelSchemaId(model)
						}
					},
					required: [ pkName, 'data' ],
					additionalProperties: false
				},
				outputs: {
					next: {
						description: `Successfully updated the ${model.name}.`,
						context: '$.updated',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					notfound: {
						description: 'No model instance found.'
					}
				}
			};
			break;
		case 'upsert':
			spec = {
				description: 'Creates a model record if not found, or updates the model record if found.',
				parameter: {
					type: 'object',
					properties: {
						data: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					required: [ 'data' ],
					additionalProperties: false
				},
				outputs: {
					update: {
						description: 'Successfully updated the model.',
						context: '$.model',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					},
					insert: {
						description: 'Successfully inserted the model.',
						context: '$.model',
						schema: {
							$ref: apibuilder.getModelSchemaFullId(model)
						}
					}
				}
			};
			break;
		default:
			spec = null;
	}
	return spec;
}

/**
 * Returns the schema function for the model specific node handler.
 * @param {APIBuilder} apibuilder - the API Builder instance
 * @param {object} model - the model to generate a spec for
 * @returns {object} generated node handler spec
 */
const getSpec = (apibuilder, model) => {
	apibuilder.logger && apibuilder.logger.trace && apibuilder.logger.trace(`Generating Model spec for ${model.name}`);
	// Remove the connector prefix from the name.
	let name;
	const connector = model.connector;
	const connectorName = (connector && typeof connector === 'object') ? connector.name : connector;
	if (model.name.startsWith(connectorName)) {
		name = model.name.substring(connectorName.length + 1);
	} else {
		name = model.name;
	}

	const handlerSpec = {
		schemaVersion: '1',
		type: FlowManager.formatNodeHandlerUri('api-builder-flow-invoke', `model/${model.name}`),
		name,
		icon: 'icon-GG-cube',
		category: 'Model',
		methods: {
		}
	};

	const supportedAPIs = _getSupportedAPIs(apibuilder, model);
	supportedAPIs.forEach((methodName) => {
		const spec = _getMethodSpec(apibuilder, model, methodName);
		if (!spec) {
			apibuilder.logger && apibuilder.logger.trace && apibuilder.logger.trace(`  unsupported Model method: ${methodName}`);
		} else {
			apibuilder.logger && apibuilder.logger.trace && apibuilder.logger.trace(`  adding Model method to spec: ${methodName}`);
			handlerSpec.methods[methodName] = spec;
		}
	});
	return handlerSpec;
};

class ArrowModelNode extends ArrowNode {
	constructor(apibuilder, model, name, node, spec, flow) {
		super(apibuilder, name, node, spec, flow);
		this.model = model;
		this.primaryKey = model ? model.getPrimaryKeyName() : null;
	}

	/**
	 * Objectify the model response - convert it from a model to a
	 * plain object.
	 * @private
	 * @param {function} cb - The callback function to objectify.
	 * @returns {function} - The wrapped callback that does the conversion.
	 */
	_objectify(cb) {
		const objectify = (value) => {
			if (!value) {
				return;
			}
			// Using the array prototype to avoid the ArrowOrm collection overrides.
			return Array.isArray(value)
				? Array.prototype.map.call(value, (v) => JSON.parse(JSON.stringify(v)))
				: JSON.parse(JSON.stringify(value));
		};

		return (err, result) => cb(err, objectify(result));
	}

	count(req, cb) {
		this.model.count(req.params, cb.next);
	}

	create(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.create(req.params.data, cb.next);
	}

	delete(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.delete(req.params[this.primaryKey], (err, result) => {
			// Not great but ORM layer doesn't just return null when not found
			if (err && err.match
					&& err.match(/^trying to remove, couldn't find record with primary key:/)) {
				cb.notfound();
			} else {
				cb.next(err, result);
			}
		});
	}

	deleteAll(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.deleteAll(cb.next);
	}

	distinct(req, cb) {
		cb.next = this._objectify(cb.next);
		const field = req.params.field;
		delete req.params.field;
		this.model.distinct(field, req.params, cb.next);
	}

	findAll(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.findAll(cb.next);
	}

	findAndModify(req, cb) {
		cb.next = this._objectify(cb.next);
		const args = req.params.args || {};
		const model = req.params.data;
		delete req.params.args;
		delete req.params.data;
		this.model.findAndModify(req.params, model, args, (err, modified) => {
			if (modified) {
				cb.next(err, modified);
			} else {
				cb.notfound(err);
			}
		});
	}

	findByID(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.findByID(req.params[this.primaryKey], (err, result) => {
			if (result) {
				cb.next(err, result);
			} else {
				cb.notfound(err);
			}
		});
	}

	query(req, cb) {
		cb.next = this._objectify(cb.next);
		this.model.query(req.params, (err, result) => {
			cb.next(err, result || []);
		});
	}

	update(req, cb) {
		cb.next = this._objectify(cb.next);
		const data = Object.assign({}, req.params.data, { [this.primaryKey]: req.params[this.primaryKey] });
		this.model.update(data, (err, result) => {
			// Not great but ORM layer doesn't just return null when not found
			if (err && err.match
					&& err.match(/^trying to update, couldn't find record with primary key:/)) {
				cb.notfound();
			} else {
				cb.next(err, result);
			}
		});
	}

	upsert(req, cb) {
		cb.update = this._objectify(cb.update);
		cb.insert = this._objectify(cb.insert);
		if (!req.params.data || !req.params.data.hasOwnProperty(this.primaryKey)) {
			cb({ error: `missing required parameter: ${this.primaryKey}` });
			return;
		}

		const modelData = req.params.data;
		const id = modelData[this.primaryKey];

		// Upsert is expected to differentiate between new and update
		// the model upsert doesn't so do it manually.
		this.model.findByID(id, (err, result) => {
			if (err) {
				cb(err);
				return;
			}

			const update = !!result;

			this.model.upsert(id, modelData, (upsertErr, model) => {
				if (update) {
					cb.update(upsertErr, model);
				} else {
					cb.insert(upsertErr, model);
				}
			});
		});
	}
}

exports = module.exports = {
	handler: ArrowModelNode,
	spec: getSpec
};
