const fs = require('fs');
const path = require('path');
const events = require('events');
const chalk = require('chalk');
const parseJson = require('parse-json');
const schemas = require('axway-schema');
const consoleLogger = require('./logger');
const Flow = require('./flow');
const UpgradeManager = require('./upgrademanager');
const noderegistry = require('./noderegistry');

/**
 * Formats a node handler URI.  URI are lower-case.  The `module` must be alpha-numeric, including
 * dash, dot, underscore and forward slash.
 * @private
 * @param {string} module - A module name for scope, e.g. "twilio".
 * @param {string} type - A simple URL safe type name, e.g. "echo".
 * @returns {string} node handler URI
 */
function formatNodeHandlerUri(module, type) {
	// NOTE: this function should be the same as: nodehandler-utils/src/index.js
	if (!module) {
		throw new Error('Invalid argument: module');
	}
	if (!type) {
		throw new Error('Invalid argument: type');
	}
	return `nodehandler://${module}/${type}`;
}

/**
 * The Flow manager.
 * @public
 * @class
 */
class FlowManager extends events.EventEmitter {
	/**
	 * Create a server.
	 * @constructor
	 * @param {object} logger - The internal logger to use.
	 * @param {object} credentialManager - The credential manager to use
	 */
	constructor(logger, credentialManager) {
		super();
		this.cache = {};
		this.setLogger(logger);
		this.setCredentialManager(credentialManager);
		const upgradeDir = path.join(__dirname, 'upgrades');
		if (fs.existsSync(upgradeDir)) {
			this.upgrades = require(upgradeDir);
		} else {
			this.upgrades = {};
		}

		// TODO: [RDPP-1687] Handle flow versioning/schema validation better
		this.upgrademanager = new UpgradeManager(this.logger);
		// Register 'flow' as an upgrade type and all it's accessors
		this.upgrademanager.registerUpgradeType('flow', {
			getId: (flow, flowPath) => {
				return path.basename(flowPath, path.extname(flowPath));
			},
			getVersion: (flow) => {
				return flow.schemaVersion;
			},
			setVersion: (flow, newVersion) => {
				flow.schemaVersion = newVersion;
				return flow;
			}
		}, this.validate);
		this.upgrademanager.registerUpgrades(this.upgrades);
	}

	/**
	 * Sets the logger.  Set to `null` to use the default logger.
	 * @public
	 * @param {object} logger - The internal logger to use.
	 */
	setLogger(logger) {
		this.logger = logger || consoleLogger;
	}

	/**
	 * Sets the credential manager
	 * @param {object} credentialManager - The credential manager to use
	 */
	setCredentialManager(credentialManager) {
		if (credentialManager) {
			this.credentialManager = credentialManager;
		}
	}

	/**
	 * Formats a node handler URI.  URI are lower-case.
	 * @public
	 * @param {string} module - A module name for scope, e.g. "twilio".
	 * @param {string} type - A simple URL safe type name, e.g. "echo".
	 * @returns {string} formatted node handler URI
	 */
	formatNodeHandlerUri(module, type) {
		return formatNodeHandlerUri(module, type);
	}

	/**
	 * Registers upgrades for the flow
	 * @param {array} upgrades - array of upgrades to register with the flow upgrade manager
	 */
	registerUpgrades(upgrades) {
		this.upgrademanager.registerUpgrades(upgrades);
	}

	/**
	 * Unregisters upgrades which have been previously registered for the flow
	 * @param {array} upgrades - array of upgrades to unregister from the flow upgrade manager
	 */
	unregisterUpgrades(upgrades) {
		this.upgrademanager.unregisterUpgrades(upgrades);
	}

	/**
	 * Register a node handler.
	 * @public
	 * @param {string} uri - The unique uri of the node the handler to unregister
	 *						 (see `formatNodeHandlerUri`).
	 * @param {FlowNode} handler - The handler implementation.
	 * @param {function} getHandlerSpec - A function to return the node handler definition.
	 */
	registerNode(uri, handler, getHandlerSpec) {
		this.logger.debug(`Registering flow-node: ${uri}`);

		// Validate the schema for the node handler.  The handler should have all its
		// dependencies met before registration (e.g. code blocks registered).
		const spec = getHandlerSpec && getHandlerSpec();
		if (spec) {
			this.logger.debug(`Validating spec for: ${uri}`);
			const error = schemas.validate('http://axway.com/schemas/flownode.json', spec);
			if (error) {
				throw new Error(`Unable to register flow-node: '${uri}'. ${error}`);
			}
		}
		noderegistry.registerNode(uri, handler, spec);
	}

	/**
	 * Unregister a node handler.
	 * @public
	 * @param {string} uri - The unique uri of the node the handler to unregister
	 *						 (see `formatNodeHandlerUri`).
	 */
	unregisterNode(uri) {
		this.logger.debug(`Unregistering flow-node: ${uri}`);
		noderegistry.unregisterNode(uri);
	}

	/**
	 * Gets a registered node handler.
	 * @public
	 * @param {string} type - The type of the node the handler to get.
	 * @return {FlowNode} The node handler.
	 */
	getRegisteredNode(type) {
		return noderegistry.getRegisteredNode(type);
	}

	/**
	 * Gets the node handler spec for a registered node.
	 * @public
	 * @param {string} type - The type of the node the handler specification to get.
	 * @return {object} The node handler spec.
	 */
	getRegisteredNodeSpec(type) {
		return noderegistry.getNodeSpec(type);
	}

	/**
	 * Gets all of the available node handler specs.
	 * @public
	 * @returns {object|array} The node handler specs.
	 */
	getRegisteredNodeSpecs() {
		return noderegistry.getNodeSpecs();
	}

	/**
	 * Return a map of the flow definitions by id.
	 * @public
	 * @returns {Object} A map of flow definitions by id.
	 */
	getFlows() {
		return Object.keys(this.cache).reduce(
			(prev, cur) => {
				prev[cur] = this.cache[cur].flow;
				return prev;
			},
			{}
		);
	}

	/**
	 * Return the flow definition.
	 * @public
	 * @param {string} flowId - The flow to execute.
	 * @returns {Object} The flow definition.
	 */
	getFlow(flowId) {
		return this.cache && this.cache[flowId] && this.cache[flowId].flow;
	}

	/**
	 * Exceute the flow.
	 * @public
	 * @param {string} flowId - The flow to execute.
	 * @param {object} data - The data to execute the flow with.
	 * @param {object} [options] - options - The flow runtime options.
	 * @param {object} [options.logger] - The logger to use for the flow execution.
	 *		Uses the constructor default if not supplied.
	 * @param {object} [options.validateFlowParameter=true] - Validates `data` against flow input parameter.
	 * @returns {Promise} A promise that will be resolved with the final context when the
	 *		flow execution completes.
	 */
	flow(flowId, data, options = {}) {
		const reqlog = (options && options.logger) || this.logger;
		if (!this.cache || !this.cache[flowId]) {
			reqlog.error(`Flow not found: ${flowId}`);
			throw Error(`Flow not found: ${flowId}`);
		}
		this.emit('preflow', flowId, data);
		reqlog.debug(chalk.dim(`Invoking: ${flowId}`));

		const promise = this.cache[flowId].invoke(data, options);
		this.emit('postflow', flowId, data, promise);
		return promise;
	}

	/**
	 * Load the flow.
	 * @public
	 * @param {string} flowPath - The path to the flow json definition.
	 * @param {object} options - Options for the upgrade loader.
	 * @param {boolean} options.save - Enable to save the upgraded file  (default: false)
	 * @returns {Promise} A promise that when resolved contains the loaded flow.
	 */
	load(flowPath, options) {
		return new Promise((resolve, reject) => {
			fs.readFile(flowPath, (err, data) => {
				if (err) {
					return reject(err);
				}

				const id = path.basename(flowPath, path.extname(flowPath));

				let flow;
				try {
					flow = parseJson(data.toString(), flowPath);
				} catch (ex) {
					return reject(new Error(`Unable to load flow ${id}. ${ex.message}`));
				}

				// validate the flow
				this.validate(flow)
					.catch(error => {
						if (error instanceof Error) {
							return Promise.reject(new Error(`Unable to load flow ${id}. Syntax error in flow: ${flowPath}: ${error.message}`));
						}
						return Promise.reject(error);
					})
					.then(() => {
						// Flow is validated. Upgrade it if needed.
						return this.upgrademanager.upgradeFlow(flow, flowPath, options);
					})
					.then((upgradedFlow) => {
						// Flow is now the latest version. Add it to the cache.
						return Promise.resolve(this._addFlow(id, upgradedFlow));
					})
					.then(resolve, reject);
			});
		});
	}

	/**
	 * Runs schema validation on a flow definition
	 *
	 * @param {object} flowDef - The flow definition to validate
	 * @param {object} opts - validation options
	 * @returns {Promise} Will reject with validation errors if any are found
	 */
	validate(flowDef, opts = { graph: false, schema: true }) {
		// Validate
		return new Promise((resolve, reject) => {
			if (opts.graph) {
				const flow = new Flow(null, flowDef, {
					logger: this.logger,
					credentialManager: this.credentialManager
				});
				const graphValidation = flow.getValidation();
				if (!graphValidation.valid) {
					return reject(graphValidation);
				}
			}

			if (opts.schema) {
				let validation = schemas.validate('http://axway.com/schemas/flow.json', flowDef);
				if (validation) {
					// parse the validation error
					validation = this._parseValidation(validation);
					return reject(validation);
				}
			}

			return resolve();
		});
	}

	/**
	 * Convert known schema validation error string into something a bit more consumable
	 *
	 * @param {string} validation - schema validation
	 * @param {object} flowDef - flow definition
	 * @returns {object} validation Error or object describing validation error
	 */
	_parseValidation(validation) {
		if (/\$\.start should be string/.test(validation)) {
			return {
				valid: false,
				errors: [{
					code: 'INVALID_NODE',
					type: 'invalidStart'
				}]
			};
		}
		return new Error(validation);
	}

	/**
	 * Add a flow to the cache.
	 * @private
	 * @param {string} flowId - The id for the flow.
	 * @param {object} flowDef - The flow definition.
	 * @returns {object} flow - the flow
	 */
	_addFlow(flowId, flowDef) {
		this.cache = this.cache || {};
		const flow = this.cache[flowId] = new Flow(flowId, flowDef, {
			logger: this.logger,
			credentialManager: this.credentialManager
		});
		if (flow.getValidation().valid) {
			this.emit('loaded', flow);
		} else {
			this.logger.error(`Invalid flow ${flowId}: ${JSON.stringify(flow.getValidation(), null, 2)}`);
			this.emit('invalidflow', flow);
		}
		return flow;
	}
}

// convenience 'static' method
FlowManager.formatNodeHandlerUri = formatNodeHandlerUri;
exports = module.exports = FlowManager;
