const getByJsonPath = require('./jsonpath').getByJsonPath;
const chalk = require('chalk');
const { formatNodeName, scopeNodeLogger } = require('./utils');

class FlowNode {
	constructor(id, node, spec, flow) {
		this.node = node || {};
		this.id = id;
		this.spec = spec;
		this.flow = flow;
		this.title = new.target;
		if (new.target === FlowNode) {
			throw new TypeError('Cannot construct FlowNode instances directly.');
		}
	}

	/**
	 * Gets the action method information.
	 * @private
	 * @return {object} The method.
	 */
	_getActionMethod() {
		const methodNames = Object.keys(this.spec.methods);
		// note: spec does not allow 0 methods, so it exists
		if (methodNames.length > 1) {
			// If a node has more than one method, then `config.method` is required.
			if (!this.node.method) {
				throw new Error(`expected method config for node: ${this.id}`);
			}
		}

		const methodIdx = methodNames.indexOf(this.node.method);
		if (methodIdx < 0) {
			throw new Error(`node '${this.id}' is configured to use an unknown method: ${this.node.method}`);
		}
		const name = methodNames[methodIdx];
		const action = this[name];
		if (!action) {
			throw new Error(`expected handler for node '${this.id}' to have function named: ${name}`);
		}
		return {
			name,
			spec: this.spec,
			method: this.spec.methods[name],
			action: action.bind(this)
		};
	}

	/**
	 * Iterates over parameters specified by the flow-node `location` and resolves them against the runtime `ctx`.
	 * @param {object} ctx - The runtime context.
	 * @param {string} location - The flow-node parameter location to resolve.  One of: authorizations, parameters.
	 * @return {object} The params object.
	 */
	_resolveInputs(ctx, location) {
		let params = null;
		this.node[location] && this.node[location].forEach(param => {
			params = params || {};
			let val = param.value;

			if (param.type === 'credential') {
				// resolve the credential via the manager
				val = this.flow.credentialManager && this.flow.credentialManager.getCredential
					&& this.flow.credentialManager.getCredential(param.value);
			} else if (param.type === undefined || param.type === 'jsonpath') {
				val = getByJsonPath(val, ctx.data);
			} else {
				try {
					val = JSON.parse(val);
				} catch (e) {
					val = undefined;
				}
			}

			// if value is undefined, do not assign to params - it does not resolve.
			if (val !== undefined) {
				params[param.name] = val;
			}

			// useful for debugging parameters:
			if (param.type === undefined || param.type === 'jsonpath') {
				ctx.runtime && ctx.runtime.logger
					&& ctx.runtime.logger.trace(
						chalk.dim(`  resolved selector ${param.value} for '${param.name}' as ${JSON.stringify(params[param.name])} in ${location}`));
			} else {
				ctx.runtime && ctx.runtime.logger
					&& ctx.runtime.logger.trace(
						chalk.dim(`  resolved '${param.name}' as ${JSON.stringify(params[param.name])} in ${location}`));
			}
		});
		return params;
	}

	/**
	 * Set up the callbacks.
	 * @param {object} actionMethod - the method to generate callback for
	 * @param {function} cb - the callback to bind outputs to
	 * @returns {object|function} the generated output callback
	 */
	curryOutputCallbacks(actionMethod, cb) {
		const self = this;
		const outputKeys = Object.keys(actionMethod.method.outputs);
		let outputCallback;

		// Set the default cb(err, result) target. This is required for upgrade where
		// existing nodehandlers may be unaware of the outputs and for handlers that have
		// no outputs.
		if (!outputKeys.length) {
			// No ouputs defined - callback is for completion only
			outputCallback = (err) => cb(null, err);
		} else if (outputKeys.length === 1) {
			// There's only one output, it's the de-facto default
			outputCallback = (err, result) => cb(outputKeys[0], err, result);
		} else {
			// Get default as defined in the spec.
			const defaultOutput
				= outputKeys.find((output) => actionMethod.method.outputs[output].hasOwnProperty('default') && actionMethod.method.outputs[output].default)
				|| outputKeys[0];
			outputCallback = (err, result) => cb(defaultOutput, err, result);
		}

		// Curry the callback with the known possible outputs. So you can do:
		// cb.<output>(<err>, <result>)
		outputCallback = outputKeys.reduce(
			(col, cur) => {
				col[cur] = cb.bind(self, cur);
				return col;
			},
			outputCallback
		);

		return outputCallback;
	}

	_getDisplayName(node) {
		return formatNodeName(node);
	}

	invoke(ctx) {
		const promise = new Promise((resolve, reject) => {
			const callback = (output, err, results) => {
				if (err) {
					ctx.runtime && ctx.runtime.logger
						&& ctx.runtime.logger.trace(`${this._getDisplayName(this)} rejected.`);
					return reject(err);
				}
				ctx.runtime && ctx.runtime.logger
					&& ctx.runtime.logger.trace(`${this._getDisplayName(this)} ${output} resolved.`);
				return resolve({ results, output });
			};

			try {
				const input = {
					authorizations: this._resolveInputs(ctx, 'authorizations'),
					params: this._resolveInputs(ctx, 'parameters')
				};

				const actionMethod = this._getActionMethod();
				const callbacks = this.curryOutputCallbacks(actionMethod, callback);

				const runtimeLogger = ctx.runtime && ctx.runtime.logger;

				const actionOptions = {};
				if (runtimeLogger) {
					const scopeOptions = {
						reqId: ctx && ctx.data && ctx.data.request && ctx.data.request._reqid,
						nodeId: this.id,
						methodName: actionMethod && actionMethod.name
					};

					actionOptions.logger = scopeNodeLogger(runtimeLogger, scopeOptions);
				}

				actionMethod.action(input, callbacks, actionOptions);
			} catch (err) {
				ctx.runtime && ctx.runtime.logger
					&& ctx.runtime.logger.trace(`${this._getDisplayName(this)} rejected: ${err}`);
				reject(err);
			}
		});

		return promise;
	}
}

exports = module.exports = FlowNode;
