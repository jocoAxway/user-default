const FlowGraph = require('axway-flow-graph');
const schemas = require('axway-schema');

/**
 * Helper for validating flows. The validation checks for:
 * - no cyclical loops
 * - no undefined nodes in the routing
 *
 * @private
 * @class
 */
class FlowValidator extends FlowGraph.Validator {
	/**
	 * Check that the flow node handlers are valid.
 	 *
 	 * @private
 	 * @param {object} validationData - The object to add the validation errors to.
 	 * @returns {boolean} true if there are invalid nodes detected.
 	 */
	checkNodeHandlers(validationData) {
		this.flowGraph.getNodeHandlers().forEach(handler => {
			if (handler.spec.hasOwnProperty('deprecated') && handler.spec.deprecated) {
				this._addValidationWarning(validationData, {
					type: 'deprecatedNodeHandler',
					code: 'DEPRECATED',
					detail: {
						node: handler.id,
						nodehandler: handler.spec.type
					}
				});
			}
		});
		// only warnings here
		return false;
	}

	checkNodeParameters(validationData) {
		let invalid = false;
		this.flowGraph.getNodes(true).forEach(nodeId => {
			invalid |= this._checkNodeParam('parameters', nodeId, validationData);
			invalid |= this._checkNodeParam('authorizations', nodeId, validationData);
		});
		return invalid;
	}

	_getNodeDetailsById(nodeId, location) {
		const node = this.flowGraph.getNode(nodeId);
		const spec = this.flowGraph.getNodeSpec(node);
		const methodExists = spec && spec.methods && spec.methods[node.method];
		if (location === 'parameters') {
			return {
				specParams: methodExists && spec.methods[node.method].parameter,
				type: 'invalidNodeParameter',
				parameters: node.parameters || [],
				methodExists
			};
		} else if (location === 'authorizations') {
			return {
				specParams: methodExists && spec.methods[node.method].authorization,
				type: 'invalidNodeAuthorization',
				parameters: node.authorizations || [],
				methodExists
			};
		}
	}

	_checkNodeParam(location, nodeId, validationData) {
		let invalid = false;
		const { specParams, type, parameters, methodExists } = this._getNodeDetailsById(nodeId, location);
		const schemaTypeMap = {
			string: 'string',
			boolean: 'boolean',
			integer: 'number',
			number: 'number',
			object: 'object',
			array: 'array',
			null: 'null'
		};
		if (!methodExists) {
			return;
		}
		// Check that all required parameters are accounted for
		if (specParams && specParams.required && specParams.required.length) {
			specParams.required.forEach(param => {
				if (!parameters.length || !parameters.some(nodeParam => {
					return nodeParam && nodeParam.name === param;
				})) {
					invalid = true;
					this._addValidationError(validationData, {
						type,
						code: 'MISSING_VALUE',
						detail: {
							node: nodeId,
							parameter: param
						}
					});
				}
			});
		}

		parameters.forEach((param) => {
			let specParam = specParams && specParams.properties && specParams.properties[param.name];
			let skipSchemaValidation = false;

			// un-spec'd params aren't allowed
			if (!specParam) {
				invalid = true;
				this._addValidationError(validationData, {
					type,
					code: 'NOT_IN_SPEC',
					detail: {
						node: nodeId,
						parameter: param.name
					}
				});
				return;
			}

			// Deref top level if needed
			if (!specParam) {
				skipSchemaValidation = true;
			} else if (specParam && specParam.$ref) {
				const ref = schemas.get(specParam.$ref);
				if (Array.isArray(ref) || !ref) { // ref was not found
					skipSchemaValidation = true;
				} else {
					specParam = ref;
				}
			} else {
				try {
					specParam = schemas.dereference(specParam);
				} catch (e) {
					skipSchemaValidation = true;
				}
			}

			// Is parameter type correct?
			if (specParam && specParam.type && param.type && param.type !== 'credential' && param.type !== 'jsonpath') {
				// JSON schema type could be an array...
				const types = Array.isArray(specParam.type) ? specParam.type : [ specParam.type ];
				// map each schema type to flow param type and dedupe
				const knownTypes = types.filter(type => schemaTypeMap[type]);
				const expectedTypes = [ ...new Set(knownTypes.map(type => schemaTypeMap[type])) ];
				expectedTypes.push('jsonpath'); // it's not going to be jsonpath but it's an expected type.
				expectedTypes.push('credential');
				if (!expectedTypes.includes(param.type)) {
					invalid = true;
					this._addValidationError(validationData, {
						type,
						code: 'INVALID_TYPE',
						detail: {
							node: nodeId,
							parameter: param.name,
							expectedTypes
						}
					});
					return;
				}
			}

			// Is parameter data parseable to specified type?
			if (param.type && param.type !== 'jsonpath' && param.type !== 'credential' && specParam) {
				let value = null;
				const data = value = this._parseParamValue(param);
				if (data.error) {
					invalid = true;
					this._addValidationError(validationData, {
						type,
						code: data.error,
						detail: {
							node: nodeId,
							parameter: param.name
						}
					});
					return;
				}

				// Does non-jsonpath type parameter validate against spec schema?
				if (!skipSchemaValidation) {
					const validate = schemas.ajv.compile(specParam);
					const valid = validate(value.data);
					if (!valid) {
						invalid = true;
						this._addValidationError(validationData, {
							type,
							code: 'INVALID_VALUE',
							detail: {
								node: nodeId,
								parameter: param.name,
								errors: validate.errors
							}
						});
					}
				}
			} else {
				// Check if the jsonpath/credential param is valid
				const data = this._parseParamValue(param);
				if (data.error) {
					invalid = true;
					this._addValidationError(validationData, {
						type,
						code: data.error,
						detail: {
							node: nodeId,
							parameter: param.name
						}
					});
				}
			}
		});

		return invalid;
	}

	/**
	 * Check that the flow nodes have all the defined outputs.
 	 *
 	 * @private
 	 * @param {object} validationData - The object to add the validation errors to.
 	 * @returns {boolean} true if there are invalid nodes detected.
 	 */
	checkNodeOutputs(validationData) {
		let invalid = false;
		this.flowGraph.getNodes(true).forEach(nodeId => {
			const node = this.flowGraph.getNode(nodeId);
			const nodeOutputs = Object.keys(node.outputs);

			const spec = this.flowGraph.getNodeSpec(node);
			const specOutputs = spec && spec.methods
				&& spec.methods[node.method] && spec.methods[node.method].outputs
				&& Object.keys(spec.methods[node.method].outputs);

			if (specOutputs) {
				const missingOutputs = specOutputs.filter(o => nodeOutputs.indexOf(o) === -1);
				const unknownOutputs = nodeOutputs.filter(o => specOutputs.indexOf(o) === -1);
				if (missingOutputs.length) {
					missingOutputs.forEach(missingOutput => {
						invalid = true;
						this._addValidationError(validationData, {
							type: 'invalidNodeOutput',
							code: 'MISSING_KEY',
							detail: {
								output: missingOutput,
								node: nodeId
							}
						});
					});
				}
				if (unknownOutputs.length) {
					invalid = true;
					unknownOutputs.forEach(unknownOutput => {
						this._addValidationError(validationData, {
							type: 'invalidNodeOutput',
							code: 'NOT_IN_SPEC',
							detail: {
								output: unknownOutput,
								node: nodeId
							}
						});
					});
				}
			}
		});
		return invalid;
	}

	/**
	 * Check that each node's method is registered with the corresponding node handler
	 * @param  {object} validationData - The object containing validation errors
	 * @return {bool} true if there are invalid methods detected
	 */
	checkNodeMethods(validationData) {
		let invalid = false;
		this.flowGraph.getNodes(true).forEach(nodeId => {
			const node = this.flowGraph.getNode(nodeId);
			const method = node.method || '';
			const spec = this.flowGraph.getNodeSpec(node);
			if (!spec.methods[method]) {
				invalid = true;
				this._addValidationError(validationData, {
					type: 'invalidMethod',
					code: 'INVALID_VALUE',
					detail: {
						node: nodeId,
						method
					}
				});
			}
		});
		return invalid;
	}

	/**
	 * Run all checks on the flow and report any validation errors.
	 * @returns {object} validationData object
 	 */
	validate() {
		const validationData = super.validate();
		this.checkNodeHandlers(validationData);
		this.checkNodeOutputs(validationData);
		this.checkNodeMethods(validationData);
		this.checkNodeParameters(validationData);
		return validationData;
	}

	/**
	 * Log a deprecation warning.
	 * @param {object} handler - node handler to log deprecation for
	 */
	logDeprecation(handler) {
		if (handler.spec.hasOwnProperty('deprecated')) {
			let message;
			if (typeof handler.spec.deprecated === 'string') {
				message = handler.spec.deprecated;
			} else if (typeof handler.spec.deprecated === 'object') {
				// Internationalized message - just display them all
				message = Object.keys(handler.spec.deprecated).reduce(
					(col, lang) => `${col}[${lang}: ${handler.spec.deprecated[lang]}]`, ''
				);
			} else if (typeof handler.spec.deprecated === 'boolean') {
				message = `${handler.spec.type} has been deprecated, please upgrade your flow.`;
			}

			this.flowGraph.logger.warn(`${handler.flow.id}[${handler.id}]: ${message}`);
		}
	}
}

exports = module.exports = FlowValidator;
