const chalk = require('chalk');
const consoleLogger = require('./logger');
const noderegistry = require('./noderegistry');
const jsonpath = require('@livereach/jsonpath');
const FlowGraph = require('axway-flow-graph');
const schemas = require('axway-schema');
const FlowValidator = require('./flowvalidator');
let { formatNodeName } = require('./utils');

/**
 * An invokable Flow.
 * @public
 * @class
 */
class Flow extends FlowGraph {
	/**
	 * Create a flow.
	 * @constructor
	 * @param {string} flowId - The id of this flow.
	 * @param {object} flowdef - The flow definition.
	 * @param {options} options - Additional options contains logger and credentialManager
	 */
	constructor(flowId, flowdef, options) {
		super(flowId, flowdef);
		if (!options) {
			options = {};
		}
		const { logger, credentialManager } = options;
		this.logger = logger || consoleLogger;
		if (credentialManager) {
			this.credentialManager = credentialManager;
		}

		this._InstantiateNodeHandlers();
		this.registerValidator(FlowValidator);
		this.validate();
	}

	/**
	 * Validate the runtime parameter data
	 * @param {object} data - The initial data to execute the flow with.
	 * @param {object} [options] - options - The flow runtime options.
	 * @param {object} [options.validateFlowParameter=true] - Validates `data` against flow input parameter.
	 * @returns {object} A validation object.
	 */
	getRuntimeValidation(data, options) {
		let validateFlowParameter = true;
		if (options && options.validateFlowParameter !== undefined) {
			validateFlowParameter = options.validateFlowParameter;
		}
		if (validateFlowParameter && this.flow.parameter) {
			const error = schemas.validate(this.flow.parameter, data);
			if (error) {
				return {
					valid: false,
					errors: [ error ]
				};
			}
		}
		return { valid: true };
	}

	/**
	 * Invoke this flow with the specified context.
	 *
	 * @public
	 * @param {object} data - The initial data to execute the flow with.
	 * @param {object} [options] - options - The flow runtime options.
	 * @param {object} [options.logger] - The logger to use for the flow execution.
	 *		Uses the constructor default if not supplied.
	 * @param {object} [options.validateFlowParameter=true] - Validates `data` against flow input parameter.
	 * @returns {Promise} A promise that will be resolved with the final context when the
	 *		flow execution completes.
	 */
	invoke(data, options = {}) {
		const validation = this.getValidation();
		if (!validation.valid) {
			// Abort the flow immediately if not valid.
			return Promise.reject(validation);
		}

		const runtimeValidation = this.getRuntimeValidation(data, options);
		if (!runtimeValidation.valid) {
			// Abort the flow immediately if not valid.
			return Promise.reject(runtimeValidation);
		}

		const ctx = {
			runtime: {
				paths: {
					reverse: this._getReversePaths()
				},
				logger: (options && options.logger) || this.logger
			},
			data
		};

		// Starts flow execution and returns a promise that will wait on
		// termination of all branches of flow.
		const terminationPromise = new Promise((resolve, reject) => {
			try {
				const terminatorPromises = [];

				this.getTerminalNodes(true).forEach((nodeID) => {
					terminatorPromises.push(this._getNodeExecutionPromise(ctx, nodeID));
				});
				Promise.all(terminatorPromises)
					.then(() => {
						return resolve(ctx.data.response);
					})
					.catch((err) => reject(err));

				// resolve unreachable nodes
				this._resolveUnreachableNodePaths(ctx);

				// Execute the flow.
				this._invokeNodes(ctx, [ this.nodeHandlers[this.flow.start] ]);
			} catch (err) {
				reject(err);
			}
		});

		// Abort execution before the completion of the flow
		const abortPromise = this._getNodeExecutionPromise(ctx, '$$.abort')
			.catch((err) => {
				ctx.runtime.flowAborted = true;
				throw err;
			});

		// Race - on error abort the flow, otherwise wait until all nodes complete.
		return Promise.race([ abortPromise, terminationPromise ]);
	}

	/**
	 * Resolve all notes that are unreachable at the outset.
	 * @param {object} ctx - the node context
	 * @private
	 */
	_resolveUnreachableNodePaths(ctx) {
		const next = [ this.flow.start ];
		// make sure all parents of the start node are resolved before starting
		this._resolveParentNodePaths(ctx, next);

		// Find all nodes who aren't children of start and resolve them
		this.getVertices()
			.filter(vertex =>
				vertex.id !== this.flow.start
				&& vertex.parents && Object.keys(vertex.parents).length === 0)
			.forEach(
				(v) => {
					this._pruneUnexecutableBranches({ ctx, next }, v.id);
					this._getNodeExecutionPromise(ctx, v.id).resolve();
				}
			);
	}

	/**
	 * Instantiate all the node handlers
	 *
	 * @private
	 */
	_InstantiateNodeHandlers() {
		this.nodeHandlers = {};
		this.getVertices().forEach(vertex => {
			const node = this.getNode(vertex.id);
			if (node) {
				// Instantiate the node handlers for the flow:
				this.nodeHandlers[vertex.id] = noderegistry.create(vertex.id, node, this);
			}
		});
	}

	getNodeHandlers(keys) {
		return Object.keys(this.nodeHandlers).map(handlerId => {
			if (keys) {
				return handlerId;
			} else {
				return this.nodeHandlers[handlerId];
			}
		});
	}

	getNodeHandler(handlerId) {
		return this.nodeHandlers[handlerId];
	}

	_getReversePaths() {
		const paths = {};
		this.getVertices(true).forEach(vertexId => {
			this.getChildren(vertexId, true).forEach(childId => {
				// Add the reverse path
				paths[childId] = paths[childId] || {};
				paths[childId][vertexId] = true;
			});
		});
		return paths;
	}

	/**
	 * This method handles invoke the nodes when they are ready and processing the result from the
	 * node invocation when it's complete.
	 *
	 * @private
	 * @param {object} ctx - The context to execute the node with.
	 * @param {object[]} nodes - The nodes to execute.
	 */
	_invokeNodes(ctx, nodes) {
		if (!nodes || nodes.length === 0) {
			// Branch is complete
			return;
		}

		nodes.forEach((node) => {
			this._invokeWhenReady(ctx, node)
				.then(
					(result) => this._createNodeResponseContext(ctx, node, result),
					(err) => {
						ctx.runtime.logger.trace(`${this._getNodeDisplayName(node)} rejected: ${err}`);
						throw err;
					})
				.then((respCtx) => this._stopOnAbort(respCtx))
				.then((respCtx) => this._selectOutput(respCtx))
				.then((respCtx) => this._updateContext(respCtx))
				.then((respCtx) => this._resolveExecutionPromise(respCtx))
				.then((respCtx) => this._pruneUnexecutableBranches(respCtx))
				.then((respCtx) => this._invokeNext(respCtx))
				.catch((err) => {
					ctx.runtime.logger.debug(chalk.dim('Aborting flow:', err), err.stack);
					this._getNodeExecutionPromise(ctx, '$$.abort').reject(err);
				});
		});
	}

	/**
	 * Trys to get a formatted display name if a node's id is passed in
	 * Otherwise return the id.
	 * @param  {String} node - The node id to try and format
	 * @return {String}        The formatted node name string or the original id.
	 */
	_getNodeDisplayName (node) {
		const allowedTypes = [ '[object String]', '[object Object]' ];
		const type = Object.prototype.toString.call(node);
		if (allowedTypes.indexOf(type) === -1) {
			return '';
		}
		const id = node.id || node;
		node = typeof node === 'string' ? this.getNode(node) : node.node;
		return formatNodeName({ id, node });
	}
	/**
	 * Recursively prunes and resolves all nodes which occur previous in the flow to a list of nodes.
	 *
	 * @private
	 * @param {object} ctx - The context to set the resolved state on.
	 * @param {object[]} nodes - The nodes to resolve the parents of.
	 */
	_resolveParentNodePaths(ctx, nodes) {
		if (!nodes || nodes.length === 0) {
			return;
		}
		nodes.forEach((node) => {
			ctx.runtime.logger.trace(' ',
				chalk.green(this._getNodeDisplayName(node)), chalk.dim('pruning node parents')
			);
			// get the parents for the node
			const parents = this.getParents(node, true);
			if (!parents.length) {
				ctx.runtime.logger.trace(' ',
					chalk.green(this._getNodeDisplayName(node)), chalk.dim('has no parents')
				);
				return;
			}
			const reversePaths = ctx.runtime.paths.reverse;
			parents.forEach((parent) => {
				ctx.runtime.logger.trace(' ',
					chalk.green(this._getNodeDisplayName(node)), chalk.dim(`found parent ${chalk.cyan(this._getNodeDisplayName(parent))}`)
				);
				// if there isn't a path to the parent then return. (could have already been resolved)
				if (!reversePaths[node][parent]) {
					ctx.runtime.logger.trace(' ',
						chalk.green(this._getNodeDisplayName(node)), chalk.dim('no route back to'), chalk.cyan(this._getNodeDisplayName(parent))
					);
					return;
				}

				// get the siblings of the node (children of the parent)
				const children = this.getChildren(parent, true);
				ctx.runtime.logger.trace(' ',
					chalk.green(this._getNodeDisplayName(node)), chalk.dim(`parent ${chalk.cyan(this._getNodeDisplayName(parent))}`), chalk.dim(`has ${children.length} child nodes`)
				);
				children.forEach((child) => {
					if (child === node) {
						ctx.runtime.logger.trace(' ',
							chalk.green(this._getNodeDisplayName(node)), chalk.dim(`parent ${chalk.cyan(this._getNodeDisplayName(parent))}`),
							chalk.dim(`skipping child ${chalk.yellow(this._getNodeDisplayName(child))} since it's the node that we're resolving parents for`)
						);
						return;
					}

					// cut the path from child to parent
					ctx.runtime.logger.trace(' ',
						chalk.green(this._getNodeDisplayName(node)), chalk.dim(`parent ${chalk.cyan(this._getNodeDisplayName(parent))}`),
						chalk.dim(`removing route back to ${chalk.yellow(this._getNodeDisplayName(child))}`)
					);
					delete reversePaths[child][parent];

					// if the only parent of the child is *this* parent we will prune it
					if (!reversePaths[child] || !Object.keys(reversePaths[child]).length) {
						// cut off all paths from the child
						ctx.runtime.logger.trace(' ',
							chalk.green(this._getNodeDisplayName(node)), chalk.dim(`cutting inactive paths from ${chalk.yellow(this._getNodeDisplayName(child))}`)
						);
						this._cutInactivePath(ctx, child);
						// the child doesn't have any parents remaining, resolve it
						ctx.runtime.logger.debug(' ',
							chalk.green(this._getNodeDisplayName(node)), chalk.dim(`Resolving ${chalk.yellow(this._getNodeDisplayName(child))}`)
						);
						delete reversePaths[child];
						this._getNodeExecutionPromise(ctx, child).resolve();
					}
				});
				// resolve all paths originating from the parent
				this._resolveParentNodePaths(ctx, [ parent ]);
				// if the parent has no parents left then resolve it
				if (!reversePaths[parent] || !Object.keys(reversePaths[parent]).length) {
					ctx.runtime.logger.debug(' ',
						chalk.green(this._getNodeDisplayName(node)), chalk.dim(`Resolving ${chalk.cyan(this._getNodeDisplayName(parent))}`)
					);
					delete reversePaths[parent];
					this._getNodeExecutionPromise(ctx, parent).resolve();
				}
				ctx.runtime.logger.trace(' ',
					chalk.green(this._getNodeDisplayName(node)), chalk.dim(`removing route to ${chalk.cyan(this._getNodeDisplayName(parent))}`)
				);
				// remove the link from the node to the parent
				delete reversePaths[node][parent];
			});
		});
	}

	/**
	 * A node must wait until it is invocable before it can be invoked.
	 *
	 * A node is considered invocable if all paths to this node have been completed
	 * (i.e. all parent nodes have completed.)
	 *
	 * @private
	 * @param {object} ctx - The context to execute the node with.
	 * @param {object} node - The nodes to execute.
	 * @returns {Promise} A promise that is resolved when the node is invokable and that
	 * invocation completes.
	 */
	_invokeWhenReady(ctx, node) {
		ctx.runtime.logger.debug(chalk.dim('Waiting:', this._getNodeDisplayName(node)));
		const nodePromise = new Promise((resolve) => {
			Promise.all(this._getNodeParentExecutionPromises(ctx, node.id)).then(() => {
				ctx.runtime.logger.debug(chalk.dim('Invoking:', this._getNodeDisplayName(node)));
				resolve(node.invoke(ctx));
			});
		});
		return Promise.race([ this._getNodeExecutionPromise(ctx, '$$.abort'), nodePromise ]);
	}

	/**
	 * Create a response context for use in the chain that processes the invoke() response.
	 * The response context is:
	 * {
	 *	flowAborted: boolean,
	 *	ctx: context,
	 *	node: object,
	 *	result: object,
	 *	next: array
	 * }
	 * @private
	 * @param {object} ctx - The context to execute the node with.
	 * @param {string} node - The node name.
	 * @param {object} result - The node invoke result.
	 * @returns {object} An object with the necessary information for further processing.
	 */
	_createNodeResponseContext(ctx, node, result) {
		return {
			flowAborted: !!ctx.runtime.flowAborted,
			ctx,
			node,
			result: result.results,
			output: result.output,
			next: []
		};
	}

	/**
	 * Short circuit processing if the flow has been aborted.
	 * @private
	 * @param {object} responseCtx - The response context for this invocation.
	 * @returns {object} The response context for this invocation (to support chaining).
	 */
	_stopOnAbort(responseCtx) {
		if (responseCtx.flowAborted) {
			throw new Error('Aborted');
		}
		return responseCtx;
	}

	/**
	 * Get the promise that will be resolved when the node is executed.
	 *
	 * @private
	 * @param {object} ctx - The context - execution promises are stored in the context.
	 * @param {string} nodeName - The name of the node to get the promise for.
	 * @returns {Promise} The execution promise for nodeName.
	 */
	_getNodeExecutionPromise(ctx, nodeName) {
		ctx.runtime = ctx.runtime || {};
		const promises = ctx.runtime.promises = ctx.runtime.promises || {};

		if (!promises[nodeName]) {
			const getPromise = () => {
				let execResolve = null;
				let execReject = null;

				const promise = new Promise(function (resolve, reject) {
					execResolve = resolve;
					execReject = reject;
				});
				promise.resolve = execResolve;
				promise.reject = execReject;
				return promise;
			};

			promises[nodeName] = getPromise();
		}

		return promises[nodeName];
	}

	/**
	 * Get the promises that will be resolved when the nodes parents are executed.
	 *
	 * @private
	 * @param {object} ctx - The context - execution promises are stored in the context.
	 * @param {string} nodeId - The id of the node whose parent promises are being requested.
	 * @returns {Promise[]} An array containing the execution promises for nodeNames parent nodes.
	 */
	_getNodeParentExecutionPromises(ctx, nodeId) {
		const parentPromises = [];
		this.getParents(nodeId, true).forEach((parentId) => {
			parentPromises.push(this._getNodeExecutionPromise(ctx, parentId));
		});
		return parentPromises;
	}

	/**
	 * Convenience method to resolve the nodes promise in a thenable chain.
	 *
	 * @private
	 * @param {object} responseCtx - The response context for this invocation.
	 * @returns {object} The response context for this invocation (to support chaining).
	 */
	_resolveExecutionPromise(responseCtx) {
		this._getNodeExecutionPromise(responseCtx.ctx, responseCtx.node.id).resolve();
		return responseCtx;
	}

	/**
	 * Update the context with the result from the node execution.
	 *
	 * @param {object} responseCtx - The response context for this invocation.
	 * @returns {object} The response context for this invocation (to support chaining).
	 */
	_updateContext(responseCtx) {
		const nodeconfig = responseCtx.node.node;
		const output = responseCtx.output && nodeconfig.outputs[responseCtx.output];
		const target = output && output.context;

		if (target && responseCtx.result !== undefined) {
			const result = responseCtx.result;
			responseCtx.ctx.runtime.logger.debug(chalk.green(' ', this._getNodeDisplayName(responseCtx.node)),
				chalk.dim('writing'),
				chalk.yellow(JSON.stringify(result)),
				chalk.dim('to ctx as:'),
				chalk.cyan(target));

			jsonpath.value(responseCtx.ctx.data, target, result);
		}

		return responseCtx;
	}

	/**
	 * Update the response context with the nodes that will be executed next.
	 *
	 * @private
	 * @param {object} respCtx - The response context for this invocation.
	 * @returns {object} The response context for this invocation (to support chaining).
	 */
	_selectOutput(respCtx) {
		const nodeconfig = respCtx.node.node;
		const output = respCtx.output && nodeconfig.outputs[respCtx.output];

		if (output) {
			respCtx.next = output.routes ? output.routes : [];
		}
		respCtx.ctx.runtime.logger.debug(' ', chalk.green(this._getNodeDisplayName(respCtx.node)),
			'route:', chalk.dim(JSON.stringify(respCtx.next)));
		return respCtx;
	}

	/**
	 * Remove the paths that are no longer executable
	 *
	 * @private
	 * @param {object} responseCtx - The response context for this invocation.
	 * @param {string} sourceId - optional - the id of the node to start pruning from.
	 * @returns {object} The response context for this invocation (to support chaining).
	 */
	_pruneUnexecutableBranches(responseCtx, sourceId) {
		if (!sourceId) {
			sourceId = responseCtx.node.id;
		}
		const inactivePaths = this.getChildren(sourceId, true)
			.filter((child) => responseCtx.next.indexOf(child) === -1)
			.map((child) => ({ source: sourceId, target: child }));
		this._cutInactivePath(responseCtx.ctx, inactivePaths);
		return responseCtx;
	}

	/**
	 * Remove the paths that are no longer active.
	 *
	 * @private
	 * @param {object} ctx - The flow context.
	 * @param {(object[]|string)} inactivePaths - The list of paths that are no longer
	 *		active. If a single node name is specified then all children are cut.
	 * @param {string} inactivePaths[].source - The source node.
	 * @param {string} inactivePaths[].target - The target node.
	 */
	_cutInactivePath(ctx, inactivePaths) {
		if (!inactivePaths) {
			return;
		} else if (typeof inactivePaths === 'string' || inactivePaths instanceof String) {
			// All children of the specified node
			inactivePaths = this.getChildren(inactivePaths, true)
				.map((childId) => ({ source: inactivePaths, target: childId }));
		}

		if (!inactivePaths.length) {
			return;
		}

		const reversePaths = ctx.runtime.paths.reverse;

		// Filter out the inactive paths from the runtime graph
		inactivePaths.forEach((path) => {
			// if the target hasn't already been resolved, and the target still has reverse link to source
			if (reversePaths[path.target] && reversePaths[path.target][path.source]) {
				// remove the source as a parent of the target node
				delete reversePaths[path.target][path.source];
				// only resolve nodes which have no parents left
				if (!Object.keys(reversePaths[path.target]).length) {
					// No more paths to this node so resolve it's execution promise and clean up.
					delete reversePaths[path.target];
					this._getNodeExecutionPromise(ctx, path.target).resolve();
					this._cutInactivePath(ctx, path.target);
				}
			}
		});
	}

	/**
	 * Invoke the next nodes, called after updateContext (which detects the next nodes).
	 * Note nodes will only be invoked once.
	 *
	 * @private
	 * @param {object} responseCtx - The response context for this invocation.
	 * @returns {object} The response context for this invocation (to support chaining).
	 */
	_invokeNext(responseCtx) {
		const ctx = responseCtx.ctx;
		const pending = ctx.pending = ctx.pending || {};
		const nextNodeKeys = responseCtx.next;
		const nextNodes = [];

		// Invoke the next node if it's not already pending
		nextNodeKeys.forEach((nodeKey) => {
			if (!pending.hasOwnProperty(nodeKey)) {
				const next = this.nodeHandlers[nodeKey];
				nextNodes.push(next);
				pending[nodeKey] = true;
			}
		});

		this._invokeNodes(ctx, nextNodes);

		return responseCtx;
	}

	/**
	 * Gets the node handler definition.
	 * @public
	 * @param {string} node - The node handler.
	 * @returns {object} the node spec
	 */
	getNodeSpec(node) {
		return noderegistry.getNodeSpec(node.type);
	}
}

exports = module.exports = Flow;
