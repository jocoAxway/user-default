const fs = require('fs');
const consoleLogger = require('./logger');

/**
 * Returns a new constructed error for an upgrade with a blame message
 *
 * @param {string} reason - reason why upgrade failed
 * @param {object} upgrade - the upgrade which failed
 * @param {string} details - upgrade error details
 * @returns {Error} the constructed error
 */
function errorAndBlame(reason, upgrade, details) {
	const { from, to, id, owner, stage } = upgrade;
	const info = `Upgrade details: ${JSON.stringify({ from, to, id, stage }, null, 2)}`;
	let err = `${reason}.\n${info}`;
	if (owner) {
		err += `\nThis is probably the fault of ${owner}`;
	} else {
		err += '\n The owner was not specified';
	}
	if (details) {
		err += `\n${details}`;
	}
	return new Error(err);
}

/**
 * Calls a callback promise asyncronously for each item in the passed array
 *
 * @param {any} items - items to iterate over
 * @param {Promise} cb - promise to call for each item
 * @param {any} originalData - this wil be what the fisrt promise resolves with
 * @returns {Promise} the promise chain
 */
function promiseForEach(items, cb, originalData) {
	let promise = Promise.resolve(originalData);
	if (items && items.length) {
		items.forEach((currentItem) => {
			promise = promise.then((result) => {
				return cb(currentItem, result);
			});
		});
	}
	return promise;
}

/**
 * The Upgrade manager.
 * @public
 * @class
 */
class UpgradeManager {
	/**
	 * Create an class which registers and perfoms upgrades on data.
	 * @constructor
	 * @param {object} logger - The internal logger to use.
	 */
	constructor(logger) {
		this.logger = logger || consoleLogger;
		this.types = {};
		this.upgrades = {};
		this.registerUpgrades = this.registerUpgrades.bind(this);
		this.unregisterUpgrades = this.unregisterUpgrades.bind(this);
		this.registerUpgradeType = this.registerUpgradeType.bind(this);
		this._getUpgrade = this._getUpgrade.bind(this);
		this._registerUpgrade = this._registerUpgrade.bind(this);
		this._unregisterUpgrade = this._unregisterUpgrade.bind(this);
		this._upgradeVersion = this._upgradeVersion.bind(this);
		this._runUpgrade = this._runUpgrade.bind(this);
	}

	/**
	 * Registers an array of upgrades
	 *
	 * @param {array} upgrades - upgrades to register
	 */
	registerUpgrades(upgrades) {
		Object.values(upgrades).forEach(this._registerUpgrade);
	}

	/**
	 * Unregisters an array of upgrades
	 *
	 * @param {array} upgrades - upgrades to unregister
	 */
	unregisterUpgrades(upgrades) {
		Object.values(upgrades).forEach(this._unregisterUpgrade);
	}

	/**
	 * Registers a data type to handle upgrades for
	 *
	 * @param {string} type - the type to register
	 * @param {object} accessors - functions to let the upgrade manager access and modify the data
	 * @param {function} accessors.getId - function which returns the ID of the data.
	 *                                     takes the data and the file path if specified
	 * @param {function} accessors.getVersion - function which returns the version of the data passed
	 * @param {function} accessors.setVersion - function which sets the version of the data
	 *                                          passed and returns the updated data
	 * @param {function} validator - function which returns a promise that validates the data.
	 *                               This will be run after each upgrade
	 */
	registerUpgradeType(type, accessors, validator) {
		this.logger.debug(`Registering upgrade handler for ${type}`);

		// Validate the upgrade type
		if (this.types[type]) {
			throw new Error(`Upgrade handler for ${type} already exists`);
		}
		[ 'getId', 'getVersion', 'setVersion' ].forEach(key => {
			if (!accessors[key] || (typeof accessors[key] !== 'function')) {
				throw new Error(`Upgrade handle must register accessor method for ${key}`);
			}
		});

		// Save the type (eg flow)
		this.types[type] = {
			type,
			validator,
			accessors: {
				getId: accessors.getId,
				getVersion: accessors.getVersion,
				setVersion: accessors.setVersion
			}
		};

		// Setup a place to save this type's upgrades
		this.upgrades[type] = {};

		// Assign an updator method e.g. upgradeManager.upgradeFlow(data, filePath);
		this[`upgrade${type.charAt(0).toUpperCase() + type.slice(1)}`] = this._getUpgrade(type);
	}

	/**
	 * Unregisters an upgrade type and all registered upgrades for that type
	 *
	 * @param {string} type - the type to unregister
	 */
	unregisterUpgradeType(type) {
		if (type && this.types[type]) {
			delete this.types[type];
			delete this.upgrades[type];
			delete this[`upgrade${type.charAt(0).toUpperCase() + type.slice(1)}`];
		}
	}

	/**
	 * Get a function to upgrade data of a certain type
	 *
	 * @param {string} type - type of the data to generate an upgrade function for
	 * @returns {function} upgrade function for data of the specified type
	 */
	_getUpgrade(type) {
		return (data, filePath, options) => {
			this.logger.debug(`Running upgrade for ${type}`);
			const { getVersion, getId } = this.types[type].accessors;
			const upgrades = this.upgrades[type];

			// Determine the upgrade sequence. Must be increasing
			const upgradePath = [];
			let currentVersion = getVersion(data);
			do {
				const nextVersion = upgrades[currentVersion] && upgrades[currentVersion].to;
				if (nextVersion) {
					upgradePath.push(nextVersion);
				}
				currentVersion = nextVersion;
			} while (currentVersion);

			// If we couldn't map out an upgrade sequence just resolve the un-upgraded data
			if (!upgradePath.length) {
				return Promise.resolve(data);
			}

			const id = getId(data, filePath);

			// Run each upgrade sequentially
			return promiseForEach(upgradePath, (to, upgradedData) => {
				return this._upgradeVersion(type, upgradedData, id);
			}, data).then((newData) => {
				return new Promise((resolve) => {
					this.logger.debug(`${type} upgrade was successful`);
					// Save if specified
					if (options && filePath && options.save) {
						return fs.writeFile(filePath, JSON.stringify(newData, null, 2), 'utf-8', (err) => {
							if (err) {
								this.logger.error(`There was a problem saving ${type} data for ${id} after upgrade\n${err}`);
							}
							return resolve(newData);
						});
					}
					return resolve(newData);
				});
			});
		};
	}

	/**
	 * Registers an upgrade to the manager.
	 * Will throw if upgrade is invalid.
	 *
	 * @param {object} upgrade - upgrade definition
	 */
	_registerUpgrade(upgrade) {
		const { to, from, stage, type } = upgrade;
		// validate upgrade
		const errStart = `Cannot register ${type} upgrade:`;
		const validStages = [ 'pre', 'post', 'main' ];
		const required = [ 'to', 'from', 'stage', 'fn', 'owner', 'id', 'type' ];
		required.forEach(key => {
			if (!upgrade[key]) {
				throw errorAndBlame(`${errStart} missing required property '${key}'`, upgrade);
			}
		});
		if (!this.types[type]) {
			throw errorAndBlame(`${errStart} type is unknown`, upgrade);
		}
		if (!validStages.includes(stage)) {
			throw errorAndBlame(`${errStart} Upgrade stage must be one of ${JSON.stringify(validStages)}`, upgrade);
		}
		if (from >= to) {
			throw errorAndBlame(`${errStart} Upgrades cannot go to a previous version`, upgrade);
		}
		const upgrades = this.upgrades[type];
		if (stage === 'main') {
			// You can only have one path from n. You can't have 1 to 2 and 1 to 4.
			if (upgrades[from]) {
				throw errorAndBlame(`${errStart} Upgrade already exists from version ${from}`, upgrade);
			}
			// Register main upgrade
			upgrades[from] = {
				to,
				from,
				pre: [],
				main: upgrade,
				post: []
			};
		} else if (!upgrades[from]) {
			// A 'main' upgrade has to be registered first
			throw errorAndBlame(`${errStart} No upgrade path exists`, upgrade);
		} else {
			// Register pre/post upgrade
			upgrades[from][stage].push(upgrade);
		}
	}

	/**
	 * Unregisters an upgrade from the manager
	 *
	 * @param {object} upgrade - upgrade definition
	 */
	_unregisterUpgrade(upgrade) {
		const { owner, id, stage, from, to, type } = upgrade;
		if (!this.upgrades[type] || !this.upgrades[type][from]) {
			return;
		}
		const u = this.upgrades[type];
		if (stage === 'main') {
			delete u[from];
		} else {
			const upgrades = u[from][stage];
			if (!upgrades) {
				return;
			}
			const index = upgrades.findIndex(x => {
				return x.from === from
					&& x.to === to
					&& x.id === id
					&& x.owner === owner
					&& x.stage === stage;
			});
			if (index < 0) {
				return;
			}
			upgrades.splice(index, 1);
		}
	}

	/**
	 * Runs a single version upgrade for a certain type on some data.
	 *
	 * @param {string} type - the type of data to upgrade
	 * @param {any} data - the data to upgrade
	 * @param {string} id - the ID of the data being upgraded
	 * @returns {Promise} a promise which resolves with the upgraded data
	 *                    or rejects if the upgrade or validation fails.
	 */
	_upgradeVersion(type, data, id) {
		if (!type || !this.types[type]) {
			return Promise.reject(new Error(`Upgrade type ${type} is not registered`));
		}
		const version = this.types[type].accessors.getVersion(data);
		const update = this.upgrades[type][version];
		if (!update) {
			return Promise.reject(new Error(`No upgrade registered from version ${version}`));
		}
		this.logger.debug(`Upgrading ${type} ${id} from version ${version} to version ${update.to}`);
		// run all upgrades
		return promiseForEach([ ...update.pre, update.main, ...update.post ], (upgrade, upgradedData) => {
			return this._runUpgrade(upgradedData, upgrade);
		}, data);
	}

	/**
	 * Runs a single upgrade stage for some data
	 *
	 * @param {any} data - the data to upgrade
	 * @param {object} upgrade - the upgrade definition to run on the data.
	 * @returns {Promise} a promise which resolves with the upgraded data
	 *                    or rejects if the upgrade or validation fails.
	 */
	_runUpgrade(data, upgrade) {
		const { type, stage, from, to, owner, id } = upgrade;
		const validator = this.types[type].validator;
		this.logger.debug(`Running ${type} ${stage} upgrade step from version ${from} to version ${to} ([${owner}] ${id})`);
		if (upgrade.stage === 'main') {
			// set the version to the new version
			this.types[type].accessors.setVersion(data, to);
		}
		const getRejectionPromise = (err) => {
			return Promise.reject(errorAndBlame(`${type} upgrade failed`, upgrade, err));
		};

		let promise;
		try {
			// catch anything thrown syncronously
			promise = upgrade.fn(data);
		} catch (err) {
			return getRejectionPromise(err);
		}

		return promise
			.catch(getRejectionPromise)
			.then((upgradedData) => {
				if (!validator) {
					return Promise.resolve(upgradedData);
				}
				return validator(upgradedData)
					.catch(validationError => {
						return Promise.reject(errorAndBlame(
							`${type} validation failed after upgrade step`,
							upgrade,
							validationError
						));
					})
					.then(() => {
						return Promise.resolve(upgradedData);
					});
			});
	}
}

exports = module.exports = UpgradeManager;
