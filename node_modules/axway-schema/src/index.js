/**
 * @module axway-schema
 * @typicalname axway-schema
 * @exports axway-schema
 *
 * @example <caption>Quick start</caption>
 * ```javascript
 *  const schemas = require('axway-schema');
 *  schemas.add('./schemas/foo.json')
 *	  .add('./schemas/bar.json', 'schema://myservice/bar')
 *	  .add('./schemas/swagger-v2.0.json')
 *	  .loadSync();
 *  schemas.get('schema:///foo');
 *  schemas.validate('schema:///foo', foo);
 *  schemas.get('schema:///foo/myservice/bar');
 *  schemas.validate('schema:///foo/myservice/bar', bar);
 *  schemas.get('http://swagger.io/v2/schema.json#');
 *  schemas.validate('http://swagger.io/v2/schema.json#', swagger);
 *  schemas.dereference(swagger);
 *  schemas.dereference(swagger, { target: '#/definitions' });
 *  schemas.dereference(swagger, { target: '#/definitions', rename: (id) => { return 'foo'; } });
 * ```
 */
const fs = require('fs');
const path = require('path');
const Ajv = require('ajv');
const jsonpointer = require('json-pointer');
const jsonrefs = require('json-refs');
const URI = require('uri-js');
const draft04schema = require('ajv/lib/refs/json-schema-draft-04.json');

const MAX_RECURSION_DEPTH = 10;

/**
 * @private
 */
class Singleton {
	static declare(key, Clazz) {
		const globalSymbols = Object.getOwnPropertySymbols(global);
		const symbol = Symbol.for(key);
		const exists = (globalSymbols.indexOf(symbol) > -1);
		// no dupes
		if (!exists) {
			global[symbol] = new Clazz();
		}
		Object.defineProperty(Clazz, 'instance', {
			get: () => {
				return global[symbol];
			}
		});
		Object.freeze(Clazz);
	}

	static get(key) {
		const globalSymbols = Object.getOwnPropertySymbols(global);
		const symbol = Symbol.for(key);
		const exists = (globalSymbols.indexOf(symbol) > -1);
		// no dupes
		if (!exists) {
			throw new Error(`failed to find singleton: ${key}`);
		}
		return global[symbol];
	}
}

/**
 * A schema manager.
 * @public
 * @class
 */
class AxwaySchema {
	/**
	 * Constructs a schema manager.  The instance is a singleton.
	 * @public
	 */
	constructor() {
		this.scheme = 'schema://';
		this.global = [];
		this.clear();
	}

	/**
	 * Sets the Logger
	 * @param {Logger} logger - A logger.
	 * @public
	 */
	setLogger(logger) {
		this.logger = logger;
	}

	/**
	 * Adds an item to be loaded later by calling
	 * [loadSync]{@link #module_axway-schema..AxwaySchema+loadSync}.
	 * The `item` can be a `string`, in which case it is a schema file, and an optional `defaultId`
	 * will be used for the `id` if the file does not have an `id`.  If the file does not have an
	 * `id` and no `defaultId` is supplied, the function will throw.
	 *
	 * If the `item` is an object, it is a valid schema that has an `id` defined so that
	 * it can be referenced later.  In this case, `defaultId` is ignored.
	 *
	 * @example <caption>Add a schema</caption>
	 * ```javascript
	 *  const schemas = new AxwaySchema();
	 *  schemas.add('./schema1.json');
	 *  schemas.add('./schema2.json', 'schema://service/myapp/schema2.json');
	 *  schemas.add({id: 'http://axway.com/schemas/user.json'});
	 * ```
	 *
	 * @param {string|object} item - The item to add (a filename or schema).
	 * @param {string} [defaultId] - The item id if one not supplied.
	 * @return {AxwaySchema} The {@link AxwaySchema} object.
	 * @public
	 */
	add(item, defaultId) {
		const type = typeof item;
		// object schema
		if (type === 'object') {
			if (!item.id || item.id === 'schema:///') {
				throw new Error('schema that are added directly require an id so that it can be referenced later');
			} else if (item.id.startsWith('schema://') && !item.id.startsWith('schema:///')) {
				throw new Error(`schema that are added directly require an id that has no host: ${item.id}`);
			}
			this.items.push({ schema: item });
			return this;
		} else if (type !== 'string') {
			throw new TypeError('item must be a string or object');
		}
		// string (file)
		const stats = fs.statSync(item);
		if (stats.isFile()) {
			this.items.push({
				defaultId,
				path: item
			});
		} else {
			throw new Error(`not a file: ${item}`);
		}
		return this;
	}

	/**
	 * Registers a global schema that will persist across calls to
	 * [clear]{@link #module_axway-schema..AxwaySchema+clear} operations.  Schemas registered with
	 * the same `id` will generate a warning but will be ignored.
	 *
	 * @param {object} schema - The schema.
	 * @return {AxwaySchema} The {@link AxwaySchema} object.
	 */
	register(schema) {
		const type = typeof(schema);
		// array
		if (type === 'object' && schema instanceof Array) {
			schema.forEach(item => this.register(item));
			return this;
		}

		if (type !== 'object') {
			throw TypeError('invalid parameter: schema');
		}
		const exists = this.global.find(a => a.id === schema.id);
		if (exists) {
			this.logger && this.logger.warn(`a schema already exists with this id: ${schema.id}`);
			return this;
		}
		this.global.push(schema);
		return this;
	}

	/**
	 * Loads all schemas previously added with calls to
	 * [add]{@link #module_axway-schema..AxwaySchema+add}.
	 *
	 * @example <caption>Load schemas</caption>
	 * ```javascript
	 *  const schemas = new AxwaySchema();
	 *  schemas
	 *	  .add('./schema1.json');
	 *	  .add('./schema2.json', 'service');
	 *	  .loadSync());
	 * ```
	 *
	 * @return {AxwaySchema} The {@link AxwaySchema} object.
	 * @public
	 */
	loadSync() {
		// reload global schemas if not already loaded
		let schemas = [];
		if (this.global.length) {
			schemas = schemas.concat(
				// ajv will store the id as lower-case
				this.global.filter(a => !this.ids.hasOwnProperty(a.id))
			);
		}

		this.items.forEach(item => {
			let schema;
			if (item.schema) {
				schema = JSON.parse(JSON.stringify(item.schema));
			} else {
				schema = this._loadSchemaFile(item.path, item.defaultId);
			}
			schemas.push(schema);
		});

		if (schemas.length) {
			this.logger && this.logger.debug(`loading ${schemas.length} schema`);
			// every schema will have an `id` when adding, otherwise there is no point in
			// it - it will be inaccessible.
			this.ajv.addSchema(schemas);
			// record all ids
			schemas.forEach(schema => {
				this.logger && this.logger.debug(`loaded: ${schema.id}`);
				this.ids[schema.id] = true;
			});
		} else {
			this.logger && this.logger.trace('no schemas to load');
		}
		// reset items to be loaded (this is faster than: `items = []`)
		// https://jsperf.com/array-destroy
		this.items.length = 0;
		return this;
	}

	/**
	 * Clears all schemas and resets state.  All registered schema will be automatically re-added
	 * on next load.
	 *
	 * @public
	 * @return {AxwaySchema} The {@link AxwaySchema} object.
	 */
	clear() {
		this.ajv = new Ajv({ unknownFormats: 'ignore' });
		this.ajv.addFormat('multiline', () => true);
		this.ajv.addMetaSchema(draft04schema);
		this.items = [];
		this.ids = {};
		return this;
	}

	/**
	 * Tests whether or not a schema is loaded, identified by `id`.
	 *
	 * @param {string} id - The schema identifier to test.
	 * @return {boolean} True if the schema exists.
	 * @public
	 */
	exists(id) {
		const schema = this.get(id);
		return !!schema;
	}

	/**
	 * Gets a schema by `id`.  If `id` is not supplied, all schemas are returned.
	 *
	 * @param {string} [id] - The schema identifier.
	 * @return {object} Returns a schema identified by `id`.
	 * @public
	 */
	get(id) {
		this._ensureLoaded();
		// the object returned by `getSchema` is a function but it also has a `schema`
		// property.  to avoid confusion, just return the schema.
		if (id) {
			const schema = this.ajv.getSchema(id);
			return schema && schema.schema;
		}
		return Object.keys(this.ids).map(sid => {
			return this.ajv.getSchema(sid).schema;
		});
	}

	/**
	 * Validates an object `obj` against a schema previously added with
	 * [add]{@link #module_axway-schema..AxwaySchema+add} or
	 * [register]{@link #module_axway-schema..AxwaySchema+register}
	 * and identified by `id`, or if `id` is a JSON schema object, `obj` is validated
	 * against that.
	 *
	 * @param {string|object} id - The schema identifier or object.
	 * @param {*} obj - The object to validate.
	 * @return {string} Returns an error string when not valid, undefined otherwise.
	 * @public
	 */
	validate(id, obj) {
		this._ensureLoaded();
		let validate;
		if (!obj || typeof (obj) !== 'object') {
			throw TypeError('invalid parameter: obj');
		}
		if (typeof (id) === 'string') {
			validate = this.ajv.getSchema(id);
			if (!validate) {
				throw Error(`schema not loaded: ${id}`);
			}
		} else if (id && typeof (id) === 'object') {
			try {
				validate = this.ajv.compile(id);
			} catch (err) {
				throw Error(`failed to compile schema: ${err}`);
			}
		} else {
			throw TypeError('invalid parameter: id');
		}
		const valid = validate(obj);
		if (!valid) {
			const name = (typeof (id) === 'object') ? '[object]' : path.basename(id);
			return this.getErrorString(validate.errors, name);
		}
	}

	_doderef(opts) {
		const { target, rename, ref, refpath, derefed } = opts;
		if (!ref || !ref.uri) {
			throw new Error(`schema uri does not exist: ${refpath}`);
		}
		// It is possible for schema A to reference B, and for B to reference A.  In this
		// case, when A is dereferenced, it will write a new $ref to B, which is normal,
		// except that B references A, which can cause an infinite loop.  To avoid that,
		// check to see that when we process B, see if A has already been dereferenced and
		// if so, update B to use the existing, expanded reference.
		if (derefed.hasOwnProperty(ref.uri)) {
			if (target) {
				jsonpointer.set(opts.newdoc, refpath.substring(1), { $ref: derefed[ref.uri] });
				return;
			} else {
				// If not expanding into a target location, then it is impossible to expand
				// this schema inline, bail.
				throw new Error(`infinite loop detected: ${refpath}`);
			}
		}
		this.logger && this.logger.trace(`dereferencing ref ${ref.uri} for ${refpath}`);

		if (opts.depth > MAX_RECURSION_DEPTH) {
			throw new Error(`Exceeded maximum recursion depth of ${MAX_RECURSION_DEPTH}`);
		}

		// Check the reference.  If it is a reference to an item in the same document, then
		// fetch the schema from Ajv, combining the local fragment with the main URI of the
		// parent document.
		let schema;
		if (ref.type === 'local') {
			// fetch from parent schema with local fragment
			const uri = URI.serialize(
				Object.assign({}, opts.parentUri, { fragment: ref.uriDetails.fragment })
			);
			schema = this.get(uri);
			if (!schema) {
				throw new Error(`sub-schema does not exist: ${uri}`);
			}
		} else {
			schema = this.get(ref.uri);
			if (!schema) {
				throw new Error(`schema does not exist: ${ref.uri}`);
			}
		}

		// Swagger does not like `id` and `$schema`, so remove them.
		const cloned = JSON.parse(JSON.stringify(schema));
		delete cloned.id;
		delete cloned.$schema;
		if (!target) {
			// Inline dereference
			const reftarget = refpath.substring(1);
			if (!reftarget) {
				// if the refpath is `#` then this should become root /,
				// which is just replacing the whole object.
				this.logger && this.logger.warn('inline deref at root /');
				opts.newdoc = cloned;
			} else {
				this.logger && this.logger.warn(`inline deref at ${reftarget} when dereferencing ${ref.uri}`);
				jsonpointer.set(opts.newdoc, reftarget, cloned);
			}
			derefed[ref.uri] = true;
		} else {
			// Expand at target location (e.g. `#/definitions`) and update `$ref`.
			const name = rename ? rename(ref.uri) : path.basename(ref.uri, '.json');
			const targetpath = `${target.substring(1)}/${name}`;
			// escaping slashes and tilde for jsonpointer (https://tools.ietf.org/html/rfc6901)
			const escTargetref = `${target}/${name.replace(/~/, '~0').replace(/\//, '~1')}`;
			const escTargetpath = `${target.substring(1)}/${name.replace(/~/, '~0').replace(/\//, '~1')}`;

			if (jsonpointer.has(opts.newdoc, escTargetpath)) {
				this.logger && this.logger.warn(`updated existing data at ${targetpath} when dereferencing ${ref.uri}`);
			}
			jsonpointer.set(opts.newdoc, escTargetpath, cloned);

			// If the reference type is not local, then change the reference (e.g. "remote")
			// to a local reference.  Else, find the "local" references in the target document
			// and rewrite the $ref to the new target location.
			if (opts.ref.type !== 'local') {
				jsonpointer.set(opts.newdoc, refpath.substring(1), { $ref: escTargetref });
			} else {
				const existingRefs = jsonrefs.findRefs(opts.newdoc, {
					filter: eref => eref.uri === ref.def.$ref
				});
				Object.keys(existingRefs).forEach(eref => {
					existingRefs[eref].def.$ref = escTargetref;
				});
			}
			// Store deref to not hit infinite loop
			derefed[ref.uri] = `#${escTargetpath}`;
		}

		// Some schema have local definitions.  E.g. our flow-schema references #/definitions/node
		// of the same schema.  Those local definitions also need to be recursively expanded into
		// the target document.
		const subrefs = jsonrefs.findRefs(schema, { filter: [ 'local' ] });
		Object.keys(subrefs).forEach(subrefpath => this._doderef({
			newdoc: opts.newdoc,
			target,
			rename,
			ref: subrefs[subrefpath],
			refpath: subrefpath,
			parentUri: opts.parentUri || ref.uriDetails,
			derefed,
			depth: opts.depth + 1
		}));
	}

	/**
	 * Callback function to rename a target when used as a
	 * [dereference]{@link #module_axway-schema..AxwaySchema+dereference} target.
	 * For example, if your id is "schema://svc.foo/bar", then `bar` will be written
	 * to the dereference target as `bar`.  If you want to rename `bar`, then use
	 * this function.
	 * @public
	 * @callback targetRenameCallback
	 * @param {id} id - The schema id.
	 * @return {string} Return the renamed target.
	 */

	/**
	 * Dereferences non-local references in the supplied document.  The supplied
	 * document is not modified.  All non-local references (e.g `schema://`) will
	 * be replaced with the corresponding loaded schema.  If schema are not found,
	 * an error will be thrown.
	 *
	 * If `options.target` is not supplied, then references are expanded inline.  If
	 * `options.target` is supplied, then references are expanded in the location specified
	 * by `options.target` and any existing reference updated to point to the new target.
	 * For example, if the `options.target` is `#/definitions`, then the schema will be
	 * expanded to `$.definitions` with the name of the schema the trailing component
	 * (basename) of its `id`, or if `options.rename` is supplied, the name
	 * returned by that.
	 *
	 * @param {object} doc - A document
	 * @param {object} [options] - Options
	 * @param {string} [options.target] - A target
	 * @param {targetRenameCallback} [options.rename] - A callback to rename schema
	 * @return {object} Returns a document with `schema://` references expanded.
	 * @public
	 */
	dereference(doc, options) {
		this._ensureLoaded();
		if (!doc || typeof doc !== 'object') {
			throw TypeError('invalid parameter: doc');
		}
		if (options && typeof options !== 'object') {
			throw TypeError('invalid parameter: options');
		}
		const newdoc = JSON.parse(JSON.stringify(doc)); // deep copy
		let complete = false;
		const derefed = {};
		// for every $ref identified, get the schema for it and replace it in `newdoc`, either by
		// replacing it inline, or if `target` is supplied, expanding it into the target location
		// and updating the $ref to point to the new target location.
		do {
			// filter all refs that are not doc anchors
			const refs = jsonrefs.findRefs(newdoc, { filter: [ 'remote' ] });
			const paths = Object.keys(refs);
			const target = options && options.target;
			const rename = options && options.rename;
			complete = !paths.length;
			paths.forEach(refpath => this._doderef({
				newdoc,
				target,
				rename,
				ref: refs[refpath],
				refpath,
				derefed,
				depth: 0
			}));
		} while (!complete);
		return newdoc;
	}

	/**
	 * The ajv.errorsText is actually not very good.
	 *
	 * @param {array} errors - ajv errors object
	 * @param {string} objectType - The name of the object type that was validated
	 * @return {string} A formatted error string.
	 * @public
	 */
	getErrorString(errors, objectType) {
		return errors.map(err => {
			const dataPath = err.dataPath ? `$${err.dataPath}` : `${objectType} root`;
			return `at schema ${err.schemaPath}, ${dataPath} ${err.message} (${JSON.stringify(err.params)})`;
		}).join('. ');
	}

	/**
	 * Ensures [loadSync]{@link #module_axway-schema..AxwaySchema+loadSync} was called after
	 * [add]{@link #module_axway-schema..AxwaySchema+add} - throws if not loaded.
	 *
	 * @private
	 */
	_ensureLoaded() {
		if (this.items.length) {
			throw new Error('call `loadSync` to finish adding items.');
		}
	}

	/**
	 * Loads a schema from file.
	 * @param {string} fpath - The file path to load.
	 * @param {string} [defaultId] - An optional default id the schema.
	 * @return {object} A parsed JSON schema file.
	 * @private
	 */
	_loadSchemaFile(fpath, defaultId) {
		const contents = fs.readFileSync(fpath, 'utf8');
		const parsed = JSON.parse(contents);
		if (!parsed.id) {
			parsed.id = defaultId;
			if (!defaultId) {
				throw new Error(`schema id must be defined: ${fpath}`);
			}
		}
		this.logger && this.logger.trace(`loaded schema file: ${fpath} with id ${parsed.id}`);
		return parsed;
	}
}

Singleton.declare('axway-schema-singleton', AxwaySchema);

exports = module.exports = Singleton.get('axway-schema-singleton');
